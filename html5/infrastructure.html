<!DOCTYPE html>

<html lang="ko">
<head>
  <meta charset="utf-8">

  <title>공통 인프라 - HTML5</title>
  <script src="link-fixup.js"></script>
  <link href='bower_components/NanumBarunGothic/nanumbarungothic.css' rel='stylesheet' type='text/css'>
  <style type="text/css">
   body {line-height:1.5;font-family:'Nanum Barun Gothic', sans-serif !important}
     .applies thead th > * { display: block; }
     .applies thead code { display: block; }
     .applies tbody th { white-space: nowrap; }
     .applies td { text-align: center; }
     .applies .yes { background: yellow; }

     .matrix, .matrix td { border: hidden; text-align: right; }
     .matrix { margin-left: 2em; }

     .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
     .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
     .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

     td.eg { border-width: thin; text-align: center; }

     #table-example-1 { border: solid thin; border-collapse: collapse; margin-left: 3em; }
     #table-example-1 * { font-family: "Essays1743", serif; line-height: 1.01em; }
     #table-example-1 caption { padding-bottom: 0.5em; }
     #table-example-1 thead, #table-example-1 tbody { border: none; }
     #table-example-1 th, #table-example-1 td { border: solid thin; }
     #table-example-1 th { font-weight: normal; }
     #table-example-1 td { border-style: none solid; vertical-align: top; }
     #table-example-1 th { padding: 0.5em; vertical-align: middle; text-align: center; }
     #table-example-1 tbody tr:first-child td { padding-top: 0.5em; }
     #table-example-1 tbody tr:last-child td { padding-bottom: 1.5em; }
     #table-example-1 tbody td:first-child { padding-left: 2.5em; padding-right: 0; width: 9em; }
     #table-example-1 tbody td { padding-left: 2em; padding-right: 2em; }
     #table-example-1 tbody td:first-child + td { width: 10em; }
     #table-example-1 tbody td:first-child + td ~ td { width: 2.5em; }
     #table-example-1 tbody td:first-child + td + td + td ~ td { width: 1.25em; }

     .apple-table-examples { border: none; border-collapse: separate; border-spacing: 1.5em 0em; width: 40em; margin-left: 3em; }
     .apple-table-examples * { font-family: "Times", serif; }
     .apple-table-examples td, .apple-table-examples th { border: none; white-space: nowrap; padding-top: 0; padding-bottom: 0; }
     .apple-table-examples tbody th:first-child { border-left: none; width: 100%; }
     .apple-table-examples thead th:first-child ~ th { font-size: smaller; font-weight: bolder; border-bottom: solid 2px; text-align: center; }
     .apple-table-examples tbody th, .apple-table-examples tfoot th { font: inherit; text-align: left; }
     .apple-table-examples td { text-align: right; vertical-align: top; }
     .apple-table-examples.e1 tbody tr:last-child td { border-bottom: solid 1px; }
     .apple-table-examples.e1 tbody + tbody tr:last-child td { border-bottom: double 3px; }
     .apple-table-examples.e2 th[scope=row] { padding-left: 1em; }
     .apple-table-examples sup { line-height: 0; }

     .details-example img { vertical-align: top; }

     #base64-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 6em;
       column-count: 5;
       column-gap: 1em;
       -moz-column-width: 6em;
       -moz-column-count: 5;
       -moz-column-gap: 1em;
       -webkit-column-width: 6em;
       -webkit-column-count: 5;
       -webkit-column-gap: 1em;
     }
     #base64-table thead { display: none; }
     #base64-table * { border: none; }
     #base64-table tbody td:first-child:after { content: ':'; }
     #base64-table tbody td:last-child { text-align: right; }

     #named-character-references-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 30em;
       column-gap: 1em;
       -moz-column-width: 30em;
       -moz-column-gap: 1em;
       -webkit-column-width: 30em;
       -webkit-column-gap: 1em;
     }
     #named-character-references-table > table > tbody > tr > td:first-child + td,
     #named-character-references-table > table > tbody > tr > td:last-child { text-align: center; }
     #named-character-references-table > table > tbody > tr > td:last-child:hover > span { position: absolute; top: auto; left: auto; margin-left: 0.5em; line-height: 1.2; font-size: 5em; border: outset; padding: 0.25em 0.5em; background: white; width: 1.25em; height: auto; text-align: center; }
     #named-character-references-table > table > tbody > tr#entity-CounterClockwiseContourIntegral > td:first-child { font-size: 0.5em; }

     .glyph.control { color: red; }

     @font-face {
       font-family: 'Essays1743';
       src: url('fonts/Essays1743.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-weight: bold;
       src: url('fonts/Essays1743-Bold.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       src: url('fonts/Essays1743-Italic.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       font-weight: bold;
       src: url('fonts/Essays1743-BoldItalic.ttf');
     }

  </style>
  <style type="text/css">
     pre { margin-left: 2em; white-space: pre-wrap; }
       h2 { margin: 3em 0 1em 0; }
       h3 { margin: 2.5em 0 1em 0; }
       h4 { margin: 2.5em 0 0.75em 0; }
       h5, h6 { margin: 2.5em 0 1em; }
       h1 + h2, h1 + h2 + h2, h1 + p, h1 + p + h2 { margin: 0.75em 0 0.75em; }
       h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
       p { margin: 1em 0; }
       hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
       .element dd,  .element dl { margin-top: 0em; margin-bottom: 0.25em;}
       dt { margin-top: 0.75em; margin-bottom: 0.5em; clear: left; }
        .element dt { margin-top: 0.5em; margin-bottom: 0.5em;  }
       dt + dt { margin-top: 0; }
       dd dt { margin-top: 0.25em; margin-bottom: 0; }
       dd p { margin-top: 0; }
       dd dl + p { margin-top: 1em; }
       dd table + p { margin-top: 1em; }
       p + * > li, dd li { margin: 1em 0; }
       dt, dfn { font-weight: bold; font-style: normal; }
       i, em { font-style: italic; }
       dt dfn { font-style: italic; }
       pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
       pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
       pre em { font-weight: bolder; font-style: normal; }
       @media screen { code { color: #D93B00; } code :link, code :visited { color: inherit; } }
       var { background-color: #f9f9f9; border: 1px solid #eee; padding: 0 2px; }
       var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
       table { border-collapse: collapse; border-style: hidden hidden none hidden; }
       table thead, table tbody { border-bottom: solid; }
       table tbody th:first-child { border-left: solid; }
       table tbody th { text-align: left; }
       table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
       blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

       .bad, .bad *:not(.XXX) { color: #5F6D7A; border-color: gray; background: transparent; }
       .matrix, .matrix td { border: none; text-align: right; }
       .matrix { margin-left: 2em; }
       .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
       .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
       .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

       .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
       img.extra, p.overview { float: right; }
       pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
       pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
       pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
       pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
       pre.css:first-line { color: #AAAA50; }
       dl.domintro {padding: 0.5em 1em; border: none; background:#E9FBE9; border: 1px solid lightgray; }
       hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
       dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
       dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
       dl.domintro dd p { margin: 0.5em 0; }
       dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This definition is non-normative. Implementation requirements are given below this definition.'; color: #606060; border:1px solid lightgray; background: white; padding: 0 0.25em;font-size:.9em;}
       dl.switch { padding-left: 2em; }
       dl.switch > dt { text-indent: -1.5em; }
       dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
       dl.triple { padding: 0 0 0 1em; }
       dl.triple dt, dl.triple dd { margin: 0; display: inline }
       dl.triple dt:after { content: ':'; }
       dl.triple dd:after { content: '\A'; white-space: pre; }
       .diff-old { text-decoration: line-through; color: silver; background: transparent; }
       .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
       a .diff-new { border-bottom: 1px blue solid; }

       figure.diagrams { border: double black; background: white; padding: 1em; }
       figure.diagrams img { display: block; margin: 1em auto; } 

       h2 { page-break-before: always; }
       h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
       h1 + h2, hr + h2.no-toc { page-break-before: auto; }

       p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang]),
       li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang])
       { border-bottom: solid #9999CC; }

       div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
       div.head p { margin: 0; }
       div.head h1 { margin: 0; }
       div.head .logo { float: right; margin: 0 1em; }
       div.head .logo img { border: none } /* remove border from top image */
       div.head dl { margin: 1em 0; }
       div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

       body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
       body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
       body > .toc > li > * { margin-bottom: 0.5em; }
       body > .toc > li > * > li > * { margin-bottom: 0.25em; }
       .toc, .toc li { list-style: none; }

       .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
       .brief li { margin: 0; padding: 0; }
       .brief li p { margin: 0; padding: 0; }

       .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
       .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
       .category-list li { display: inline; }
       .category-list li:not(:last-child)::after { content: ', '; }
       .category-list li > span, .category-list li > a { text-transform: lowercase; }
       .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

       .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
       .XXX > :first-child { margin-top: 0; }
       p .XXX { line-height: 3em; }
       .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
       .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
       .annotation :link, .annotation :visited { color: inherit; }
       .annotation :link:hover, .annotation :visited:hover { background: transparent; }
       .annotation span { border: none ! important; }
       .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
       .warning { background-color: #F9F0D4; border: medium double #FF0000; margin: 1em; padding: 1em; }
       .note em, .warning em, .note i, .warning i { font-style: normal; }
       p.note, div.note { padding: 0.5em 2em; }
       span.note { padding: 0 2em; }
       .note p:first-child, .warning p:first-child { margin-top: 0; }
       .note p:last-child, .warning p:last-child { margin-bottom: 0; }
       .warning:before { font-style: normal; }
       p.note:before { content: 'Note: '; font-weight: bolder;}
       p.warning:before { content: '\26A0 Warning! '; font-weight:bolder;}
       .critical {margin:1em; border:double red; padding:1em; background-color:#F9F0D4;}

       .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
       .bookkeeping { font-size: 0.8em; margin: 2em 0; }
       .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
       .bookkeeping dt { margin: 0.5em 2em 0; }
       .bookkeeping dd { margin: 0 3em 0.5em; }

       h4 { position: relative; z-index: 3; }
       h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
       .element {
         background: #F4F4FA;
         color: black;
         margin: 0 0 1em 0.15em;
         padding: 0 1em 0.25em 0.75em;
         border-left: solid #9999FF 0.25em;
         position: relative;
         z-index: 1;
       }
       .element:before {
         position: absolute;
         z-index: 2;
         top: 0;
         left: -1.15em;
         height: 2em;
         width: 0.9em;
         background: #F4F4FA;
         content: ' ';
         border-style: none none solid solid;
         border-color: #9999FF;
         border-width: 0.25em;
       }

       .example { display: block; color: #222222; background: #FCFCFC; border-left-style: solid;border-color:#c0c0c0; border-left-width: 0.25em; margin-left: 1em; padding-left: 1em;padding-bottom: 0.5em;}
       div.example:before { content: 'Code Example: '; font-weight: bolder;}
       td > .example:only-child { margin: 0 0 0 0.1em; }

       ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
       ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
       ul.domTree li li { list-style: none; }
       ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree span { font-style: italic; font-family: serif; }
       ul.domTree .t1 code { color: purple; font-weight: bold; }
       ul.domTree .t2 { font-style: normal; font-family: monospace; }
       ul.domTree .t2 .name { color: black; font-weight: bold; }
       ul.domTree .t2 .value { color: blue; font-weight: normal; }
       ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
       ul.domTree .t7 code, .domTree .t8 code { color: green; }
       ul.domTree .t10 code { color: teal; }

       body.dfnEnabled dfn { cursor: pointer; }
       .dfnPanel {
         display: inline;
         position: absolute;
         z-index: 10;
         height: auto;
         width: auto;
         padding: 0.5em 0.75em;
         font: small sans-serif, Droid Sans Fallback;
         background: #DDDDDD;
         color: black;
         border: outset 0.2em;
       }
       .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
       .dfnPanel :link, .dfnPanel :visited { color: black; }
       .dfnPanel p { font-weight: bolder; }
       .dfnPanel * + p { margin-top: 0.25em; }
       .dfnPanel li { list-style-position: inside; }

       #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
       #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
       #configUI p label { display: block; }
       #configUI #updateUI, #configUI .loginUI { text-align: center; }
       #configUI input[type=button] { display: block; margin: auto; }

       fieldset { margin: 1em; padding: 0.5em 1em; }
       fieldset > legend + * { margin-top: 0; }
       fieldset > :last-child { margin-bottom: 0; }
       fieldset p { margin: 0.5em 0; }
       header p.subline {color:#005A9C; font: 140% sans-serif;margin: 0.75em 0;}
       #authorButton {overflow: visible; padding: 0.1em 0.3em; position: fixed; right: 2em; top: 6em; width: auto;}

       @media print {#authorButton { display:none;}}

   .stability {
     position: fixed;
     bottom: 0;
     left: 0; right: 0;
     margin: 0 auto 0 auto;
     width: 50%;
     background: maroon; color: yellow;
     -webkit-border-radius: 1em 1em 0 0;
     -moz-border-radius: 1em 1em 0 0;
     border-radius: 1em 1em 0 0;
     -moz-box-shadow: 0 0 1em #500;
     -webkit-box-shadow: 0 0 1em #500;
     box-shadow: 0 0 1em red;
     padding: 0.5em 1em;
     text-align: center;
   }
   .stability strong {
     display: block;
   }
   .stability input {
     -moz-appearance: none; -webkit-appearance: none; margin: 0; 
     border: 0; padding: 0.25em 0.5em; background: transparent; color: black;
     position: absolute; top: -0.5em; right: 0; font: 1.25em sans-serif; text-align: center;
   }
   .stability input:hover {
     color: white;
     text-shadow: 0 0 2px black;
   }
   .stability input:active {
     padding: 0.3em 0.45em 0.2em 0.55em;
   }
   .stability :link, .stability :visited,
   .stability :link:hover, .stability :visited:hover {
     background: transparent;
     color: white;
   }

  </style><!-- style switcher script by Stommepoes  -->
  <link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css">
  <link href="switcher/author-view.css" id="author-view" rel="alternate stylesheet" title="Author documentation only">
  <script src="switcher/authorstylesheet.js"></script>
  <link href="introduction.html" rel="prev" title="1 Introduction">
  <link href="Overview.html#contents" rel="contents" title="目次">
  <link href="dom.html" rel="next" title="3 Semantics, structure, and APIs of HTML documents">
</head>

<body class="split chapter" onload="fixBrokenLink();">
  <div class="head" id="head">
    <header>
      <span id="styleSwitch"></span>

      <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

      <h1 id="big-title">HTML5</h1>

      <p class="no-num no-toc subline">HTML과 XHTML을 위한 어휘와 관련 API</p>

      <h2 class="no-num no-toc" id="w3c-recommendation-28-october-2014">W3C Recommendation 28 October 2014</h2>
    </header>
  </div>

  <nav class="prev_next">
    <a href="introduction.html">← 1 들어가기</a> – <a href="Overview.html#contents">목차</a> – <a href="dom.html">3 시맨틱, 구조, HTML 문서의 API →</a>

    <ol class="toc">
      <li>
        <a href="infrastructure.html#infrastructure"><span class="secno">2</span> 공통 인프라</a>

        <ol>
          <li>
            <a href="infrastructure.html#terminology"><span class="secno">2.1</span> 용어</a>

            <ol>
              <li>
                <a href="infrastructure.html#resources"><span class="secno">2.1.1</span> 리소스</a>
              </li>

              <li>
                <a href="infrastructure.html#xml"><span class="secno">2.1.2</span> XML</a>
              </li>

              <li>
                <a href="infrastructure.html#dom-trees"><span class="secno">2.1.3</span> DOM 트리</a>
              </li>

              <li>
                <a href="infrastructure.html#scripting-0"><span class="secno">2.1.4</span> 스크립팅</a>
              </li>

              <li>
                <a href="infrastructure.html#plugins"><span class="secno">2.1.5</span> 플러그인</a>
              </li>

              <li>
                <a href="infrastructure.html#encoding-terminology"><span class="secno">2.1.6</span> 문자 인코딩</a>
              </li>
            </ol>
          </li>

          <li>
            <a href="infrastructure.html#conformance-requirements"><span class="secno">2.2</span> 적합성 조건</a>

            <ol>
              <li>
                <a href="infrastructure.html#conformance-classes"><span class="secno">2.2.1</span> Conformance classes</a>
              </li>

              <li>
                <a href="infrastructure.html#dependencies"><span class="secno">2.2.2</span> Dependencies</a>
              </li>

              <li>
                <a href="infrastructure.html#extensibility-0"><span class="secno">2.2.3</span> 확장성</a>
              </li>

              <li>
                <a href="infrastructure.html#interactions-with-xpath-and-xslt"><span class="secno">2.2.4</span> Interactions with XPath and XSLT</a>
              </li>
            </ol>
          </li>

          <li>
            <a href="infrastructure.html#case-sensitivity-and-string-comparison"><span class="secno">2.3</span> 대소문자 구분 및 문자열 비교</a>
          </li>

          <li>
            <a href="infrastructure.html#common-microsyntaxes"><span class="secno">2.4</span> 공통 마이크로 구문</a>

            <ol>
              <li>
                <a href="infrastructure.html#common-parser-idioms"><span class="secno">2.4.1</span> Common parser idioms</a>
              </li>

              <li>
                <a href="infrastructure.html#boolean-attributes"><span class="secno">2.4.2</span> boolean 속성</a>
              </li>

              <li>
                <a href="infrastructure.html#keywords-and-enumerated-attributes"><span class="secno">2.4.3</span> 키워드 및 열거 속성</a>
              </li>

              <li>
                <a href="infrastructure.html#numbers"><span class="secno">2.4.4</span> 숫자</a>

                <ol>
                  <li>
                    <a href="infrastructure.html#signed-integers"><span class="secno">2.4.4.1</span> 부호 있는 정수</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#non-negative-integers"><span class="secno">2.4.4.2</span> 양의 정수</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#floating-point-numbers"><span class="secno">2.4.4.3</span> 부동소수점</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#percentages-and-dimensions"><span class="secno">2.4.4.4</span> Percentages and lengths</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#lists-of-integers"><span class="secno">2.4.4.5</span> 정수 목록</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#lists-of-dimensions"><span class="secno">2.4.4.6</span> Lists of dimensions</a>
                  </li>
                </ol>
              </li>

              <li>
                <a href="infrastructure.html#dates-and-times"><span class="secno">2.4.5</span> 날짜 및 시간</a>

                <ol>
                  <li>
                    <a href="infrastructure.html#months"><span class="secno">2.4.5.1</span> 월</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#dates"><span class="secno">2.4.5.2</span> 날짜</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#yearless-dates"><span class="secno">2.4.5.3</span> 연 없는 날짜</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#times"><span class="secno">2.4.5.4</span> 시간</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#floating-dates-and-times"><span class="secno">2.4.5.5</span> 부동 날짜 및 시간</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#time-zones"><span class="secno">2.4.5.6</span> 타임존</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#global-dates-and-times"><span class="secno">2.4.5.7</span> 글로벌 날짜 및 시간</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#weeks"><span class="secno">2.4.5.8</span> 주</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#durations"><span class="secno">2.4.5.9</span> 지속시간</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#vaguer-moments-in-time"><span class="secno">2.4.5.10</span> 시간의 애매한 순간</a>
                  </li>
                </ol>
              </li>

              <li>
                <a href="infrastructure.html#colors"><span class="secno">2.4.6</span> 색</a>
              </li>

              <li>
                <a href="infrastructure.html#space-separated-tokens"><span class="secno">2.4.7</span> 공백 분리 토큰</a>
              </li>

              <li>
                <a href="infrastructure.html#comma-separated-tokens"><span class="secno">2.4.8</span> 쉼표 분리 토큰</a>
              </li>

              <li>
                <a href="infrastructure.html#syntax-references"><span class="secno">2.4.9</span> 참조</a>
              </li>

              <li>
                <a href="infrastructure.html#mq"><span class="secno">2.4.10</span> 미디어쿼리</a>
              </li>
            </ol>
          </li>

          <li>
            <a href="infrastructure.html#urls"><span class="secno">2.5</span> URL</a>

            <ol>
              <li>
                <a href="infrastructure.html#terminology-0"><span class="secno">2.5.1</span> 용어</a>
              </li>

              <li>
                <a href="infrastructure.html#resolving-urls"><span class="secno">2.5.2</span> Resolving URLs</a>
              </li>

              <li>
                <a href="infrastructure.html#dynamic-changes-to-base-urls"><span class="secno">2.5.3</span> Dynamic changes to base URLs</a>
              </li>
            </ol>
          </li>

          <li>
            <a href="infrastructure.html#fetching-resources"><span class="secno">2.6</span> Fetching resources</a>

            <ol>
              <li>
                <a href="infrastructure.html#terminology-1"><span class="secno">2.6.1</span> Terminology</a>
              </li>

              <li>
                <a href="infrastructure.html#processing-model"><span class="secno">2.6.2</span> Processing model</a>
              </li>

              <li>
                <a href="infrastructure.html#encrypted-http-and-related-security-concerns"><span class="secno">2.6.3</span> Encrypted HTTP and related security concerns</a>
              </li>

              <li>
                <a href="infrastructure.html#content-type-sniffing"><span class="secno">2.6.4</span> Determining the type of a resource</a>
              </li>

              <li>
                <a href="infrastructure.html#extracting-character-encodings-from-meta-elements"><span class="secno">2.6.5</span> Extracting character encodings from <code>meta</code> elements</a>
              </li>

              <li>
                <a href="infrastructure.html#cors-settings-attributes"><span class="secno">2.6.6</span> CORS 설정 속성</a>
              </li>

              <li>
                <a href="infrastructure.html#cors-enabled-fetch"><span class="secno">2.6.7</span> CORS-enabled fetch</a>
              </li>
            </ol>
          </li>

          <li>
            <a href="infrastructure.html#common-dom-interfaces"><span class="secno">2.7</span> 공통 DOM 인터페이스</a>

            <ol>
              <li>
                <a href="infrastructure.html#reflecting-content-attributes-in-idl-attributes"><span class="secno">2.7.1</span> IDL 속성에 따른 콘텐츠 속성 반영</a>
              </li>

              <li>
                <a href="infrastructure.html#collections"><span class="secno">2.7.2</span> 콜렉션</a>

                <ol>
                  <li>
                    <a href="infrastructure.html#htmlallcollection"><span class="secno">2.7.2.1</span> HTMLAllCollection</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#htmlformcontrolscollection"><span class="secno">2.7.2.2</span> HTMLFormControlsCollection</a>
                  </li>

                  <li>
                    <a href="infrastructure.html#htmloptionscollection"><span class="secno">2.7.2.3</span> HTMLOptionsCollection</a>
                  </li>
                </ol>
              </li>

              <li>
                <a href="infrastructure.html#domstringmap"><span class="secno">2.7.3</span> DOMStringMap</a>
              </li>

              <li>
                <a href="infrastructure.html#transferable-objects"><span class="secno">2.7.4</span> 양도 가능한 객체</a>
              </li>

              <li>
                <a href="infrastructure.html#safe-passing-of-structured-data"><span class="secno">2.7.5</span> Safe passing of structured data</a>
              </li>

              <li>
                <a href="infrastructure.html#callbacks"><span class="secno">2.7.6</span> 콜백</a>
              </li>

              <li>
                <a href="infrastructure.html#garbage-collection"><span class="secno">2.7.7</span> Garbage collection</a>
              </li>
            </ol>
          </li>

          <li>
            <a href="infrastructure.html#namespaces"><span class="secno">2.8</span> 네임스페이스</a>
          </li>
        </ol>
      </li>
    </ol>
  </nav>

  <h2 id="infrastructure"><span class="secno">2</span> 공통 인프라</h2>

  <h3 id="terminology"><span class="secno">2.1</span> 용어</h3>

  <p>이 스펙 문서는 종종 같은 콘텍스트에 놓여있는 HTML, XML의 속성과 IDL 속성을 언급합니다. 어떤 속성에 대한 언급인지 불명확한 경우, HTML 및 XML 속성의 <dfn data-anolis-xref="">콘텐츠 속성</dfn> 및 IDL 인터페이스에서 정의하는 <dfn data-anolis-xref="">IDL 속성</dfn>으로써 언급됩니다. 마찬가지로 용어 "프로퍼티"는 JavaScript의 객체 프로퍼티 및 CSS 프로퍼티에 모두 사용됩니다. 프로퍼티가 불분명한 경우, 각각 <dfn data-anolis-xref="">객체 프로퍼티</dfn> 및 <dfn data-anolis-xref="">CSS 프로퍼티</dfn>로 자격을 가집니다.</p>

  <p>일반적으로 어떤 기능이 <a href="syntax.html#syntax">HTML 구문</a> 혹은 <a href="the-xhtml-syntax.html#the-xhtml-syntax">XHTML 구문</a> 중 하나에서 언급하는 경우, 다른 쪽도 포함합니다. 기능이 둘 중 하나에만 명확히 해당하는 경우"HTML에서만…（이는 XHTML에는 적용되지 않습니다）" 같이 다른 형식에 적용되지 않음을 명확히 표시합니다.</p>

  <p>이 스펙은 짧은 정적 문서에서 리치 멀티미디어를 아우르는 에세이나 보고서뿐만 아니라, 본격적인 대화형 어플리케이션에 이르는, HTML의 모든 용법을 나타내는 <dfn data-anolis-xref="">문서</dfn>를 이용합니다. 이 문서는, 문맥에 따라서 <code><a href="dom.html#document">Document</a></code> 객체 및 자손 DOM 트리, <a data-anolis-xref="the HTML syntax" href="syntax.html#syntax">HTML구문</a> 또는 <a data-anolis-xref="the XHTML syntax" href="the-xhtml-syntax.html#the-xhtml-syntax">XHTML구문</a>을 사용하여 직렬화된 바이트 스트림을 나타내는 데 사용합니다.</p>

  <p>DOM 구조 문맥에서 용어 <a data-anolis-xref="HTML documents" href="#html-documents">HTML 문서</a> 및 <a data-anolis-xref="XML documents" href="#xml-documents">XML 문서</a>는 DOM 스펙 문서에서 정의한대로 사용하여 <code><a href="dom.html#document">Document</a></code> 객체가 자신을 찾을 수 있는 2가지 다른 모드를 나타냅니다.<a href="references.html#refsDOM">[DOM]</a>（이러한 용도인 경우 항상 정의 하이퍼링크가 걸립니다）</p>

  <p>바이트 스트림 문맥에서 용어 HTML 문서는 <code><a href="iana.html#text/html">text/html</a></code>로 분류되어있는 리소스를 나타내며, 용어 XML 문서는 <a href="#xml-mime-type">XML MIME 타입</a>으로 분류된 리소스를 나타냅니다.</p>

  <p>용어 <dfn id="xhtml-document">XHTML 문서</dfn>는 문맥에 따라서 <a href="#html-namespace-0">HTML 네임스페이스</a> 안의 요소 노드를 포함하는 <a data-anolis-xref="XML documents" href="#xml-documents">XML 문서</a>모드에서 <code><a href="dom.html#document">Document</a></code> 및 <a href="#html-namespace-0">HTML 네임스페이스</a>에서 유래한 요소를 포함한<a href="#xml-mime-type">XML MIME 타입</a>으로 분류된 바이트스트림을 모두 표시하기 위해 사용합니다.</p>
  <hr>

  <p>간결함을 위해 문서를 유저에게 표시되는 방법을 참조할 때 （원문에서 말하는）<dfn data-anolis-xref="">shown</dfn>、<dfn data-anolis-xref="">displayed</dfn>、<dfn data-anolis-xref="">visible</dfn> 같은 용어가 사용될 지도 모릅니다. 이 용어는 시각 매체를 의미하지 않으며, 동일한 방법으로 다른 미디어에 적용한다고 생각해야 합니다.</p>

  <p>용어 "transparent black"은 red, green, blue 및 알파 채널을 모두 0으로 처리한 색상을 가리킵니다.</p>

  <h4 id="resources"><span class="secno">2.1.1</span> 리소스</h4>

  <p>스펙 문서는 유저 에이전트가 외부 리소스 시맨틱을 디코드 가능한 구현을 가가지고 있는지에 대해 참조하는 경우 용어 <dfn data-anolis-xref="">지원함</dfn>을 사용합니다. 포맷 또는 타입은 중요한 리소스 기능을 무시하는 일 없이 구현이 그 포맷이나 타입의 리소스를 처리 가능한 경우 <i>지원함</i>이라 기술합니다. 특정 리소스가 <i>지원함</i>인지 아닌지는 리소스 포맷의 어느 기능이 사용하고 있는지에 의존합니다.</p>

  <p class="example">예를 들어 비록 구현되어있는 지 모르더라도 이미지가 애니메이션 데이터를 포함하더라도 픽셀 데이터를 디코딩하여 렌더링된다면, PNG 이미지는 지원 포맷으로 간주될 것입니다.</p>

  <p class="example">비록 구현이 파일의 메타데이터에서 동영상의 크기를 결정 가능해도, 사용하는 합축형식이 지원하지 않을 경우, MPEG-4 비디오 파일을 지원하는 형식으로 간주하지 않습니다.</p>

  <p>특히 HTML 스펙에서 일부 스펙이 <i>representation</i>이라 표현하는 걸 이 스펙에서는 <dfn data-anolis-xref="">리소스</dfn>로 표현합니다.<a href="references.html#refsHTTP">[HTTP]</a></p>

  <p>용어 <dfn id="mime-type">MIME 타입</dfn>은 프로토콜 문헌에서 가끔 <i>인터넷 미디어 타입</i>이라는 걸 가리키는 데 사용합니다. 이 스펙에서 용어 <i>미디어 타입</i>은 CSS 스펙에서 사용하는 바와 같이, 프레젠테이션을 위해 예정되는 미디어 종류를 표시하기 위해 사용합니다. <a href="references.html#refsRFC2046">[RFC2046]</a> <a href="references.html#refsMQ">[MQ]</a></p>

  <p>미디어 타입이 RFC 7231의 3.1.1.1절 "Media Types"에서 정의하는 <code data-anolis-xref="">media-type</code> 규칙에 일치하는 경우 문자열은 <dfn id="valid-mime-type">유효한 MIME 타입</dfn>이 됩니다. 구체적으로 <a href="#valid-mime-type">유효한 MIME 타입</a>은 MIME타입의 파라미터를 표현할 수 있습니다. <a href="references.html#refsHTTP">[HTTP]</a></p>

  <p>";"（U+003B）문자를 포함하지 않지만 RFC 7231의 3.1.1.1절 "Media Types"에서 정의하는 <code data-anolis-xref="">media-type</code>규칙과 일치하는 경우 문자열은 <dfn id="valid-mime-type-with-no-parameters">파라미터 없이 유효한 MIME 타입</dfn>이 됩니다. 즉 MIME 타입의 파라미터가 없는 타입 및 서브 타입으로만 구성된 경우입니다.<a href="references.html#refsHTTP">[HTTP]</a></p>

  <p>용어 <dfn id="html-mime-type">HTML MIME 타입</dfn>은 <a href="#mime-type">MIME 타입</a>이<code><a href="iana.html#text/html">text/html</a></code>을 나타내기 위해 사용됩니다.</p>

  <p>리소스의 <dfn id="critical-subresources">크리티컬 서브 리소스</dfn>는 리소스가 제대로 처리되는 데 사용할 수 있는 상태로 유지해야할 필요가 있습니다. 어떤 리소스가 크리티컬한지 간주하는 데에 리소스의 포맷을 정의하는 스펙에서 정의하지 않습니다.</p>

  <p>용어 <dfn data-anolis-xref="data protocol" id="data-protocol"><code data-anolis-xref="">data:</code> URL</dfn>은 <code data-anolis-xref="">data:</code>스킴을 이용해 <span data-anolis-xref="URL">URL</span>을 가리킵니다.<a href="references.html#refsRFC2397">[RFC2397]</a></p>

  <h4 id="xml"><span class="secno">2.1.2</span> XML</h4>

  <p id="html-namespace">HTML에서 XHTML로 마이그레이션을 용이하게 하기 위해, 이 스펙ㅇ을 준수하는 유저 에이전트는 적어도 DOM과 CSS를 위해 <code>http://www.w3.org/1999/xhtml</code> 네임스페이스에 HTML 요소를 기술할 것입니다. 이 스펙에서 사용하는 용어 "<dfn id="html-elements">HTML 요소</dfn>"는 그 네임스페이스 내 임의의 요소를 가리킵니다. 따라서 HTML과 XHTML 요소 모두를 가리킵니다.</p>

  <p>달리 작성하는 경우를 제외하고 이 스펙에서 정의하거나 작성한 모든 요소는 <a href="#html-namespace-0">HTML 네임스페이스</a>（"<code>http://www.w3.org/1999/xhtml</code>"）이며, 이 스펙에서 정의하거나 작성한 모든 속성은 네임스페이스를 지 않습니다.</p>

  <p>용어 <dfn id="element-type">요소 타입</dfn>은 주어진 로컬명과 네임스페이스를 가진 요소의 집할을 참조하기 위해 사용됩니다. 예를 들어 <code><a href="forms.html#the-button-element">button</a></code>요소는 요소 타입 <code><a href="forms.html#the-button-element">button</a></code>을 가진 요소이며, 로컬 명 "<code data-anolis-xref="">button</code><a href="#html-namespace-0"></a>" 및 （암묵적으로 위에서 정의하도록）HTML 네임스페스를 가지는 것을 의미합니다.</p>

  <p>속성명이 XML로 정의된 <a href="http://www.w3.org/TR/xml/#NT-Name"><code data-anolis-xref="">Name</code></a> 생성물과 일치하며여 ":"（U+003A）문자를 포함하지 않고 첫 세 문자의 문자열이 <a href="#ascii-case-insensitive">ASCII 대소문자 구분하지 않음</a>인 문자열 "<code data-anolis-xref="">xml</code>"에 일치하지 않는 경우 속성명은 <dfn id="xml-compatible">XML 호환</dfn>이라 말합니다.<a href="references.html#refsXML">[XML]</a></p>

  <p>용어 <dfn id="xml-mime-type">XML MIME 타입</dfn>은 <a data-anolis-xref="MIME type" href="#mime-type">MIME 타입</a><code data-anolis-xref="">text/xml</code>、<code data-anolis-xref="">application/xml</code>、subtype이 4글자 "<code data-anolis-xref="">+xml</code>"로 끝나는 임의의 <a href="#mime-type">MIME 타입</a>을 참조하기 위해 사용됩니다. <a href="references.html#refsRFC7303">[RFC7303]</a></p>

  <h4 id="dom-trees"><span class="secno">2.1.3</span> DOM 트리</h4>

  <p><dfn id="root-element-of-a-document-object"><code>Document</code> 객체의 루트 요소</dfn>는 만약 있다면 그 <code><a href="dom.html#document">Document</a></code>의 첫번째 자식이 되고, 만약 없다면 <code><a href="dom.html#document">Document</a></code>가 루트 요소를 가지지 않습니다.</p>

  <p><code><a href="dom.html#document">Document</a></code> 객체의 루토 요소를 나타내지 않는 경우, 용어 <dfn id="root-element">루트 요소</dfn>는 논의 대상 노드에서 가장 먼 조상 노드, 혹은 조상이 없는 노드 자신을 의미합니다. 노드가 문서의 일부인 경우, 노드의 <a href="#root-element">루트 요소</a>는 문서의 루트 요소 그 자체입니다. 그러나 일반적으로 노드가 문서 트리의 일부가 아니라면 루트 요소는 독립 노드일 것입니다.</p>

  <p>요소의 <a href="#root-element">루트 요소</a>가 <a href="#root-element-of-a-document-object"><code>Document</code> 객체의 루토 요소</a>인 경우 노드는 <dfn id="in-a-document"><code>Document</code> 내</dfn>에 있다고 말할 수 있습니다. 노드의 <a href="#root-element">루트 요소</a>가 변화하여 현재 문서의 <a href="#root-element">루트 요소</a>인 경우 노드는 <dfn data-anolis-xref="insert an element into a document" id="insert-an-element-into-a-document">문서 내 삽입</dfn>이라고 불립니다. 마찬가지로 문서의 <a href="#root-element">루트 요소</a>에서 별도의 요소에 <a href="#root-element">루트 요소</a>가 변하는 경우 노드는 <dfn data-anolis-xref="remove an element from a document" id="remove-an-element-from-a-document">문서에서 제거된 요소</dfn>라 부릅니다</p>

  <p>노드의 <dfn id="home-subtree">홈 서브 트리</dfn>는 그 노드의 <a href="#root-element">루트 요소</a>를 루트로 삼는 서브 트리입니다. 노드가 <a href="#in-a-document"><code>Document</code> 안에</a> 존재하는 경우, 노드의 <a href="#home-subtree">홈 서브 트리</a>는 노드의 <code><a href="dom.html#document">Document</a></code> 트리 입니다.</p>

  <p>（요소 같은）특정 <code><a href="#node">Node</a></code>의 <code><a href="dom.html#document">Document</a></code>는 <code><a href="#node">Node</a></code>의 <code data-anolis-xref="dom-Node-ownerDocument"><a href="#dom-node-ownerdocument">ownerDocument</a></code> IDL 속성이 반환하는 <code><a href="dom.html#document">Document</a></code>입니다. 특정 <code><a href="#node">Node</a></code>가 <a href="#in-a-document"><code>Document</code> 내에</a> 있는 경우 그 <code><a href="dom.html#document">Document</a></code>는 항상 <code><a href="#node">Node</a></code>의<code><a href="dom.html#document">Document</a></code>이며 따라서 <code><a href="#node">Node</a></code>의 <code data-anolis-xref="dom-Node-ownerDocument"><a href="#dom-node-ownerdocument">ownerDocument</a></code>IDL 속성은 항상 그 <code><a href="dom.html#document">Document</a></code> 반환합니다.</p>

  <p>콘텐츠 속성의 <code><a href="dom.html#document">Document</a></code>는 속성 요소의 <code><a href="dom.html#document">Document</a></code>입니다.</p>

  <p>용어 <dfn id="tree-order">트리 순서</dfn>는 선행관계를 의미하며 （<code data-anolis-xref="dom-Node-parentNode"><a href="#dom-node-parentnode">parentNode</a></code>/<code data-anolis-xref="dom-Node-childNodes"><a href="#dom-node-childnodes">childNodes</a></code> 관계를 통해）DOM 노드의 수직 조사에 관계합니다.</p>

  <p>노드가 일부 요소 혹은 속성을 <dfn data-anolis-xref="ignore" id="ignore">무시</dfn>한다고 말하거나 다른 값처럼 취급되거나 다른 것인 마냥 다루어지는 경우, 이는 DOM이 된 후 노드 처리만을 가리킵니다. <span class="impl">유저 에이전트는 이런 상황에서 DOM을 변화시켜서는 안됩니다.</span></p>

  <p>새로운 값이 이전 값과 다른 경우에만, 콘텐츠 속성은 값을 <dfn data-anolis-xref="">변경한다</dfn>라 부릅니다. 이미 존재하는 속성값을 설정하는 건 변경이 아닙니다.</p>

  <p>용어 <dfn data-anolis-xref="">공백</dfn>은 속성값, <code><a href="#text-0">Text</a></code>노드, 혹은 문자열에서 사용되는 경우 텍스트의 길이가 0인 것을 의미합니다. (즉 스페이스나 <a href="#control-characters">제어문자</a>조차 포함하지 않습니다）</p>

  <h4 id="scripting-0"><span class="secno">2.1.4</span> 스크립팅</h4>

  <p>구조체 "<code>Foo</code> 객체"는 <code>Foo</code>가 실제 인터페이스인 경우에 보다 정확한 "<code>Foo</code> 인터페이스를 구현하는 객체" 대신 사용합니다</p>

  <p>IDL 속성은 그 값이 （에디터의 스크립트 등에 의해）취득 되는 경우 <dfn data-anolis-xref="">취득 당함</dfn>이라 부르며 새로운 값을 할당할 때 <dfn data-anolis-xref="">설정됨</dfn>이라 부릅니다.</p>

  <p>DOM 객체가 <dfn id="live">live</dfn>라 불리는 경우 그 객체의 속성과 메소드는 데이터 스스냅샷이 아닌 실제에 바탕을 두는 데이터를 조작합니다.</p>

  <p>이벤트의 콘텍스트에 있어 용어 <i>발화</i>나 <i>송출</i>은 DOM 스펙에서 정의되는 그대로 사용합니다. 이벤트의 <dfn data-anolis-xref="concept-event-fire" id="concept-event-fire">발화</dfn>는 이벤트를 작성할 때 <a data-anolis-xref="concept-event-dispatch" href="#concept-event-dispatch">송출하는</a> 것을 의미하며, 이벤트의 <dfn data-anolis-xref="concept-event-dispatch" id="concept-event-dispatch">송출</dfn>은 트리를 통해 이벤트를 전파하는 단계를 수행하는 걸 의미합니다. 용어 <dfn data-anolis-xref="concept-events-trusted" id="concept-events-trusted">신뢰할 수 있는 이벤트</dfn>는 <code data-anolis-xref="dom-event-isTrusted"><a href="#dom-event-istrusted">isTrusted</a></code>속성이 true로 초기화된 이벤트를 참조하기 위해 사용합니다.<a href="references.html#refsDOM">[DOM]</a></p>

  <h4 id="plugins"><span class="secno">2.1.5</span> 플러그인</h4>

  <p>용어 <dfn id="plugin">플러그인</dfn>은 <code><a href="dom.html#document">Document</a></code> 객체가 속한 유저에이전트의 렌더링에 관여 가능한 유저 에이전트의 의해 사용되는 콘텐츠 핸들러에 의해 정의된 유저 에이전트를 참조하지만 <code><a href="dom.html#document">Document</a></code>의 <a data-anolis-xref="child browsing context" href="browsers.html#child-browsing-context">자식 브라우징 콘텍스트</a>로써 행동할 임의의 <code><a href="#node">Node</a></code> 객체를 <code><a href="dom.html#document">Document</a></code> DOM에 넣을 수 없습니다.</p>

  <p>보통 그런 컨텐츠 핸들러는 제3자에 의해 제공됩니다. 무엇보다 유저 에이전트 또한 플러그인으로 빌트 인 콘텐츠 핸들러를 정의 가능합니다.</p>

  <p class="example">플러그인 예시로는 유저가 PDF 파일을 조작할 때 사용하는 <a href="browsers.html#browsing-context">브라우징 콘텍스트</a>로 인스턴스를 생성한 PDF 뷰어일 것입니다. 이는 구현된 PDF 뷰어 컴포넌트가 유저 에이전트 자신에 구현된 것과 동일한 메이커인지는 관계 없이 플러그인으로써 카운트 됩니다. 그러나 유저 에이전트(같은 인터페이스를 사용하는 건 아닙니다)와는 별개로 동작하는 PDF 뷰어 어플리케이션은 이 정의에 의한 플러그인은 아닙니다.</p>

  <p class="note">이 명세에서는 플러그인과 상호작용하는 메커니즘에 대해서는 정의하지 않습니다. 그것은 사용자 에이전트의 몫이며 운영체제에 따라 다르기 때문입니다. 일부 사용자 에이전트는 넷스케이프의 플러그인 API와 같은 것을 선택할 수 있으며, 다른 일부는 내용 형식을 변화시키는 방법을 빌릴 수도 있고 또는 몇가지 타입에 대해 내장된 지원을 선택할 수도 있습니다. <a href="references.html#refsNPAPI">[NPAPI]</a></p>

  <p><code data-anolis-xref="attr-iframe-sandbox"><a href="embedded-content-0.html#attr-iframe-sandbox">sandbox</a></code> 속성 시멘틱을 부여받은 경우 플러그인은 <dfn data-anolis-xref="concept-plugin-secure" id="concept-plugin-secure">보호 될</dfn> 것입니다.</p>

  <p class="example">예를 들어 보호되는 플러그인은 플러그인이 샌드박스화 되는 <code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code>내부에서 인스턴스화 될 때 콘텐츠가 팝업창을 생성하는 걸 방지할 것입니다.</p>

  <h4 id="encoding-terminology"><span class="secno">2.1.6</span> 문자 인코딩</h4>

  <p><dfn data-anolis-xref="encoding" id="encoding">문자 인코딩</dfn>또는 애매하지 않은 곳에서 간단히 <i><a href="#encoding">인코딩</a></i>은 인코딩 표준에서 정의하는 바와 같이 바이트 스트림과 Unicode 문자열 사이의 변환 방법을 정의합니다. <a href="#encoding">인코딩</a>은 인코딩 스펙에서 인코딩의 <i>이름</i> 및 <i>라벨</i>로 참조되어 <dfn id="encoding-name">인코딩 네임</dfn> 및 1개 이상의 <dfn data-anolis-xref="encoding label" id="encoding-label">인코딩 라벨</dfn>을 가집니다.<a href="references.html#refsENCODING">[ENCODING]</a></p>

  <p><dfn id="ascii-compatible-character-encoding">ASCII 호환 문자 인코딩</dfn>이란 바이트 0x09、0x0A、0x0C、0x0D、0x20-0x22、0x26、0x27、0x2C-0x3F、0x41-0x5A 및 0x61-0x7A이 단일 바이트 혹은 가변성 <a href="#encoding">인코딩</a>이며 멀티 바이트 배열의 2번째 것 이후의 바이트를 무시한 Windows-1252에 있어서 이런 바이트들 전체가 Unicode 문자에 변환하는 간단한 바이트 시퀀스를 대응합니다.<a href="references.html#refsENCODING">[ENCODING]</a></p>

  <p class="note">비록 인코딩에서 0x70 같은 바이트에 있어서 ASCII로써의 해석과는 관계 없는, 더 나은 시퀀스의 일부일 가능성이 있다고 하더라도, 여기에는 Shift_JIS、HZ-GB-2312 ISO-2022 같은 변종 인코딩을 포함합니다. 그러나 UTF-7、GSM03.38, EBCDIC 같은 구식 인코딩 방식은 제외합니다.</p><!--
   We'll have to change that if anyone comes up with a way to have a document that is valid as two
   different encodings at once, with different <meta charset> elements applying in each case.
  -->

  <p>용어 <dfn id="a-utf-16-encoding">UTF-16 인코딩</dfn>은 UTF-16의 임의 변종, BOM 유무에 상관 없이 UTF-16LE 혹은 UTF-16BE를 가리킵니다.<a href="references.html#refsENCODING">[ENCODING]</a></p>

  <p>용어 <dfn id="code-unit">코드 유닛</dfn>은 Web IDL 스펙에서 정의된 바와 같이 16 비트 부호없는 정수, <code>DOMString</code>의 최소 기본 컴포넌트로써 사용됩니다. （이는 Unicode에서 사용되는 것보다 더 좁은 정의이며 <i>코드 포인트</i>와 동일하지 않습니다.）<a href="references.html#refsWEBIDL">[WEBIDL]</a></p>

  <p>용어 <dfn id="unicode-code-point">Unicode 코드 포인트</dfn>는 가능하다면 <i data-anolis-xref="">Unicode 스칼라 값</i>을, 그렇지 않다면 독립 서로게이트 코드 포인트를 의미합니다. 적합 요건이 문자 혹은 Unicode 코드 포인트로 정의되어 있는 경우 하위 서로게이트에서 계속하며 상위 서로게이트에 갖춰진<a data-anolis-xref="code unit" href="#code-unit">코드 단위</a>의 한 쌍은 한 쌍의 서로게이트에서 표시되어 단일 코드 포인트로써 처리되어야 하지만, 독립한 서로게이트는 서로게이트의 값을 가진 단일 코드 포인트로써 각각 취급되어야 합니다.<a href="references.html#refsUNICODE">[UNICODE]</a></p>

  <p>이 스펙에 있어서 용어 <dfn id="character">문자</dfn>는 <em>Unicode</em> 문자의 자격이 되지 않는 경우 용어 <a href="#unicode-code-point">Unicode코드 포인트</a>와 같은 의미입니다.</p>

  <p>용어 <dfn id="unicode-character">Unicode 문자</dfn>는 <i data-anolis-xref="">Unicode 스칼라 값</i>（즉 서로게이트 코드포인트가 아닌 임의의 Unicode 코드 포인트）를 의미하는 데 사용합니다.<a href="references.html#refsUNICODE">[UNICODE]</a></p>

  <p>문자열의 <dfn id="code-unit-length">코드 유닛 길이</dfn>는 그 문자열의 <a data-anolis-xref="code unit" href="#code-unit">코드 유닛</a> 갯수입니다.</p>

  <p class="note">이러한 복잡성은, <a data-anolis-xref="Unicode character" href="#unicode-character">Unicode 문자</a> 관점보다 16비트（UTF-16）<a data-anolis-xref="code unit" href="#code-unit">코드 유닛</a> 관점에서 DOM API를 정의하기 위한 역사적인 결정에 유래합니다.</p><!--FIXUP microdata +1--><!--FIXUP 2dcontext +1-->

  <h3 id="conformance-requirements"><span class="secno">2.2</span> 적합성 조건</h3><!--FIXUP 2dcontext -1--><!--FIXUP microdata -1-->

  <p>이 스펙 문서에 있어서, 모든 그림, 예시, 주의는 표준에 준하는 내용이 아니며, 표준에 준하지 않는다는 내용을 명시하고 있습니다. 그 외의 모든 것은 표준에 준합니다.</p>

  <p>이 문서의 스펙 섹션에 있어서 키워드 "MUST"、"MUST NOT"、"REQUIRED"、"SHOULD"、"SHOULD NOT"、"MAY"、"OPTIONAL"은 RFC 2119에서 표현하는 바 그대로 해석하면 됩니다. 이 문서의 스펙 섹션에서 키워드 "OPTIONALLY"은 "MAY" 혹은 "OPTIONAL"로써 같은 의미로 해석됩니다. 가독성을 높이기 위해 이런 단어들은 대문자로만 표기합니다.<a href="references.html#refsRFC2119">[RFC2119]</a></p>

  <h4 id="extensibility-0"><span class="secno">2.2.3</span> 확장성</h4><!--FIXUP dev-html +1-->

  <p>유저 에이전트가 이 스펙을 확장하여 벤더 고유의 속성을 추가하는 걸 매우 권장하지 않습니다. 이는 특정 유저 에이전트의 유저만 해당 콘텐츠에 접근할 수 있도록 하기 때문에, 상호운용성을 감소시켜 유저 베이스를 분단하기 때문에 문서는 그러한 확장을 해선 안됩니다.</p>

  <hr>

  <p>이 스펙에서 벤더 중립의 확장이 필요한 경우 이 스펙을 상황에 따라 갱신할 수도 있으며, 확장 스펙이 이 스펙의 요구 사항을 재정의할 수도 있습니다. 이 스펙에서 활동하는 사람이, 그런 확장 스펙의 요건을 승인하기로 결정하면 확장 스펙은 <dfn data-anolis-xref="other applicable specifications" id="other-applicable-specifications">적용 가능한 스펙</dfn>이 됩니다.</p>

  <p>문서에 대한 적합용어는 적용 가능한 스펙에 따라 도입되는 변경점의 성질 및 콘텐츠와 의도 된 문서의 해석에 의존합니다. 적용 가능한 스펙은 새로운 문서 콘텐츠 (예를 들면 footer 요소)를 정의해도 좋고, 특정한 것 외의 적합 콘텐츠를 금지하는 것（예를 들어 &lt;TABLE&gt; 사용을 금지한다）, 이 스펙에서 정의된 콘텐츠에 대한 시맨틱, DOM 변환 또는 처리규칙을 변경해도 좋다. 문서가 적용 가능한 스펙의 용도에 의존하지 않는 <a href="#conforming-documents">적합 HTML5 문서</a>인지 아닌지 : 주어진 <a href="#conforming-documents">적합 HTML5 문서</a>의 구문 및 시멘틱이 적용 가능한 스펙의 사용으로 인해 변경되지 않는 경우 그 문서는 <a href="#conforming-documents">적합 HTML5 문서</a>인채로 유지됩니다. 주어진 （다른 적합）문서의 시맨틱 혹은 처리가 적용 가능한 스펙의 사용에 의해 변경되는 경우 그는 <a href="#conforming-documents">적합 HTML5 문서</a>가 아닙니다. 이런 경우 적용 가능한 스펙은 적합 용어를 정의해야만 합니다.</p>

  <p class="note">제안되었지만 필수는 아닌 관습으로써, 그런 스펙은 "적합 HTML5 + XXX문서" 같은 적합용어를 정의할 수도 있습니다. 여기서 XXX는 적용 가능한 스펙에 대한 짧은 이름입니다.（예："적합 HTML5 + 자동 확장 문서"）。</p>

  <p class="note">
    
    위에서 결정한 규칙의 결과로 일부 문법이 정확한 HTML5 문서가 적용 가능한 기술 아래에서 <a href="#conforming-documents">적합 HTML5 문서</a>가 아닐 수도 있습니다. (예: 적용 가능한 스펙이 한 묶음처럼 정의하는 &lt;table&gt;를 정의한다- 비록 요소가 HTML5 문법을 제대로 준수해도, 그 스펙에 쓰인 &lt;table&gt; 요소를 포함한 문법은 <a href="#conforming-documents">적합 HTML5 문서</a>가 아닙니다)

  <h3 id="case-sensitivity-and-string-comparison"><span class="secno">2.3</span> 대소문자 구분 및 문자열 비교</h3>

  <p><dfn id="case-sensitive">대소문자 구분</dfn>에 있어 두 문자열을 비교하는 건 정확한 코드 포인트를 비교하는 데 의미가 있습니다.</p>

  <p><dfn id="ascii-case-insensitive">ASCII 대소문자 구분</dfn>에 있어 두 문자열을 비교하는 방법은 코드 포인트채로 정확히 비교하는 것을 의미하며, U+0041부터 U+005A까지의 범위(즉 LATIN CAPITAL LETTER A부터 LATIN CAPITAL LETTER Z까지)를 제외하고 U+0061부터 U+007A까지 범위（즉 LATIN SMALL LETTER A부터 LATIN SMALL LETTER Z까지）에 일치하는 것으로 간주합니다.</p>

  <p><dfn id="compatibility-caseless">호환 대소문자 구분</dfn>에서 두 문자열을 비교하는 방법은 언어 고유의 수정(trailoring) 없이, 두 문자열을 비교하기 위해 Unicode <i>호환성 대소문자 비구분 일치</i> 작업을 사용하는걸 의미 합니다.<a href="references.html#refsUNICODE">[UNICODE]</a></p>

  <p>명확히 써져있는 경우를 제외하고 문자열 비교는 <a href="#case-sensitive">대소문자 구분</a> 방법이 아닙니다.</p>

  <p><var data-anolis-xref="">pattern</var>이 <var data-anolis-xref="">s</var> 미만인 <var data-anolis-xref="">pattern</var> 길이에서 <var data-anolis-xref="">s</var>를 버렸지만 서로 매치하고있는 두가지 문자열인 경우 문자열의 <var data-anolis-xref="">pattern</var>은 문자열 <var data-anolis-xref="">s</var>와 <dfn id="prefix-match">prefix match</dfn>합니다.</p>

  <h3 id="common-microsyntaxes"><span class="secno">2.4</span> 공통 마이크로 구문</h3>

  <p>
    날짜나 숫자 등, HTML에는 특정 데이터 타입을 받는 여러 부분이 있습니다.
    이 절에서는, 이런 타입의 적합 기준이 무엇인지, 그리고 어떻게 해석해야 하는 지 설명합니다.
  </p>

  <p>이 스펙의 용도에 있어 <dfn data-anolis-xref="space character" id="space-character">공백 문자</dfn>는 U+0020 SPACE、"tab"（U+0009）、"LF"（U+000A）、"FF"（U+000C）、"CR"（U+000D）입니다.</p>

  <p><dfn data-anolis-xref="White_Space" id="white_space">white space</dfn>는 Unicode의 <code data-anolis-xref="">PropList.txt</code>데이터 파일에서 Unicode 프로퍼티 "White_Space"를 가지는 것입니다.<a href="references.html#refsUNICODE">[UNICODE]</a></p>

<p class="note"><code data-anolis-xref="">Unicode.txt</code> 데이터 파일에서 "Bidi_Class" 프로퍼티의 "White_Space"값（"WS"라 생략되기도 함）과 혼동하지 마십시오.</p>

  <p><dfn id="control-characters">제어 문자</dfn>에서는 Unicode의 <code data-anolis-xref="">UnicodeData.txt</code> 데이터파일에서 Unicode의 "White_Space" 프로퍼티를 가지는 것입니다.<a href="references.html#refsUNICODE">[UNICODE]</a></p>

  <p><dfn id="uppercase-ascii-letters">대문자 ASCII 문자</dfn>는 범위 <a href="#uppercase-ascii-letters">대문자 ASCII 문자</a> 내의 문자입니다.</p>

  <p><dfn id="lowercase-ascii-letters">소문자 ASCII 문자</dfn>는 범위 <a href="#lowercase-ascii-letters">소문자 ASCII 문자</a> 내의 문자입니다.</p>

  <p><dfn id="ascii-digits">ASCII 숫자</dfn>는 <a href="#ascii-digits">ASCII 숫자</a> 범위의 문자입니다.</p>

  <p><dfn id="alphanumeric-ascii-characters">알파뉴메릭 ASCII 문자</dfn>는 <a href="#uppercase-ascii-letters">대문자 ASCII 문자</a>、<a href="#lowercase-ascii-letters">소문자 ASCII 문자</a>, 또는 <a href="#ascii-digits">ASCII 숫자</a> 중 하나입니다.</p>

  <p><dfn id="ascii-hex-digits">ASCII 16진수</dfn>는 <a href="#ascii-digits">ASCII 숫자</a>、U+0041 LATIN CAPITAL LETTER A부터 U+0046 LATIN CAPITAL LETTER F까지 및 U+0061 LATIN SMALL LETTER A부터 U+0066 LATIN SMALL LETTER F 범위 내의 문자입니다.</p>

  <p><dfn id="uppercase-ascii-hex-digits">대문자 ASCII 16진수</dfn>는 <a href="#ascii-digits">ASCII 숫자</a> 및 U+0041 LATIN CAPITAL LETTER A부터 U+0046 LATIN CAPITAL LETTER F 안에서의 문자입니다.</p>

  <p><dfn id="lowercase-ascii-hex-digits">소문자 ASCII 16진수</dfn>는 <a href="#ascii-digits">ASCII 숫자</a> 및 U+0061 LATIN SMALL LETTER A부터 U+0066 LATIN SMALL LETTER F 안에서의 문자입니다.</p>

  <h4 id="boolean-attributes"><span class="secno">2.4.2</span> boolean 속성</h4>

  <p>
    몇 속성은 <dfn data-anolis-xref="boolean attribute" id="boolean-attribute">boolean 속성</dfn>입니다.
    요소에서의 boolean 속성이 존재하는 건 true를 의미하고, 존재하지 않는 건 false를 나타냅니다.
  </p>

  <p>
    속성이 존재하는 경우, 값의 맨 처음, 혹은 맨 뒤에 공백 없이, 빈 문자열 혹은 속성의 정규명에서<a href="#ascii-case-insensitive">ASCII 대소문자 비구분</a>으로 매치하는 값이어야만 합니다.</p>

  <p class="note">값 "true" 및 "false"는 boolean 속성에서 사용할 수 없습니다. false를 나타내기 위해 속성을 완전히 제거해야할 필요가 있습니다.</p>

  <div class="example">
    <p>checked 및 disabled 되어있는 체크박스의 예를 표현합니다.<code data-anolis-xref="attr-input-checked"><a href="forms.html#attr-input-checked">checked</a></code> 및 <code data-anolis-xref="attr-fe-disabled"><a href="forms.html#attr-fe-disabled">disabled</a></code> 속성은 boolean 속성입니다.</p>
    <pre>
&lt;label&gt;&lt;input type=checkbox checked name=cheese disabled&gt; Cheese&lt;/label&gt;
</pre>

    <p>이는 아래와 같이 써있는 것과 동일합니다 :</p>
    <pre>
&lt;label&gt;&lt;input type=checkbox checked=checked name=cheese disabled=disabled&gt; Cheese&lt;/label&gt;
</pre>

    <p>스타일을 섞는 것도 가능합니다. 아래 예제는 여전히 동일합니다 :</p>
    <pre>
&lt;label&gt;&lt;input type='checkbox' checked name=cheese disabled=""&gt; Cheese&lt;/label&gt;
</pre>
  </div>
  <!-- TODO : 번역 진행 중 -->
  
  <h4 id="keywords-and-enumerated-attributes"><span class="secno">2.4.3</span> 키워드 및 열거 속성</h4>
  <p>一部の属性は、有限集合のキーワードのいずれかを取るように定義されている。このような属性は<dfn data-anolis-xref="enumerated attribute" id="enumerated-attribute">列挙属性</dfn>と呼ばれる。キーワードは、特定の<em>状態</em>にそれぞれ対応付けて定義される（キーワードの一部が互いに同義語となる場合、複数のキーワードは同じ状態に対応づけられる。加えて、一部のキーワードは不適合であると言うことができる。これは、歴史的な理由のためだけの仕様である）。さらに、2つのデフォルト状態を挙げることができる。1つは<i>妥当でない値のデフォルト</i>であり、もう1つは<i>欠落した値のデフォルト</i>である。</p>

  <p>列挙属性が指定される場合、属性値は、先行または後続の空白なしで、不適合でないとされる与えられたキーワードのいずれかと<a href="#ascii-case-insensitive">ASCII大文字・小文字不区別</a>で一致しなければならない。</p>

  <p>属性が指定される際に、その値が与えられたキーワードのいずれかと<a href="#ascii-case-insensitive">ASCII大文字・小文字不区別</a>で一致する場合、属性のキーワードの状態は、属性が表す状態である。属性値が与えられたキーワードのいずれにも一致しないが、属性が<i>妥当でない値のデフォルト</i>を持つ場合、その属性はその状態を表す。そうでなければ、属性値がキーワードのいずれにも一致しないが<i>欠落値のデフォルト</i>状態定義が存在する場合、<em>それ</em>は属性によって表される状態である。そうでなければ、デフォルトは存在せず、何も表さない状態を意味する妥当でない値である。</p>

  <p>属性が指定<em>されない</em>際に、<i>欠落値のデフォルト</i>定義状態がある場合、それは（欠落）属性によって表される状態である。そうでなければ、属性の不在は何も状態を表さないことを意味する。</p>

  <p class="note">空文字列は妥当なキーワードとなりうる。</p>

  <h4 id="numbers"><span class="secno">2.4.4</span> 数字</h4>

  <h5 id="signed-integers"><span class="secno">2.4.4.1</span> 符号付き整数</h5>

  <p>文字列が1つ以上の<a href="#ascii-digits">ASCII 数字</a>、任意で接頭辞"-"（U+002D）文字を持つ場合、文字列は<dfn id="valid-integer">妥当な整数</dfn>である。</p>

  <p>"-"（U+002D）接頭辞なしの<a href="#valid-integer">妥当な整数</a>は、10進数を表す。"-"（U+002D）接頭辞<em>あり</em>の<a href="#valid-integer">妥当な整数</a>は、U+002D HYPHEN-MINUSに続く10進数を表し、ゼロから減算される。</p>

  <div class="impl">
    <p>The <dfn id="rules-for-parsing-integers">rules for parsing integers</dfn> are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either an integer or an error.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">sign</var> have the value "positive".</p>
      </li>

      <li>
        <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</p>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> (the first character) is a "-" (U+002D) character:</p>

        <ol>
          <li>Let <var data-anolis-xref="">sign</var> be "negative".</li>

          <li>Advance <var data-anolis-xref="">position</var> to the next character.</li>

          <li>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</li>
        </ol>

        <p>Otherwise, if the character indicated by <var data-anolis-xref="">position</var> (the first character) is a "+" (U+002B) character:</p>

        <ol>
          <li>Advance <var data-anolis-xref="">position</var> to the next character. (The "<code data-anolis-xref="">+</code>" is ignored, but it is not conforming.)</li>

          <li>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</li>
        </ol>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is not an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, then return an error.</p>
      </li><!-- Ok. At this point we know we have a number. It might have
   trailing garbage which we'll ignore, but it's a number, and we
   won't return an error. -->

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>, and interpret the resulting sequence as a base-ten integer. Let <var data-anolis-xref="">value</var> be that integer.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">sign</var> is "positive", return <var data-anolis-xref="">value</var>, otherwise return the result of subtracting <var data-anolis-xref="">value</var> from zero.</p>
      </li>
    </ol>
  </div>

  <h5 id="non-negative-integers"><span class="secno">2.4.4.2</span> 非負整数</h5>

  <p>1つ以上の<a href="#ascii-digits">ASCII数字</a>からなる場合、文字列は<dfn id="valid-non-negative-integer">妥当な非負整数</dfn>である。</p>

  <p><a href="#valid-non-negative-integer">妥当な非負整数</a>は、10進数である数を表す。</p>

  <div class="impl">
    <p>The <dfn id="rules-for-parsing-non-negative-integers">rules for parsing non-negative integers</dfn> are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either zero, a positive integer, or an error.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">value</var> be the result of parsing <var data-anolis-xref="">input</var> using the <a href="#rules-for-parsing-integers">rules for parsing integers</a>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">value</var> is an error, return an error.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">value</var> is less than zero, return an error.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">value</var>.</p>
      </li>
    </ol><!-- Implications: A leading + is ignored. A leading - is ignored if the value is zero. -->
  </div>

  <h5 id="floating-point-numbers"><span class="secno">2.4.4.3</span> 浮動小数点数</h5>

  <p>次の場合、文字列は<dfn id="valid-floating-point-number">妥当な浮動小数点数</dfn>である：</p>

  <ol class="brief">
    <li>任意で、"-"（U+002D）文字。</li>

    <li>次のいずれかまたは両方の、与えられた順：

      <ol>
        <li>ひと続きの1つ以上の<a href="#ascii-digits">ASCII数字</a>。
        </li>

        <li>
          <ol>
            <li>1つの"."（U+002E）文字。</li>

            <li>ひと続きの1つ以上の<a href="#ascii-digits">ASCII数字</a>。
            </li>
          </ol>
        </li>
      </ol>
    </li>

    <li>任意で：

      <ol>
        <li>"e"（U+0065）文字または"E"（U+0045）文字のいずれか。</li>

        <li>任意で、"-"（U+002D）文字または"+"（U+002B）文字。</li>

        <li>ひと続きの1つ以上の<a href="#ascii-digits">ASCII数字</a>。
        </li>
      </ol>
    </li>
  </ol>

  <p><a href="#valid-floating-point-number">妥当な浮動小数点数</a>は、10の累乗による仮数部の乗算によって得られる。ここで乗算は最初の数であり、10進数として解釈される（もしあれば、小数点および小数点の後の数を含み、文字列全体が"-"（U+002D）文字で始まるおよび数値がゼロでない場合、負数として仮数部を解釈する）。またここで、もしあれば、指数はEの後の数字である（Eと数字と数字の間に"-"（U+002D）文字がある場合、負数として解釈され、数字がゼロでない、またはその他Eと数字の間に"+"（U+002B）文字が存在する場合無視できる）。Eが存在しない場合、指数はゼロとして扱われる。</p>

  <p class="note">無限大および非数（NaN）値は<a data-anolis-xref="valid floating-point number" href="#valid-floating-point-number">妥当な浮動小数点数</a>ではない。</p>

  <div class="impl">
    <p>The <dfn data-anolis-xref="best representation of the number as a floating-point number" id="best-representation-of-the-number-as-a-floating-point-number">best representation of the number <var data-anolis-xref="">n</var> as a floating-point number</dfn> is the string obtained from applying the JavaScript operator ToString to <var data-anolis-xref="">n</var>. The JavaScript operator ToString is not uniquely determined. When there are multiple possible strings that could be obtained from the JavaScript operator ToString for a particular value, the user agent must always return the same string for that value (though it may differ from the value used by other user agents).</p>

    <p>The <dfn id="rules-for-parsing-floating-point-number-values">rules for parsing floating-point number values</dfn> are as given in the following algorithm. This algorithm must be aborted at the first step that returns something. This algorithm will return either a number or an error.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">value</var> have the value 1.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">divisor</var> have the value 1.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">exponent</var> have the value 1.</p>
      </li>

      <li>
        <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</p>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is a U+002D HYPHEN-MINUS character (-):</p>

        <ol>
          <li>Change <var data-anolis-xref="">value</var> and <var data-anolis-xref="">divisor</var> to −1.</li>

          <li>Advance <var data-anolis-xref="">position</var> to the next character.</li>

          <li>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</li>
        </ol>

        <p>Otherwise, if the character indicated by <var data-anolis-xref="">position</var> (the first character) is a "+" (U+002B) character:</p>

        <ol>
          <li>Advance <var data-anolis-xref="">position</var> to the next character. (The "<code data-anolis-xref="">+</code>" is ignored, but it is not conforming.)</li>

          <li>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</li>
        </ol>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is a "." (U+002E), and that is not the last character in <var data-anolis-xref="">input</var>, and the character after the character indicated by <var data-anolis-xref="">position</var> is an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, then set <var data-anolis-xref="">value</var> to zero and jump to the step labeled <i>fraction</i>.</p><!-- we have to check there's a number so that ".e1" fails to parse but ".0"
   does not -->
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is not an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, then return an error.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>, and interpret the resulting sequence as a base-ten integer. Multiply <var data-anolis-xref="">value</var> by that integer.</p>
      </li>

      <li>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, jump to the step labeled <i>conversion</i>.</li>

      <li>
        <p><i>Fraction</i>: If the character indicated by <var data-anolis-xref="">position</var> is a "." (U+002E), run these substeps:</p>

        <ol>
          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, or if the character indicated by <var data-anolis-xref="">position</var> is not an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, "e" (U+0065), or "E" (U+0045), then jump to the step labeled <i>conversion</i>.</p>
          </li>

          <li>
            <p>If the character indicated by <var data-anolis-xref="">position</var> is a "e" (U+0065) character or a "E" (U+0045) character, skip the remainder of these substeps.</p>
          </li>

          <li>
            <p><i>Fraction loop</i>: Multiply <var data-anolis-xref="">divisor</var> by ten.</p>
          </li>

          <li>Add the value of the character indicated by <var data-anolis-xref="">position</var>, interpreted as a base-ten digit (0..9) and divided by <var data-anolis-xref="">divisor</var>, to <var data-anolis-xref="">value</var>.</li>

          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then jump to the step labeled <i>conversion</i>.</p>
          </li>

          <li>
            <p>If the character indicated by <var data-anolis-xref="">position</var> is an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, jump back to the step labeled <i>fraction loop</i> in these substeps.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is a "e" (U+0065) character or a "E" (U+0045) character, run these substeps:</p>

        <ol>
          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then jump to the step labeled <i>conversion</i>.</p>
          </li>

          <li>
            <p>If the character indicated by <var data-anolis-xref="">position</var> is a "-" (U+002D) character:</p>

            <ol>
              <li>Change <var data-anolis-xref="">exponent</var> to −1.</li>

              <li>Advance <var data-anolis-xref="">position</var> to the next character.</li>

              <li>
                <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then jump to the step labeled <i>conversion</i>.</p>
              </li>
            </ol>

            <p>Otherwise, if the character indicated by <var data-anolis-xref="">position</var> is a "+" (U+002B) character:</p>

            <ol>
              <li>Advance <var data-anolis-xref="">position</var> to the next character.</li>

              <li>
                <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then jump to the step labeled <i>conversion</i>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>If the character indicated by <var data-anolis-xref="">position</var> is not an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, then jump to the step labeled <i>conversion</i>.</p>
          </li>

          <li>
            <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>, and interpret the resulting sequence as a base-ten integer. Multiply <var data-anolis-xref="">exponent</var> by that integer.</p>
          </li>

          <li>
            <p>Multiply <var data-anolis-xref="">value</var> by ten raised to the <var data-anolis-xref="">exponent</var>th power.</p>
          </li>
        </ol>
      </li>

      <li>
        <p><i>Conversion</i>: Let <var data-anolis-xref="">S</var> be the set of finite IEEE 754 double-precision floating-point values except −0, but with two special values added: 2<sup data-anolis-xref="">1024</sup> and −2<sup data-anolis-xref="">1024</sup>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">rounded-value</var> be the number in <var data-anolis-xref="">S</var> that is closest to <var data-anolis-xref="">value</var>, selecting the number with an even significand if there are two equally close values. (The two special values 2<sup data-anolis-xref="">1024</sup> and −2<sup data-anolis-xref="">1024</sup> are considered to have even significands for this purpose.)</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">rounded-value</var> is 2<sup data-anolis-xref="">1024</sup> or −2<sup data-anolis-xref="">1024</sup>, return an error.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">rounded-value</var>.</p>
      </li>
    </ol>
  </div>

  <div class="impl">
    <h5 id="percentages-and-dimensions"><span class="secno">2.4.4.4</span> Percentages and lengths</h5>

    <p>The <dfn id="rules-for-parsing-dimension-values">rules for parsing dimension values</dfn> are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than or equal to 1.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</p>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is a U+002B PLUS SIGN character (+), advance <var data-anolis-xref="">position</var> to the next character.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are "0" (U+0030) characters, and discard them.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return an error.</p>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is not one of "1" (U+0031) to "9" (U+0039), then return an error.</p>
      </li><!-- Ok. At this point we know we have a number. It might have trailing garbage which we'll
   ignore, but it's a number, and we won't return an error. -->

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>, and interpret the resulting sequence as a base-ten integer. Let <var data-anolis-xref="">value</var> be that number.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return <var data-anolis-xref="">value</var> as a length.</p>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is a U+002E FULL STOP character (.):</p>

        <ol>
          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, or if the character indicated by <var data-anolis-xref="">position</var> is not an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, then return <var data-anolis-xref="">value</var> as a length.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">divisor</var> have the value 1.</p>
          </li>

          <li>
            <p><i>Fraction loop</i>: Multiply <var data-anolis-xref="">divisor</var> by ten.</p>
          </li>

          <li>Add the value of the character indicated by <var data-anolis-xref="">position</var>, interpreted as a base-ten digit (0..9) and divided by <var data-anolis-xref="">divisor</var>, to <var data-anolis-xref="">value</var>.</li>

          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then return <var data-anolis-xref="">value</var> as a length.</p>
          </li>

          <li>
            <p>If the character indicated by <var data-anolis-xref="">position</var> is an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, return to the step labeled <i>fraction loop</i> in these substeps.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, return <var data-anolis-xref="">value</var> as a length.</p>
      </li>

      <li>
        <p>If the character indicated by <var data-anolis-xref="">position</var> is a "%" (U+0025) character, return <var data-anolis-xref="">value</var> as a percentage.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">value</var> as a length.</p>
      </li>
    </ol>
  </div>

  <h5 id="lists-of-integers"><span class="secno">2.4.4.5</span> 整数リスト</h5>

  <p><dfn id="valid-list-of-integers">妥当な整数リスト</dfn>は、U+002C COMMA文字によって区切られる多数の<a data-anolis-xref="valid integer" href="#valid-integer">妥当な整数</a>であり、他の文字を持たない（たとえば<a data-anolis-xref="space character" href="#space-character">空白文字</a>のない）。さらに、与えられる整数の数、または許可される値の範囲には制限があるかもしれない。</p>

  <div class="impl">
    <p>The <dfn id="rules-for-parsing-a-list-of-integers">rules for parsing a list of integers</dfn> are as follows:</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">numbers</var> be an initially empty list of integers. This list will be the result of this algorithm.</p>
      </li>

      <li>
        <p>If there is a character in the string <var data-anolis-xref="">input</var> at position <var data-anolis-xref="">position</var>, and it is either a U+0020 SPACE, U+002C COMMA, or U+003B SEMICOLON character, then advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>, or to beyond the end of the string if there are no more characters.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> points to beyond the end of <var data-anolis-xref="">input</var>, return <var data-anolis-xref="">numbers</var> and abort.</p>
      </li>

      <li>
        <p>If the character in the string <var data-anolis-xref="">input</var> at position <var data-anolis-xref="">position</var> is a U+0020 SPACE, U+002C COMMA, or U+003B SEMICOLON character, then return to step 4.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">negated</var> be false.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">value</var> be 0.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">started</var> be false. This variable is set to true when the parser sees a number or a "-" (U+002D) character.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">got number</var> be false. This variable is set to true when the parser sees a number.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">finished</var> be false. This variable is set to true to switch parser into a mode where it ignores characters until the next separator.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">bogus</var> be false.</p>
      </li>

      <li>
        <p><i>Parser</i>: If the character in the string <var data-anolis-xref="">input</var> at position <var data-anolis-xref="">position</var> is:</p>

        <dl class="switch">
          <dt>A U+002D HYPHEN-MINUS character</dt>

          <dd>
            <p>Follow these substeps:</p>

            <ol>
              <li>If <var data-anolis-xref="">got number</var> is true, let <var data-anolis-xref="">finished</var> be true.</li>

              <li>If <var data-anolis-xref="">finished</var> is true, skip to the next step in the overall set of steps.</li>

              <li>If <var data-anolis-xref="">started</var> is true, let <var data-anolis-xref="">negated</var> be false.</li>

              <li>Otherwise, if <var data-anolis-xref="">started</var> is false and if <var data-anolis-xref="">bogus</var> is false, let <var data-anolis-xref="">negated</var> be true.</li>

              <li>Let <var data-anolis-xref="">started</var> be true.</li>
            </ol>
          </dd>

          <dt>
            An <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>
          </dt>

          <dd>
            <p>Follow these substeps:</p>

            <ol>
              <li>If <var data-anolis-xref="">finished</var> is true, skip to the next step in the overall set of steps.</li>

              <li>Multiply <var data-anolis-xref="">value</var> by ten.</li>

              <li>Add the value of the digit, interpreted in base ten, to <var data-anolis-xref="">value</var>.</li>

              <li>Let <var data-anolis-xref="">started</var> be true.</li>

              <li>Let <var data-anolis-xref="">got number</var> be true.</li>
            </ol>
          </dd>

          <dt>A U+0020 SPACE character</dt>

          <dt>A U+002C COMMA character</dt>

          <dt>A U+003B SEMICOLON character</dt>

          <dd>
            <p>Follow these substeps:</p>

            <ol>
              <li>If <var data-anolis-xref="">got number</var> is false, return the <var data-anolis-xref="">numbers</var> list and abort. This happens if an entry in the list has no digits, as in "<code data-anolis-xref="">1,2,x,4</code>".</li>

              <li>If <var data-anolis-xref="">negated</var> is true, then negate <var data-anolis-xref="">value</var>.</li>

              <li>Append <var data-anolis-xref="">value</var> to the <var data-anolis-xref="">numbers</var> list.</li>

              <li>Jump to step 4 in the overall set of steps.</li>
            </ol>
          </dd><!-- <dt>A U+002E FULL STOP character</dt> -->

          <dt>A character in the range U+0001 to U+001F, <!-- space --> U+0021 to U+002B, <!-- comma --> U+002D to U+002F, <!-- digits --> U+003A, <!-- semicolon --> U+003C to U+0040, <!-- a-z --> U+005B to U+0060, <!-- A-Z --> U+007b to U+007F (i.e. any other non-alphabetic ASCII character)</dt><!--
 Test: http://www.hixie.ch/tests/adhoc/html/flow/image-maps/004-demo.html
 IE6 on Wine treats the following characters like this also: U+1-U+1f, U+21-U+2b, U+2d-U+2f, U+3a,
 U+3c-U+40, U+5b-U+60, U+7b-U+82, U+84-U+89, U+8b, U+8d, U+8f-U+99, U+9b, U+9d, U+a0-U+bf, U+d7,
 U+f7, U+1f6-U+1f9, U+218-U+24f, U+2a9-U+385, U+387, U+38b, U+38d, U+3a2, U+3cf, U+3d7-U+3d9, U+3db,
 U+3dd, U+3df, U+3e1, U+3f4-U+400, U+40d, U+450, U+45d, U+482-U+48f, U+4c5-U+4c6, U+4c9-U+4ca,
 U+4cd-U+4cf, U+4ec-U+4ed, U+4f6-U+4f7, U+4fa-U+530, U+557-U+560, U+588-U+5cf, U+5eb-U+5ef,
 U+5f3-U+620, U+63b-U+640, U+64b-U+670, U+6b8-U+6b9, U+6bf, U+6cf, U+6d4, U+6d6-U+904, U+93a-U+957,
 U+962-U+984, U+98d-U+98e, U+991-U+992, U+9a9, U+9b1, U+9b3-U+9b5, U+9ba-U+9db, U+9de, U+9e2-U+9ef,
 U+9f2-U+a04, U+a0b-U+a0e, U+a11-U+a12, U+a29, U+a31, U+a34, U+a37, U+a3a-U+a58, U+a5d, U+a5f-U+a84,
 U+a8c, U+a8e, U+a92, U+aa9, U+ab1, U+ab4, U+aba-U+adf, U+ae1-U+b04, U+b0d-U+b0e, U+b11-U+b12,
 U+b29, U+b31, U+b34-U+b35, U+b3a-U+b5b, U+b5e, U+b62-U+b84, U+b8b-U+b8d, U+b91, U+b96-U+b98, U+b9b,
 U+b9d, U+ba0-U+ba2, U+ba5-U+ba7, U+bab-U+bad, U+bb6, U+bba-U+c04, U+c0d, U+c11, U+c29, U+c34,
 U+c3a-U+c5f, U+c62-U+c84, U+c8d, U+c91, U+ca9, U+cb4, U+cba-U+cdd, U+cdf, U+ce2-U+d04, U+d0d,
 U+d11, U+d29, U+d3a-U+d5f, U+d62-U+e00, U+e2f, U+e31, U+e34-U+e3f, U+e46-U+e80, U+e83, U+e85-U+e86,
 U+e89, U+e8b-U+e8c, U+e8e-U+e93, U+e98, U+ea0, U+ea4, U+ea6, U+ea8-U+ea9, U+eac, U+eaf-U+edb,
 U+ede-U+109f, U+10c6-U+10cf, U+10f7-U+10ff, U+115a-U+115e, U+11a3-U+11a7, U+11fa-U+1dff,
 U+1e9b-U+1e9f, U+1efa-U+1eff, U+1f16-U+1f17, U+1f1e-U+1f1f, U+1f46-U+1f47, U+1f4e-U+1f4f, U+1f58,
 U+1f5a, U+1f5c, U+1f5e, U+1f7e-U+1f7f, U+1fb5, U+1fbd-U+1fc1, U+1fc5, U+1fcd-U+1fcf, U+1fd4-U+1fd5,
 U+1fdc-U+1fdf, U+1fed-U+1ff1, U+1ff5, U+1ffd-U+249b, U+24ea-U+3004, U+3006-U+3040, U+3095-U+309a,
 U+309f-U+30a0, U+30fb, U+30ff-U+3104, U+312d-U+3130, U+318f-U+4dff, U+9fa6-U+abff, U+d7a4-U+d7ff,
 U+e000-U+f8ff, U+fa2e-U+faff, U+fb07-U+fb12, U+fb18-U+fb1e, U+fb37, U+fb3d, U+fb3f, U+fb42, U+fb45,
 U+fbb2-U+fbd2, U+fbe9, U+fce1, U+fd3e-U+fd4f, U+fd90-U+fd91, U+fdc8-U+fdef, U+fdfc-U+fe7f,
 U+fefd-U+ff20, U+ff3b-U+ff40, U+ff5b-U+ff65, U+ffa0, U+ffbf-U+ffc1, U+ffc8-U+ffc9, U+ffd0-U+ffd1,
 U+ffd8-U+ffd9, U+ffdd-U+ffff
 IE7 on Win2003 treats the following characters like this also instead: U+1-U+1f, U+21-U+2b,
 U+2d-U+2f, U+3a, U+3c-U+40, U+5b-U+60, U+7b-U+82, U+84-U+89, U+8b, U+8d, U+8f-U+99, U+9b, U+9d,
 U+a0-U+a9, U+ab-U+b4, U+b6-U+b9, U+bb-U+bf, U+d7, U+f7, U+220-U+221, U+234-U+24f, U+2ae-U+2af,
 U+2b9-U+2ba, U+2c2-U+2df, U+2e5-U+2ed, U+2ef-U+344, U+346-U+379, U+37b-U+385, U+387, U+38b, U+38d,
 U+3a2, U+3cf, U+3d8-U+3d9, U+3f4-U+3ff, U+482-U+48b, U+4c5-U+4c6, U+4c9-U+4ca, U+4cd-U+4cf,
 U+4f6-U+4f7, U+4fa-U+530, U+557-U+558, U+55a-U+560, U+588-U+5cf, U+5eb-U+5ef, U+5f3-U+620,
 U+63b-U+640, U+656-U+66f, U+6d4, U+6dd-U+6e0, U+6e9-U+6ec, U+6ee-U+6f9, U+6fd-U+70f, U+72d-U+72f,
 U+740-U+77f, U+7b1-U+900, U+904, U+93a-U+93c, U+94d - U+94f, U+951-U+957, U+964-U+980, U+984,
 U+98d-U+98e, U+991-U+992, U+9a9, U+9b1, U+9b3-U+9b5, U+9ba-U+9bd, U+9c5-U+9c6, U+9c9-U+9ca,
 U+9cd-U+9d6, U+9d8-U+9db, U+9de, U+9e4-U+9ef, U+9f2-U+a01, U+a03-U+a04, U+a0b-U+a0e, U+a11-U+a12,
 U+a29, U+a31, U+a34, U+a37, U+a3a-U+a3d, U+a43-U+a46, U+a49-U+a4a, U+a4d-U+a58, U+a5d, U+a5f-U+a6f,
 U+a75-U+a80, U+a84, U+a8c, U+a8e, U+a92, U+aa9, U+ab1, U+ab4, U+aba-U+abc, U+ac6, U+aca,
 U+acd-U+acf, U+ad1-U+adf, U+ae1-U+b00, U+b04, U+b0d-U+b0e, U+b11-U+b12, U+b29, U+b31, U+b34-U+b35,
 U+b3a-U+b3c, U+b44-U+b46, U+b49 - U+b4a, U+b4d-U+b55, U+b58-U+b5b, U+b5e, U+b62-U+b81, U+b84,
 U+b8b-U+b8d, U+b91, U+b96-U+b98, U+b9b, U+b9d, U+ba0 - U+ba2, U+ba5-U+ba7, U+bab-U+bad, U+bb6,
 U+bba-U+bbd, U+bc3-U+bc5, U+bc9, U+bcd-U+bd6, U+bd8-U+c00, U+c04, U+c0d, U+c11, U+c29, U+c34,
 U+c3a-U+c3d, U+c45, U+c49, U+c4d-U+c54, U+c57-U+c5f, U+c62-U+c81, U+c84, U+c8d, U+c91, U+ca9,
 U+cb4, U+cba-U+cbd, U+cc5, U+cc9, U+ccd-U+cd4, U+cd7-U+cdd, U+cdf, U+ce2-U+d01, U+d04, U+d0d,
 U+d11, U+d29, U+d3a-U+d3d, U+d44-U+d45, U+d49, U+d4d-U+d56, U+d58-U+d5f, U+d62-U+d81, U+d84,
 U+d97-U+d99, U+db2, U+dbc, U+dbe - U+dbf, U+dc7-U+dce, U+dd5, U+dd7, U+de0-U+df1, U+df4-U+e00,
 U+e3b-U+e3f, U+e4f-U+e80, U+e83, U+e85-U+e86, U+e89, U+e8b-U+e8c, U+e8e-U+e93, U+e98, U+ea0, U+ea4,
 U+ea6, U+ea8-U+ea9, U+eac, U+eba, U+ebe-U+ebf, U+ec5-U+ecc, U+ece-U+edb, U+ede-U+eff, U+f01-U+f3f,
 U+f48, U+f6b-U+f70, U+f82-U+f87, U+f8c-U+f8f, U+f98, U+fbd-U+fff, U+1022, U+1028, U+102b,
 U+1033-U+1035, U+1037, U+1039-U+104f, U+105a-U+109f, U+10c6-U+10cf, U+10f7-U+10ff, U+115a - U+115e,
 U+11a3-U+11a7, U+11fa-U+11ff, U+1207, U+1247, U+1249, U+124e-U+124f, U+1257, U+1259, U+125e-U+125f,
 U+1287, U+1289, U+128e-U+128f, U+12af, U+12b1, U+12b6-U+12b7, U+12bf, U+12c1, U+12c6-U+12c7,
 U+12cf, U+12d7, U+12ef, U+130f, U+1311, U+1316-U+1317, U+131f, U+1347, U+135b-U+139f,
 U+13f5-U+1400, U+166d-U+166e, U+1677-U+1680, U+169b - U+169f, U+16eb-U+177f, U+17c9-U+181f, U+1843,
 U+1878-U+187f, U+18aa-U+1dff, U+1e9c-U+1e9f, U+1efa-U+1eff, U+1f16-U+1f17, U+1f1e-U+1f1f,
 U+1f46-U+1f47, U+1f4e-U+1f4f, U+1f58, U+1f5a, U+1f5c, U+1f5e, U+1f7e-U+1f7f, U+1fb5, U+1fbd,
 U+1fbf-U+1fc1, U+1fc5, U+1fcd-U+1fcf, U+1fd4-U+1fd5, U+1fdc-U+1fdf, U+1fed-U+1ff1, U+1ff5,
 U+1ffd-U+207e, U+2080-U+2101, U+2103-U+2106, U+2108-U+2109, U+2114, U+2116-U+2118, U+211e-U+2123,
 U+2125, U+2127, U+2129, U+212e, U+2132, U+213a-U+215f, U+2184-U+3005, U+3008-U+3020, U+302a-U+3037,
 U+303b-U+3104, U+312d-U+3130, U+318f - U+319f, U+31b8-U+33ff, U+4db6-U+4dff, U+9fa6-U+9fff,
 U+a48d-U+abff, U+d7a4-U+d7ff, U+e000-U+f8ff, U+fa2e-U+faff, U+fb07-U+fb12, U+fb18-U+fb1c, U+fb1e,
 U+fb29, U+fb37, U+fb3d, U+fb3f, U+fb42, U+fb45, U+fbb2-U+fbd2, U+fd3e-U+fd4f, U+fd90-U+fd91,
 U+fdc8-U+fdef, U+fdfc-U+fe6f, U+fe73, U+fe75, U+fefd-U+ff20, U+ff3b-U+ff40, U+ff5b-U+ff9f,
 U+ffbf-U+ffc1, U+ffc8-U+ffc9, U+ffd0-U+ffd1, U+ffd8-U+ffd9, U+ffdd-U+ffff
-->

          <dd>
            <p>Follow these substeps:</p>

            <ol>
              <li>If <var data-anolis-xref="">got number</var> is true, let <var data-anolis-xref="">finished</var> be true.</li>

              <li>If <var data-anolis-xref="">finished</var> is true, skip to the next step in the overall set of steps.</li>

              <li>Let <var data-anolis-xref="">negated</var> be false.</li>
            </ol>
          </dd>

          <dt>Any other character</dt><!-- alphabetic a-z A-Z, and non-ASCII -->

          <dd>
            <p>Follow these substeps:</p>

            <ol>
              <li>If <var data-anolis-xref="">finished</var> is true, skip to the next step in the overall set of steps.</li>

              <li>Let <var data-anolis-xref="">negated</var> be false.</li>

              <li>Let <var data-anolis-xref="">bogus</var> be true.</li>

              <li>If <var data-anolis-xref="">started</var> is true, then return the <var data-anolis-xref="">numbers</var> list, and abort. (The value in <var data-anolis-xref="">value</var> is not appended to the list first; it is dropped.)</li>
            </ol>
          </dd>
        </dl>
      </li>

      <li>
        <p>Advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>, or to beyond the end of the string if there are no more characters.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> points to a character (and not to beyond the end of <var data-anolis-xref="">input</var>), jump to the big <i>Parser</i> step above.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">negated</var> is true, then negate <var data-anolis-xref="">value</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">got number</var> is true, then append <var data-anolis-xref="">value</var> to the <var data-anolis-xref="">numbers</var> list.</p>
      </li>

      <li>
        <p>Return the <var data-anolis-xref="">numbers</var> list and abort.</p>
      </li>
    </ol>
  </div>

  <div class="impl">
    <h5 id="lists-of-dimensions"><span class="secno">2.4.4.6</span> Lists of dimensions</h5><!-- no definition of a type since no conforming feature uses this syntax (it's only used in
  cols="" and rows="" on <frameset> -->

    <p>The <dfn id="rules-for-parsing-a-list-of-dimensions">rules for parsing a list of dimensions</dfn> are as follows. These rules return a list of zero or more pairs consisting of a number and a unit, the unit being one of <i>percentage</i>, <i>relative</i>, and <i>absolute</i>.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">raw input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>If the last character in <var data-anolis-xref="">raw input</var> is a "," (U+002C) character, then remove that character from <var data-anolis-xref="">raw input</var>.</p>
      </li>

      <li>
        <p><a data-anolis-xref="split a string on commas" href="#split-a-string-on-commas">Split the string <var data-anolis-xref="">raw input</var> on commas</a>. Let <var data-anolis-xref="">raw tokens</var> be the resulting list of tokens.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">result</var> be an empty list of number/unit pairs.</p>
      </li>

      <li>
        <p>For each token in <var data-anolis-xref="">raw tokens</var>, run the following substeps:</p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">input</var> be the token.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">value</var> be the number 0.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">unit</var> be <i>absolute</i>.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, set <var data-anolis-xref="">unit</var> to <i>relative</i> and jump to the last substep.</p>
          </li>

          <li>
            <p>If the character at <var data-anolis-xref="">position</var> is an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, <a href="#collect-a-sequence-of-characters">collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>, interpret the resulting sequence as an integer in base ten, and increment <var data-anolis-xref="">value</var> by that integer.</p>
          </li>

          <li>
            <p>If the character at <var data-anolis-xref="">position</var> is a "." (U+002E) character, run these substeps:</p>

            <ol>
              <li>
                <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> consisting of <a data-anolis-xref="space character" href="#space-character">space characters</a> and <a href="#ascii-digits">ASCII digits</a>. Let <var data-anolis-xref="">s</var> be the resulting sequence.</p>
              </li>

              <li>
                <p>Remove all <a data-anolis-xref="space character" href="#space-character">space characters</a> in <var data-anolis-xref="">s</var>.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">s</var> is not the empty string, run these subsubsteps:</p>

                <ol>
                  <li>
                    <p>Let <var data-anolis-xref="">length</var> be the number of characters in <var data-anolis-xref="">s</var> (after the spaces were removed).</p>
                  </li>

                  <li>
                    <p>Let <var data-anolis-xref="">fraction</var> be the result of interpreting <var data-anolis-xref="">s</var> as a base-ten integer, and then dividing that number by <span data-anolis-xref="">10<sup data-anolis-xref=""><var data-anolis-xref="">length</var></sup></span>.</p>
                  </li>

                  <li>
                    <p>Increment <var data-anolis-xref="">value</var> by <var data-anolis-xref="">fraction</var>.</p>
                  </li>
                </ol>
              </li>
            </ol>
          </li>

          <li>
            <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
          </li>

          <li>
            <p>If the character at <var data-anolis-xref="">position</var> is a "%" (U+0025) character, then set <var data-anolis-xref="">unit</var> to <i>percentage</i>.</p>

            <p>Otherwise, if the character at <var data-anolis-xref="">position</var> is a U+002A ASTERISK character (*), then set <var data-anolis-xref="">unit</var> to <i>relative</i>.</p>
          </li><!-- the remaining characters in /input/ are ignored -->

          <li>
            <p>Add an entry to <var data-anolis-xref="">result</var> consisting of the number given by <var data-anolis-xref="">value</var> and the unit given by <var data-anolis-xref="">unit</var>.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>Return the list <var data-anolis-xref="">result</var>.</p>
      </li>
    </ol>
  </div>

  <h4 id="dates-and-times"><span class="secno">2.4.5</span> 日付および時刻</h4>

  <p>下記のアルゴリズムにおいて、<dfn id="number-of-days-in-month-month-of-year-year">年<var data-anolis-xref="">year</var>の月<var data-anolis-xref="">month</var>の日数</dfn>は：<var data-anolis-xref="">month</var>が1、3、5、7、8、10、12ならば<em>31</em>である。<var data-anolis-xref="">month</var>が4、6、9、11ならば<em>30</em>である。<var data-anolis-xref="">month</var>が2かつ<var data-anolis-xref="">year</var>が400で割り切れる数、または<var data-anolis-xref="">year</var>が4で割り切れるが100で割り切れないならば<em>29</em>であり、そうでなければ<em>28</em>である。これは、グレゴリオ暦の閏年を考慮に入れている。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p><a href="#ascii-digits">ASCII数字</a>がこの節で定義される日付および時刻の構文で使用される場合、これらは10進数で表現される。</p>

  <div class="impl">
    <p class="note">While the formats described here are intended to be subsets of the corresponding ISO8601 formats, this specification defines parsing rules in much more detail than ISO8601. Implementors are therefore encouraged to carefully examine any date parsing libraries before using them to implement the parsing rules described below; ISO8601 libraries might not parse dates and times in exactly the same manner. <a href="references.html#refsISO8601">[ISO8601]</a></p>
  </div>

  <p>この仕様が<dfn id="proleptic-gregorian-calendar">先発グレゴリオ暦</dfn>を参照する場合、これは、1年に遡って挿入された現代のグレゴリオ暦を意味する。<dfn id="proleptic-gregorian-date">先発グレゴリオ日付</dfn>として明示的に参照される<a href="#proleptic-gregorian-calendar">先発グレゴリオ暦</a>での日付は、たとえ暦が問題の時刻（または場所）で使用されていないとしても、その暦を使用して説明される。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p class="note">この仕様においてワイヤ形式としてのグレゴリオ暦の使用は、決定に関わる人々の文化的なバイアスに起因する恣意的な選択肢である。フォームの<a href="forms.html#input-author-notes">日付、時刻、数値の形式</a>および <span class="impl">(for authors), <a href="forms.html#input-impl-notes">implemention notes regarding localization of form controls</a>,</span> <code><a href="text-level-semantics.html#the-time-element">time</a></code>要素の議論の節も参照のこと。</p>

  <h5 id="months"><span class="secno">2.4.5.1</span> 月</h5>

  <p><dfn data-anolis-xref="concept-month" id="concept-month">月</dfn>は、タイムゾーン情報および年と月を超えた日付を持たない、特定の<a href="#proleptic-gregorian-date">先発グレゴリオ暦</a>から成る。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は、年<var data-anolis-xref="">year</var>および月<var data-anolis-xref="">month</var>で表される<dfn id="valid-month-string">妥当な月文字列</dfn>である：</p>

  <ol>
    <li>4<a href="#ascii-digits">桁</a>以上で表される<var data-anolis-xref="">year</var>。ここで<var data-anolis-xref="">year</var>&nbsp;&gt;&nbsp;0である。
    </li>

    <li>"-"（U+002D）文字</li>

    <li>1&nbsp;≤&nbsp;<var data-anolis-xref="">month</var>&nbsp;≤&nbsp;12の範囲で、月<var data-anolis-xref="">month</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>
    </li>
  </ol>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-month-string">parse a month string</dfn> are as follows. This will return either a year and month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-month-component">Parse a month component</a> to obtain <var data-anolis-xref="">year</var> and <var data-anolis-xref="">month</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">year</var> and <var data-anolis-xref="">month</var>.</p>
      </li>
    </ol>

    <p>The rules to <dfn id="parse-a-month-component">parse a month component</dfn>, given an <var data-anolis-xref="">input</var> string and a <var data-anolis-xref="">position</var>, are as follows. This will return either a year and a month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not at least four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">year</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">year</var> is not a number greater than zero, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">month</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">month</var> is not a number in the range 1&nbsp;≤&nbsp;<var data-anolis-xref="">month</var>&nbsp;≤&nbsp;12, then fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">year</var> and <var data-anolis-xref="">month</var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="dates"><span class="secno">2.4.5.2</span> 日付</h5>

  <p><dfn data-anolis-xref="concept-date" id="concept-date">日付</dfn>は、年月日からなりタイムゾーン情報を持たない、特定の<a href="#proleptic-gregorian-date">先発グレゴリオ暦</a>からなる。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は年<var data-anolis-xref="">year</var>、月<var data-anolis-xref="">month</var>、日<var data-anolis-xref="">day</var>で表される<dfn id="valid-date-string">妥当な日付文字列</dfn>である：</p>

  <ol>
    <li>
      <var data-anolis-xref="">year</var>および<var data-anolis-xref="">month</var>で表される、<a href="#valid-month-string">妥当な月文字列</a>
    </li>

    <li>"-"（U+002D）文字</li>

    <li>1&nbsp;≤&nbsp;<var data-anolis-xref="">day</var>&nbsp;≤&nbsp;<var data-anolis-xref="">maxday</var>の範囲での<var data-anolis-xref="">day</var>で表される2つの<a href="#ascii-digits">ASCII数字</a>。ここで<var data-anolis-xref="">maxday</var>は<a data-anolis-xref="number of days in month month of year year" href="#number-of-days-in-month-month-of-year-year">年<var data-anolis-xref="">year</var>および月<var data-anolis-xref="">month</var>での日の数</a>である。
    </li>
  </ol>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-date-string">parse a date string</dfn> are as follows. This will return either a date, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-date-component">Parse a date component</a> to obtain <var data-anolis-xref="">year</var>, <var data-anolis-xref="">month</var>, and <var data-anolis-xref="">day</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">date</var> be the date with year <var data-anolis-xref="">year</var>, month <var data-anolis-xref="">month</var>, and day <var data-anolis-xref="">day</var>.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">date</var>.</p>
      </li>
    </ol>

    <p>The rules to <dfn id="parse-a-date-component">parse a date component</dfn>, given an <var data-anolis-xref="">input</var> string and a <var data-anolis-xref="">position</var>, are as follows. This will return either a year, a month, and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p><a href="#parse-a-month-component">Parse a month component</a> to obtain <var data-anolis-xref="">year</var> and <var data-anolis-xref="">month</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">maxday</var> be the <a href="#number-of-days-in-month-month-of-year-year">number of days in month <var data-anolis-xref="">month</var> of year <var data-anolis-xref="">year</var></a>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">day</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">day</var> is not a number in the range 1&nbsp;≤&nbsp;<var data-anolis-xref="">day</var>&nbsp;≤&nbsp;<var data-anolis-xref="">maxday</var>, then fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">year</var>, <var data-anolis-xref="">month</var>, and <var data-anolis-xref="">day</var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="yearless-dates"><span class="secno">2.4.5.3</span> 年なし日付</h5>

  <p><dfn data-anolis-xref="concept-yearless-date" id="concept-yearless-date">年なし日付</dfn>はグレコリオ月とその月の日からなるが、年を伴わない。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は月<var data-anolis-xref="">month</var>および日<var data-anolis-xref="">day</var>で表される<dfn id="valid-yearless-date-string">妥当な年なし日付文字列</dfn>である：</p>

  <ol>
    <li>任意で、2つの"-"（U+002D）文字</li>

    <li>1&nbsp;≤&nbsp;<var data-anolis-xref="">month</var>&nbsp;≤&nbsp;12の範囲で、月<var data-anolis-xref="">month</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>
    </li>

    <li>"-"（U+002D）文字</li>

    <li>1&nbsp;≤&nbsp;<var data-anolis-xref="">day</var>&nbsp;≤&nbsp;<var data-anolis-xref="">maxday</var>の範囲での<var data-anolis-xref="">day</var>で表される2つの<a href="#ascii-digits">ASCII数字</a>。ここで<var data-anolis-xref="">maxday</var>は月<var data-anolis-xref="">month</var>かつ任意の閏年（たとえば4または2000）における<a data-anolis-xref="number of days in month month of year year" href="#number-of-days-in-month-month-of-year-year">日数</a>である。
    </li>
  </ol>

  <p class="note">言い換えると、2月を意味する<var data-anolis-xref="">month</var>が"<code data-anolis-xref="">02</code>"である場合、あたかもその年は閏年かのように、日は29であってもよい。</p>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-yearless-date-string">parse a yearless date string</dfn> are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-yearless-date-component">Parse a yearless date component</a> to obtain <var data-anolis-xref="">month</var> and <var data-anolis-xref="">day</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">month</var> and <var data-anolis-xref="">day</var>.</p>
      </li>
    </ol>

    <p>The rules to <dfn id="parse-a-yearless-date-component">parse a yearless date component</dfn>, given an <var data-anolis-xref="">input</var> string and a <var data-anolis-xref="">position</var>, are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are "-" (U+002D) characters. If the collected sequence is not exactly zero or two characters long, then fail.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">month</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">month</var> is not a number in the range 1&nbsp;≤&nbsp;<var data-anolis-xref="">month</var>&nbsp;≤&nbsp;12, then fail.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">maxday</var> be the <a data-anolis-xref="number of days in month month of year year" href="#number-of-days-in-month-month-of-year-year">number of days</a> in month <var data-anolis-xref="">month</var> of any arbitrary leap year (e.g. 4 or 2000).</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">day</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">day</var> is not a number in the range 1&nbsp;≤&nbsp;<var data-anolis-xref="">day</var>&nbsp;≤&nbsp;<var data-anolis-xref="">maxday</var>, then fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">month</var> and <var data-anolis-xref="">day</var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="times"><span class="secno">2.4.5.4</span> 時刻</h5>

  <p><dfn data-anolis-xref="concept-time" id="concept-time">時刻</dfn>は、時、分、秒、秒以下からなりタイムゾーン情報を持たない、特定の時刻からなる。</p>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は、時<var data-anolis-xref="">hour</var>、分<var data-anolis-xref="">minute</var>、秒<var data-anolis-xref="">second</var>で表される<dfn id="valid-time-string">妥当な時刻文字列</dfn>である：</p>

  <ol>
    <li>0&nbsp;≤&nbsp;<var data-anolis-xref="">hour</var>&nbsp;≤&nbsp;23の範囲で、<var data-anolis-xref="">hour</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>
    </li>

    <li>":"（U+003A）文字</li>

    <li>0&nbsp;≤&nbsp;<var data-anolis-xref="">minute</var>&nbsp;≤&nbsp;59の範囲で<var data-anolis-xref="">minute</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>
    </li>

    <li>任意で（<var data-anolis-xref="">second</var>が非ゼロの場合必要）：

      <ol>
        <li>":"（U+003A）文字</li>

        <li>0&nbsp;≤&nbsp;<var data-anolis-xref="">s</var>&nbsp;≤&nbsp;59の範囲で、<var data-anolis-xref="">second</var>整数部を表す2つの<a href="#ascii-digits">ASCII数字</a>
        </li>

        <li>任意で（<var data-anolis-xref="">second</var>が整数でない場合必要）：

          <ol>
            <li>U+002E FULL STOP文字（.）</li>

            <li>
              <var data-anolis-xref="">second</var>分数部で表される、1、2、また3<a href="#ascii-digits">桁</a>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <p class="note"><var data-anolis-xref="">second</var>コンポーネントは60または61にはなり得ない。閏秒を表すことはできない。</p>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-time-string">parse a time string</dfn> are as follows. This will return either a time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-time-component">Parse a time component</a> to obtain <var data-anolis-xref="">hour</var>, <var data-anolis-xref="">minute</var>, and <var data-anolis-xref="">second</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">time</var> be the time with hour <var data-anolis-xref="">hour</var>, minute <var data-anolis-xref="">minute</var>, and second <var data-anolis-xref="">second</var>.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">time</var>.</p>
      </li>
    </ol>

    <p>The rules to <dfn id="parse-a-time-component">parse a time component</dfn>, given an <var data-anolis-xref="">input</var> string and a <var data-anolis-xref="">position</var>, are as follows. This will return either an hour, a minute, and a second, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">hour</var>.</p>
      </li>

      <li>If <var data-anolis-xref="">hour</var> is not a number in the range 0&nbsp;≤&nbsp;<var data-anolis-xref="">hour</var>&nbsp;≤&nbsp;23, then fail.</li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a U+003A COLON character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">minute</var>.</p>
      </li>

      <li>If <var data-anolis-xref="">minute</var> is not a number in the range 0&nbsp;≤&nbsp;<var data-anolis-xref="">minute</var>&nbsp;≤&nbsp;59, then fail.</li>

      <li>
        <p>Let <var data-anolis-xref="">second</var> be a string with the value "0".</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is not beyond the end of <var data-anolis-xref="">input</var> and the character at <var data-anolis-xref="">position</var> is a U+003A COLON, then run these substeps:</p>

        <ol>
          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var>, or at the last character in <var data-anolis-xref="">input</var>, or if the next <em>two</em> characters in <var data-anolis-xref="">input</var> starting at <var data-anolis-xref="">position</var> are not both <a href="#ascii-digits">ASCII digits</a>, then fail.</p>
          </li>

          <li>
            <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are either <a href="#ascii-digits">ASCII digits</a> or U+002E FULL STOP characters. If the collected sequence is three characters long, or if it is longer than three characters long and the third character is not a U+002E FULL STOP character, or if it has more than one U+002E FULL STOP character, then fail. Otherwise, let the collected string be <var data-anolis-xref="">second</var> instead of its previous value.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>Interpret <var data-anolis-xref="">second</var> as a base-ten number (possibly with a fractional part). Let <var data-anolis-xref="">second</var> be that number instead of the string version.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">second</var> is not a number in the range 0&nbsp;≤&nbsp;<var data-anolis-xref="">second</var>&nbsp;&lt;&nbsp;60, then fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">hour</var>, <var data-anolis-xref="">minute</var>, and <var data-anolis-xref="">second</var>.</p>
      </li>
    </ol>
  </div><!--START FORK rename local->floating-->

  <h5 id="floating-dates-and-times"><span class="secno">2.4.5.5</span> 浮動日付および時刻</h5>

  <p><dfn data-anolis-xref="concept-datetime-floating" id="concept-datetime-floating">浮動日付および時刻</dfn>は、年、月、日、時、分、秒、秒以下からなる特定の<a href="#proleptic-gregorian-date">先発グレコリオ暦</a>からなるが、タイムゾーン情報を持たない。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は<dfn id="valid-floating-date-and-time-string">妥当な浮動日付および時刻文字列</dfn>である：</p>

  <ol>
    <li>日付を表す<a href="#valid-date-string">妥当な日付文字列</a>
    </li>

    <li>"T"（U+0054）文字またはU+0020 SPACE文字</li>

    <li>時刻を表す<a href="#valid-time-string">妥当な時刻文字列</a>
    </li>
  </ol>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は<dfn id="valid-normalized-floating-date-and-time-string">妥当な規格化浮動日付および時刻文字列</dfn>である：</p>

  <ol>
    <li>日付を表す<a href="#valid-date-string">妥当な日付文字列</a>
    </li>

    <li>"T"（U+0054）文字</li>

    <li>時刻を表す<a href="#valid-time-string">妥当な時間文字列</a>は、与えられた時刻に対して可能な限り最短の文字列として表現される（たとえば、与えられた時刻がゼロ秒分を過ぎている場合、完全に秒のコンポーネントを省略する）
    </li>
  </ol>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-floating-date-and-time-string">parse a floating date and time string</dfn> are as follows. This will return either a date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-date-component">Parse a date component</a> to obtain <var data-anolis-xref="">year</var>, <var data-anolis-xref="">month</var>, and <var data-anolis-xref="">day</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#parse-a-time-component">Parse a time component</a> to obtain <var data-anolis-xref="">hour</var>, <var data-anolis-xref="">minute</var>, and <var data-anolis-xref="">second</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">date</var> be the date with year <var data-anolis-xref="">year</var>, month <var data-anolis-xref="">month</var>, and day <var data-anolis-xref="">day</var>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">time</var> be the time with hour <var data-anolis-xref="">hour</var>, minute <var data-anolis-xref="">minute</var>, and second <var data-anolis-xref="">second</var>.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">date</var> and <var data-anolis-xref="">time</var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="time-zones"><span class="secno">2.4.5.6</span> タイムゾーン</h5>

  <p><dfn data-anolis-xref="concept-timezone" id="concept-timezone">タイムゾーンオフセット</dfn>は符号付きの時と分の数字からなる。</p>

  <p>次のいずれかからなる場合、文字列は、タイムゾーンオフセットを表す<dfn id="valid-time-zone-offset-string">妥当なタイムゾーンオフセット文字列</dfn>である：</p>

  <ul>
    <li>
      <p>タイムゾーンがUTCの場合のみ許される、"Z"（U+005A）文字</p>
    </li>

    <li>
      <p>または、与えられた順で以下のコンポーネント：</p>

      <ol>
        <li>タイムゾーンオフセットがゼロでない場合、タイムゾーンオフセットの符号を表す、"+"（U+002B）文字または"-"（U+002D）文字のいずれか</li><!-- the -00:00 offset is disallowed because RFC3339 gives it a special semantic -->

        <li>0&nbsp;≤&nbsp;<var data-anolis-xref="">hour</var>&nbsp;≤&nbsp;23の範囲で、タイムゾーンオフセットの時コンポーネント<var data-anolis-xref="">hour</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>
        </li>

        <li>任意で、":"（U+003A）文字</li>

        <li>0&nbsp;≤&nbsp;<var data-anolis-xref="">minute</var>&nbsp;≤&nbsp;59の範囲で、タイムゾーンオフセットの分コンポーネント<var data-anolis-xref="">minute</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>
        </li>
      </ol>
    </li>
  </ul>

  <p class="note">この形式は、-23:59から+23:59までのタイムゾーンオフセットを許可する。しかし、特に、実際のタイムゾーンオフセットの範囲は-12:00から+14:00までであり、実際のタイムゾーンオフセットの分コンポーネントは常に00、30または45のいずれかである。とはいえ、永遠に保持される保証はない。タイムゾーンは国によって思いのままに変更され、標準に従わない。</p><!--FORK-->

  <p class="note">正式なタイムゾーンの形成以前に遡る歴史的な時代でのタイムゾーンのオフセットを使用についての詳細は、下記の<a data-anolis-xref="concept-datetime" href="#concept-datetime">グローバル日付および時刻</a>の節にある使用上の注意と例を参照のこと。</p>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-time-zone-offset-string">parse a time-zone offset string</dfn> are as follows. This will return either a time-zone offset, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-time-zone-offset-component">Parse a time-zone offset component</a> to obtain <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Return the time-zone offset that is <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> hours and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> minutes from UTC.</p>
      </li>
    </ol>

    <p>The rules to <dfn id="parse-a-time-zone-offset-component">parse a time-zone offset component</dfn>, given an <var data-anolis-xref="">input</var> string and a <var data-anolis-xref="">position</var>, are as follows. This will return either time-zone hours and time-zone minutes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>If the character at <var data-anolis-xref="">position</var> is a U+005A LATIN CAPITAL LETTER Z character (Z), then:</p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> be 0.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> be 0.</p>
          </li>

          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>.</p>
          </li>
        </ol>

        <p>Otherwise, if the character at <var data-anolis-xref="">position</var> is either a "+" (U+002B) or a "-" (U+002D), then:</p>

        <ol>
          <li>
            <p>If the character at <var data-anolis-xref="">position</var> is a "+" (U+002B), let <var data-anolis-xref="">sign</var> be "positive". Otherwise, it's a "-" (U+002D); let <var data-anolis-xref="">sign</var> be "negative".</p>
          </li>

          <li>
            <p>Advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>.</p>
          </li>

          <li>
            <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. Let <var data-anolis-xref="">s</var> be the collected sequence.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">s</var> is exactly two characters long, then run these substeps:</p>

            <ol>
              <li>
                <p>Interpret <var data-anolis-xref="">s</var> as a base-ten integer. Let that number be the <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var>.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a U+003A COLON character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
              </li>

              <li>
                <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>.</p>
              </li>
            </ol>

            <p>If <var data-anolis-xref="">s</var> is exactly four characters long, then run these substeps:</p>

            <ol>
              <li>
                <p>Interpret the first two characters of <var data-anolis-xref="">s</var> as a base-ten integer. Let that number be the <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var>.</p>
              </li>

              <li>
                <p>Interpret the last two characters of <var data-anolis-xref="">s</var> as a base-ten integer. Let that number be the <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>.</p>
              </li>
            </ol>

            <p>Otherwise, fail.</p>
          </li>

          <li>If <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> is not a number in the range 0&nbsp;≤&nbsp;<var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var>&nbsp;≤&nbsp;23, then fail.</li>

          <li>If <var data-anolis-xref="">sign</var> is "negative", then negate <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var>.</li>

          <li>If <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> is not a number in the range 0&nbsp;≤&nbsp;<var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>&nbsp;≤&nbsp;59, then fail.</li>

          <li>If <var data-anolis-xref="">sign</var> is "negative", then negate <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>.</li>
        </ol>

        <p>Otherwise, fail.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="global-dates-and-times"><span class="secno">2.4.5.7</span> グローバル日付および時刻</h5>

  <p><dfn data-anolis-xref="concept-datetime" id="concept-datetime">グローバル日付および時刻</dfn>は、符号付き時分からなるタイムゾーンオフセットとともに年、月、日、時、分、秒、秒以下からなる特定<a href="#proleptic-gregorian-date">先発グレコリオ暦</a>で構成する。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p>与えられた順で以下のコンポーネントからなる場合、日付、時刻、タイムゾーンオフセットを表す文字列は<dfn id="valid-global-date-and-time-string">妥当なグローバル日付および時刻</dfn>である：</p>

  <ol>
    <li>日付を表す<a href="#valid-date-string">妥当な日付文字列</a>
    </li>

    <li>"T"（U+0054）文字またはU+0020 SPACE文字</li>

    <li>時刻を表す<a href="#valid-time-string">妥当な時刻文字列</a>
    </li>

    <li>タイムゾーンオフセットを表す<a href="#valid-time-zone-offset-string">妥当なタイムゾーンオフセット文字列</a>
    </li>
  </ol>

  <p>20世紀半ばにUTCを形成する前の日付の時刻は、UTC（UT1の近似がSI秒を刻む）ではなく、UT1（0°経度での現代の地球太陽時）の見地から表現および解釈されなければならない。タイムゾーンを形成する前の時刻は、適切なローカル時刻とロンドンのグリニッジで観測された時間との間のおおよその現代的な違いのある明示的なタイムゾーンとともにUT1の時間として表現および解釈されなければならない。</p>

  <div class="example">
    <p>以下は<a data-anolis-xref="valid global date and time string" href="#valid-global-date-and-time-string">妥当なグローバル日付および時刻</a>として記述される例の一部である。</p>

    <dl>
      <dt>"<code>0037-12-13 00:00Z</code>"</dt>

      <dd>ネロ（ローマ皇帝）の誕生日にロンドン時間を用いた地域での真夜中。これが実際に対応している日付のさらなる議論については下記を参照のこと。</dd>

      <dt>"<code>1979-10-14T12:00:00.001-04:00</code>"</dt>

      <dd>夏時間の間にアメリカ東海岸で使用されるタイムゾーンで、1979年10月14日の正午1ミリ秒後。</dd>

      <dt>"<code>8592-01-01T02:09+02:09</code>"</dt>

      <dd>8592年1月1日のUTCで夜中。現在の実際のタイムゾーンではない、UTCより早く時刻が2時9分であるタイムゾーンに関連づけられるが、それでもなお、許可される。</dd>
    </dl>

    <p>数点の以下の日付に関して顕著である：</p>

    <ul>
      <li>4桁未満の年はゼロで埋める必要がある。日付"37-12-13"は妥当な日付ではない。</li>

      <li>"<code data-anolis-xref="">T</code>"が空白に置換される場合、単一の空白文字でなければならない。文字列"<code data-anolis-xref="">2001-12-21&nbsp;&nbsp;12:00Z</code>"（コンポーネントの間に2つの空白）はうまく解釈されないだろう。</li>

      <li>グレゴリオ暦（UTC成立より前の時間における瞬間の範囲で、一義的に識別されうる）の導入より前の特定の時点を一義的に識別するためには、日付は最初にその時代に使用される暦（たとえばユリウス暦）からグレゴリオ暦に変換する必要がある。ネロの誕生日は、ユリウス暦で12月37月15日であり、<a href="#proleptic-gregorian-calendar">先発グレゴリオ暦</a>で12月37月13日である。
      </li><!-- This might not be true. I can't find a reference that gives
    his birthday with an explicit statement about the calendar being used. However, it seems
    unlikely that it would be given in the Gregorian calendar, so I assume sites use the Julian one.
    -->

      <li>時刻とタイムゾーンオフセットのコンポーネントは任意ではない。</li>

      <li>西暦元年より前の日付は、HTMLのこのバージョンで日付時刻として表すことはできない。</li>

      <li>時刻は比較的最近の数十年までよく調整または測定されなかったので、古代において特定の出来事の時刻は、せいぜい近似値である。</li>

      <li>タイムゾーンオフセットは夏時間に基づいて異なる。</li>
    </ul>
  </div>

  <p class="note">ゾーンオフセットは、完全なタイムゾーンの仕様ではない。現実の日付と時刻の値を操作する場合、できればIANAのタイムゾーンIDを使用して、タイムゾーンごとに個別のフィールドの使用を検討すること。<a href="references.html#refsTIMEZONES">[TIMEZONES]</a></p>

  <p>与えられた順で以下のコンポーネントから構成される場合、日付、時刻、タイムゾーンオフセットを表す文字列は<dfn id="valid-normalized-forced-utc-global-date-and-time-string">妥当なUTCに正規化されたグローバル日付および時刻</dfn>である：</p>

  <ol>
    <li>UTCタイムゾーンに変換された日付を表す<a href="#valid-date-string">妥当な日付文字列</a>
    </li>

    <li>"T"（U+0054）文字</li>

    <li>UTCタイムゾーンに変換されるおよび与えられた時刻に対して可能な限り最短として表現される時刻（たとえば、与えられた時刻が時間を過ぎたゼロ秒である場合、完全に秒のコンポーネントを省略する）を表す<a href="#valid-time-string">妥当な時刻文字列</a>
    </li>

    <li>"Z"（U+005A）文字</li>
  </ol>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-global-date-and-time-string">parse a global date and time string</dfn> are as follows. This will return either a time in UTC, with associated time-zone offset information for round-tripping or display purposes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#parse-a-date-component">Parse a date component</a> to obtain <var data-anolis-xref="">year</var>, <var data-anolis-xref="">month</var>, and <var data-anolis-xref="">day</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#parse-a-time-component">Parse a time component</a> to obtain <var data-anolis-xref="">hour</var>, <var data-anolis-xref="">minute</var>, and <var data-anolis-xref="">second</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p><a href="#parse-a-time-zone-offset-component">Parse a time-zone offset component</a> to obtain <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">time</var> be the moment in time at year <var data-anolis-xref="">year</var>, month <var data-anolis-xref="">month</var>, day <var data-anolis-xref="">day</var>, hours <var data-anolis-xref="">hour</var>, minute <var data-anolis-xref="">minute</var>, second <var data-anolis-xref="">second</var>, subtracting <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> hours and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> minutes. That moment in time is a moment in the UTC time zone.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">timezone</var> be <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> hours and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> minutes from UTC.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">time</var> and <var data-anolis-xref="">timezone</var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="weeks"><span class="secno">2.4.5.8</span> 週</h5>

  <p><dfn data-anolis-xref="concept-week" id="concept-week">週</dfn>は、週番号年と週番号からなる。週番号は、月曜日から始まる7日間を示す。以下の定義に従って、このカレンダーシステムにおける週番号年は52または53の7日間を持つ。グレゴリオ暦の日付で1969年12月29日（1969-12-29）月曜日で始まる7日間は、1970週番号年で週番号1として定義される。連続した週は連番が付けられる。週番号年で1週目の前の週は、前の週番号年の最終週である。逆もまた同様である。<a href="references.html#refsGREGORIAN">[GREGORIAN]</a></p>

  <p>最初の日（1月1日）が木曜である<a href="#proleptic-gregorian-calendar">先発グレコリオ暦</a>の年<var data-anolis-xref="">year</var>、または最初の日（1月1日）が木曜である<a href="#proleptic-gregorian-calendar">先発グレコリオ暦</a>の年<var data-anolis-xref="">year</var>のいずれかに対応する場合、数字<var data-anolis-xref="">year</var>とともに週番号年は53週を持つ。ここで、<var data-anolis-xref="">year</var>は400で割り切れる数字、または4で割り切れるが100で割り切れない数字である。他のすべての週番号年は52週である。</p>

  <p>53週をもつ週番号年の<dfn id="week-number-of-the-last-day">最終日の週番号</dfn>は53であり、52週をもつ週番号年の最終日の週番号は52である。</p>

  <p class="note">特定の日の週番号年の数は、<a href="#proleptic-gregorian-calendar">先発グレゴリオ暦</a>で、その日を含む年の数と異なる場合がある。週番号年<var data-anolis-xref="">y</var>での最初の週は、グレコリオ年<var data-anolis-xref="">y</var>の最初の木曜を含む週である。</p>

  <p class="note">現代の用途に対して、ここで定義される<a data-anolis-xref="concept-week" href="#concept-week">週</a>は、ISO 8601で定義されるようなISO週に相当する。<a href="references.html#refsISO8601">[ISO8601]</a></p>

  <p>与えられた順で以下のコンポーネントからなる場合、文字列は、週番号年<var data-anolis-xref="">year</var>および週<var data-anolis-xref="">week</var>を表す<dfn id="valid-week-string">妥当な週文字列</dfn>である：</p>

  <ol>
    <li>4<a href="#ascii-digits">桁</a>以上で表される<var data-anolis-xref="">year</var>。ここで<var data-anolis-xref="">year</var>&nbsp;&gt;&nbsp;0である。
    </li>

    <li>"-"（U+002D）文字</li>

    <li>"W"（U+0057）文字</li>

    <li>1&nbsp;≤&nbsp;<var data-anolis-xref="">week</var>&nbsp;≤&nbsp;<var data-anolis-xref="">maxweek</var>の範囲で、週<var data-anolis-xref="">week</var>を表す2つの<a href="#ascii-digits">ASCII数字</a>。ここで <var data-anolis-xref="">maxweek</var>は週番号年<var data-anolis-xref="">year</var>の<a href="#week-number-of-the-last-day">最終日の週番号</a>である。
    </li>
  </ol>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-week-string">parse a week string</dfn> are as follows. This will return either a week-year number and week number, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not at least four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">year</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">year</var> is not a number greater than zero, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or if the character at <var data-anolis-xref="">position</var> is not a "W" (U+0057) character, then fail. Otherwise, move <var data-anolis-xref="">position</var> forwards one character.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the <var data-anolis-xref="">week</var>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">maxweek</var> be the <a href="#week-number-of-the-last-day">week number of the last day</a> of year <var data-anolis-xref="">year</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">week</var> is not a number in the range 1&nbsp;≤&nbsp;<var data-anolis-xref="">week</var>&nbsp;≤&nbsp;<var data-anolis-xref="">maxweek</var>, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>Return the week-year number <var data-anolis-xref="">year</var> and the week number <var data-anolis-xref="">week</var>.</p>
      </li>
    </ol>
  </div>

  <h5 id="durations"><span class="secno">2.4.5.9</span> 継続時間</h5><!-- if you add support for year and month durations, then search for MONTHS throughout the spec
  (not just this section) for things that have to change -->

  <p><dfn data-anolis-xref="concept-duration" id="concept-duration">継続時間</dfn>は <!--MONTHS: either a number of
  months or--> 複数秒からなる。</p>

  <p class="note">月と秒は同等ではない（1か月は正確な秒数ではなく、その正確な長さは、測定された正確な1日に依存する期間である）ので、この仕様で定義される<a data-anolis-xref="concept-duration" href="#concept-duration">継続時間</a>は月を含めることはできない <!--MONTHS: consist of a mixture of both--> （すなわち年は12ヶ月と等価である）。特定の秒数を記述する継続時間のみが記述可能である。</p>

  <p>以下のいずれかからなる場合、文字列は、<a data-anolis-xref="concept-duration" href="#concept-duration">継続時間</a><var data-anolis-xref="">t</var>で表す<dfn id="valid-duration-string">妥当な継続時間文字列</dfn>である：</p>

  <ul>
    <li>
      <!-- The ISO format --><!-- NOTE: ISO durations also have a number of formats we do not
         consider conforming:

         - a "week" format (e.g. P4W). This one is actually supported
           by the parser.

         - P<date>T<time>, with or without hyphens

         - All these formats, with commas instead of periods for the
           seconds decimal

    -->

      <p>与えられた順でリテラルにU+0050 LATIN CAPITAL LETTER P文字の後に以下のサブコンポーネントが続く。 <!--the number of years, if any, multiplied by twelve,
    plus the number of months, if any, equals the number of months in <var data-x="">t</var>, if the
    duration is in months; or, if it is in seconds, -->ここで日、時、分および秒数は<var data-anolis-xref="">t</var>として同じ秒数に対応する：</p>

      <ol>
        <!--MONTHS:
     <li><p>One or more <span>ASCII digits</span> followed by a U+0059 LATIN CAPITAL LETTER Y
     character, representing a number of years.</p></li>

     <li><p>One or more <span>ASCII digits</span> followed by a U+004D LATIN CAPITAL LETTER M
     character, representing a number of months.</p></li>
-->

        <li>
          <p>U+0044 LATIN CAPITAL LETTER D文字の後に続く、日数を表す1つ以上の<a href="#ascii-digits">ASCII数字</a>。</p>
        </li>

        <li>
          <p>与えられた順で、U+0054 LATIN CAPITAL LETTER T文字の後に以下のサブコンポーネントが続く：</p>

          <ol>
            <li>
              <p>U+0048 LATIN CAPITAL LETTER H文字の後に続く、時数を表す1つ以上の<a href="#ascii-digits">ASCII数字</a>。</p>
            </li>

            <li>
              <p>U+0044 LATIN CAPITAL LETTER M文字の後に続く、分数を表す1つ以上の<a href="#ascii-digits">ASCII数字</a>。</p>
            </li>

            <li>
              <p>以下のコンポーネント：</p>

              <ol>
                <li>
                  <p>秒数を表す、1つ以上の<a href="#ascii-digits">ASCII数字</a>。</p>
                </li>

                <li>
                  <p>任意で、秒以下を表す"."（U+002E）文字の後に続く1、2、または3つの<a href="#ascii-digits">ASCII数字</a>。</p>
                </li>

                <li>
                  <p>U+0053 LATIN CAPITAL LETTER S文字。</p>
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>

      <p class="note">この、この仕様で定義される他の日付および時刻依存のマイクロ構文は、ISO 8601で定義される形式の1つに基づく。<a href="references.html#refsISO8601">[ISO8601]</a></p>
    </li>

    <li>
      <p>任意の順で、それぞれ異なる<a href="#duration-time-component-scale">継続時間時刻コンポーネントのスケール</a>を伴う、1つ以上の<a data-anolis-xref="duration time component" href="#duration-time-component">継続時間コンポーネント</a>。秒数<var data-anolis-xref="">t</var>と等価である秒数で表される合計。</p>

      <p><dfn id="duration-time-component">継続時間時刻コンポーネント</dfn>は以下のコンポーネントからなる文字列である：</p>

      <ol>
        <li>
          <p>0個以上の<a data-anolis-xref="space character" href="#space-character">空白文字</a>。</p>
        </li>

        <li>
          <p>秒数を表現するために指定された<a href="#duration-time-component-scale">継続時間時刻コンポーネントスケール</a>（下記参照）でスケールされる時刻単位数で表す、1つ以上の<a href="#ascii-digits">ASCII数字</a>。</p>
        </li>

        <li>
          <p>指定された<a href="#duration-time-component-scale">継続時間時刻コンポーネントスケール</a>が1（すなわち単位が秒）の場合、任意で、"."（U+002E）文字の後に続く秒以下を表す1、2、または3つの<a href="#ascii-digits">ASCII数字</a>。</p>
        </li>

        <li>
          <p>0個以上の<a data-anolis-xref="space character" href="#space-character">空白文字</a>。</p>
        </li>

        <li>
          <p><a href="#duration-time-component">継続時間時刻コンポーネント</a>の数字部で用いられる時刻単位の<dfn id="duration-time-component-scale">継続時間時刻コンポーネントスケール</dfn>を表す、以下の文字の1つ：</p>

          <dl>
            <dt>U+0057 LATIN CAPITAL LETTER W 文字</dt>

            <dt>U+0077 LATIN SMALL LETTER W 文字</dt>

            <dd>週スケールは604800である。</dd>

            <dt>U+0044 LATIN CAPITAL LETTER D 文字</dt>

            <dt>U+0064 LATIN SMALL LETTER D 文字</dt>

            <dd>日。スケールは86400である。</dd>

            <dt>U+0048 LATIN CAPITAL LETTER H 文字</dt>

            <dt>U+0068 LATIN SMALL LETTER H 文字</dt>

            <dd>時。スケールは3600である。</dd>

            <dt>U+004D LATIN CAPITAL LETTER M 文字</dt>

            <dt>U+006D LATIN SMALL LETTER M文字</dt>

            <dd>分。スケールは60である。</dd>

            <dt>U+0053 LATIN CAPITAL LETTER S文字</dt>

            <dt>U+0073 LATIN SMALL LETTER S文字</dt>

            <dd>秒。スケールは1である。</dd>
          </dl>
        </li>

        <li>
          <p>0個以上の<a data-anolis-xref="space character" href="#space-character">空白文字</a>。</p>
        </li>
      </ol>

      <p class="note">これはISO 8601での形式のいずれにも基づかない。ISO 8601継続時間形式の代わりに、より人間に読みやすくすることを意図する。</p>
    </li>
  </ul>

  <div class="impl">
    <p>The rules to <dfn id="parse-a-duration-string">parse a duration string</dfn> are as follows. This will return either a <a data-anolis-xref="concept-duration" href="#concept-duration">duration</a> or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <!--MONTHS: this algorithm actually already parses months adequately, though it would need
   tweaking if we introduced a "mo" unit for the non-ISO variant. See other "MONTHS" annotations
   below. -->

      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">months</var>, <var data-anolis-xref="">seconds</var>, and <var data-anolis-xref="">component count</var> all be zero.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">M-disambiguator</var> be <i>minutes</i>.</p><!--MONTHS: this note would change-->

        <p class="note">This flag's other value is <i>months</i>. It is used to disambiguate the "M" unit in ISO8601 durations, which use the same unit for months and minutes. Months are not allowed, but are parsed for future compatibility and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.</p>
      </li>

      <li>
        <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>If the character in <var data-anolis-xref="">input</var> pointed to by <var data-anolis-xref="">position</var> is a U+0050 LATIN CAPITAL LETTER P character, then advance <var data-anolis-xref="">position</var> to the next character, set <var data-anolis-xref="">M-disambiguator</var> to <i>months</i>, and <a href="#skip-whitespace">skip whitespace</a>.</p>
      </li>

      <li>
        <p>Run the following substeps in a loop, until a step requiring the loop to be broken or the entire algorithm to fail is reached:</p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">units</var> be undefined. It will be assigned one of the following values: <i>years</i>, <i>months</i>, <i>weeks</i>, <i>days</i>, <i>hours</i>, <i>minutes</i>, and <i>seconds</i>.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">next character</var> be undefined. It is used to process characters from the <var data-anolis-xref="">input</var>.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then break the loop.</p>
          </li>

          <li>
            <p>If the character in <var data-anolis-xref="">input</var> pointed to by <var data-anolis-xref="">position</var> is a U+0054 LATIN CAPITAL LETTER T character, then advance <var data-anolis-xref="">position</var> to the next character, set <var data-anolis-xref="">M-disambiguator</var> to <i>minutes</i>, <a href="#skip-whitespace">skip whitespace</a>, and return to the top of the loop.</p>
          </li>

          <li>
            <p>Set <var data-anolis-xref="">next character</var> to the character in <var data-anolis-xref="">input</var> pointed to by <var data-anolis-xref="">position</var>.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">next character</var> is a "." (U+002E) character, then let <var data-anolis-xref="">N</var> equal zero. (Do not advance <var data-anolis-xref="">position</var>. That is taken care of below.)</p>

            <p>Otherwise, if <var data-anolis-xref="">next character</var> is an <a data-anolis-xref="ASCII digits" href="#ascii-digits">ASCII digit</a>, then <a href="#collect-a-sequence-of-characters">collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>, interpret the resulting sequence as a base-ten integer, and let <var data-anolis-xref="">N</var> be that number.</p>

            <p>Otherwise <var data-anolis-xref="">next character</var> is not part of a number; fail.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then fail.</p>
          </li>

          <li>
            <p>Set <var data-anolis-xref="">next character</var> to the character in <var data-anolis-xref="">input</var> pointed to by <var data-anolis-xref="">position</var>, and this time advance <var data-anolis-xref="">position</var> to the next character. (If <var data-anolis-xref="">next character</var> was a U+002E FULL STOP character (.) before, it will still be that character this time.)</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">next character</var> is a "." (U+002E) character, then run these substeps:</p>

            <ol>
              <li>
                <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are <a href="#ascii-digits">ASCII digits</a>. Let <var data-anolis-xref="">s</var> be the resulting sequence.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">s</var> is the empty string, then fail.</p>
              </li>

              <li>
                <p>Let <var data-anolis-xref="">length</var> be the number of characters in <var data-anolis-xref="">s</var>.</p>
              </li>

              <li>
                <p>Let <var data-anolis-xref="">fraction</var> be the result of interpreting <var data-anolis-xref="">s</var> as a base-ten integer, and then dividing that number by <span data-anolis-xref="">10<sup data-anolis-xref=""><var data-anolis-xref="">length</var></sup></span>.</p>
              </li>

              <li>
                <p>Increment <var data-anolis-xref="">N</var> by <var data-anolis-xref="">fraction</var>.</p>
              </li>

              <li>
                <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, then fail.</p>
              </li>

              <li>
                <p>Set <var data-anolis-xref="">next character</var> to the character in <var data-anolis-xref="">input</var> pointed to by <var data-anolis-xref="">position</var>, and advance <var data-anolis-xref="">position</var> to the next character.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">next character</var> is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN SMALL LETTER S character, then fail.</p>
              </li>

              <li>
                <p>Set <var data-anolis-xref="">units</var> to <i>seconds</i>.</p>
              </li>
            </ol>

            <p>Otherwise, run these substeps:</p>

            <ol>
              <li>
                <p>If <var data-anolis-xref="">next character</var> is a <a href="#space-character">space character</a>, then <a href="#skip-whitespace">skip whitespace</a>, set <var data-anolis-xref="">next character</var> to the character in <var data-anolis-xref="">input</var> pointed to by <var data-anolis-xref="">position</var>, and advance <var data-anolis-xref="">position</var> to the next character.</p>
              </li>

              <li>
                <!--MONTHS: this would probably be where we would add more
        logic to support a new unit like 'mo' -->

                <p>If <var data-anolis-xref="">next character</var> is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL LETTER Y character, set <var data-anolis-xref="">units</var> to <i>years</i> and set <var data-anolis-xref="">M-disambiguator</var> to <i>months</i>.</p>

                <p>If <var data-anolis-xref="">next character</var> is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and <var data-anolis-xref="">M-disambiguator</var> is <i>months</i>, then set <var data-anolis-xref="">units</var> to <i>months</i>.</p>

                <p>If <var data-anolis-xref="">next character</var> is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL LETTER W character, set <var data-anolis-xref="">units</var> to <i>weeks</i> and set <var data-anolis-xref="">M-disambiguator</var> to <i>minutes</i>.</p>

                <p>If <var data-anolis-xref="">next character</var> is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL LETTER D character, set <var data-anolis-xref="">units</var> to <i>days</i> and set <var data-anolis-xref="">M-disambiguator</var> to <i>minutes</i>.</p>

                <p>If <var data-anolis-xref="">next character</var> is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL LETTER H character, set <var data-anolis-xref="">units</var> to <i>hours</i> and set <var data-anolis-xref="">M-disambiguator</var> to <i>minutes</i>.</p>

                <p>If <var data-anolis-xref="">next character</var> is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and <var data-anolis-xref="">M-disambiguator</var> is <i>minutes</i>, then set <var data-anolis-xref="">units</var> to <i>minutes</i>.</p>

                <p>If <var data-anolis-xref="">next character</var> is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL LETTER S character, set <var data-anolis-xref="">units</var> to <i>seconds</i> and set <var data-anolis-xref="">M-disambiguator</var> to <i>minutes</i>.</p>

                <p>Otherwise if <var data-anolis-xref="">next character</var> is none of the above characters, then fail.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>Increment <var data-anolis-xref="">component count</var>.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">multiplier</var> be 1.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">units</var> is <i>years</i>, multiply <var data-anolis-xref="">multiplier</var> by 12 and set <var data-anolis-xref="">units</var> to <i>months</i>.</p>
          </li>

          <li>
            <p>If <var data-anolis-xref="">units</var> is <i>months</i>, add the product of <var data-anolis-xref="">N</var> and <var data-anolis-xref="">multiplier</var> to <var data-anolis-xref="">months</var>.</p>

            <p>Otherwise, run these substeps:</p>

            <ol>
              <li>
                <p>If <var data-anolis-xref="">units</var> is <i>weeks</i>, multiply <var data-anolis-xref="">multiplier</var> by 7 and set <var data-anolis-xref="">units</var> to <i>days</i>.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">units</var> is <i>days</i>, multiply <var data-anolis-xref="">multiplier</var> by 24 and set <var data-anolis-xref="">units</var> to <i>hours</i>.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">units</var> is <i>hours</i>, multiply <var data-anolis-xref="">multiplier</var> by 60 and set <var data-anolis-xref="">units</var> to <i>minutes</i>.</p>
              </li>

              <li>
                <p>If <var data-anolis-xref="">units</var> is <i>minutes</i>, multiply <var data-anolis-xref="">multiplier</var> by 60 and set <var data-anolis-xref="">units</var> to <i>seconds</i>.</p>
              </li>

              <li>
                <p>Forcibly, <var data-anolis-xref="">units</var> is now <i>seconds</i>. Add the product of <var data-anolis-xref="">N</var> and <var data-anolis-xref="">multiplier</var> to <var data-anolis-xref="">seconds</var>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p><a href="#skip-whitespace">Skip whitespace</a>.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>If <var data-anolis-xref="">component count</var> is zero, fail.</p>
      </li><!--MONTHS: if we add month support this is where you'd return them-->

      <li>
        <p>If <var data-anolis-xref="">months</var> is not zero, fail.</p>
      </li>

      <li>
        <p>Return the <a data-anolis-xref="concept-duration" href="#concept-duration">duration</a> consisting of <var data-anolis-xref="">seconds</var> seconds.</p>
      </li>
    </ol>
  </div>

  <h5 id="vaguer-moments-in-time"><span class="secno">2.4.5.10</span> 時刻における曖昧な瞬間</h5>

  <p>以下のいずれかである場合、文字列は<dfn id="valid-date-string-with-optional-time">任意の時刻を持つ妥当な日付文字列</dfn>である：</p>

  <ul>
    <li>
      <a href="#valid-date-string">妥当な日付文字列</a>
    </li>

    <li>
      <a href="#valid-global-date-and-time-string">妥当なグローバル日付および時刻文字列</a>
    </li>
  </ul>

  <div class="impl">
    <hr>

    <p>The rules to <dfn id="parse-a-date-or-time-string">parse a date or time string</dfn> are as follows. The algorithm will return either a <a data-anolis-xref="concept-date" href="#concept-date">date</a>, a <a data-anolis-xref="concept-time" href="#concept-time">time</a>, a <a data-anolis-xref="concept-datetime" href="#concept-datetime">global date and time</a>, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Set <var data-anolis-xref="">start position</var> to the same position as <var data-anolis-xref="">position</var>.</p>
      </li>

      <li>
        <p>Set the <var data-anolis-xref="">date present</var> and <var data-anolis-xref="">time present</var> flags to true.</p>
      </li>

      <li>
        <p><a href="#parse-a-date-component">Parse a date component</a> to obtain <var data-anolis-xref="">year</var>, <var data-anolis-xref="">month</var>, and <var data-anolis-xref="">day</var>. If this fails, then set the <var data-anolis-xref="">date present</var> flag to false.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">date present</var> is true, and <var data-anolis-xref="">position</var> is not beyond the end of <var data-anolis-xref="">input</var>, and the character at <var data-anolis-xref="">position</var> is either a "T" (U+0054) character or a U+0020 SPACE character, then advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>.</p>

        <p>Otherwise, if <var data-anolis-xref="">date present</var> is true, and either <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var> or the character at <var data-anolis-xref="">position</var> is neither a "T" (U+0054) character nor a U+0020 SPACE character, then set <var data-anolis-xref="">time present</var> to false.</p>

        <p>Otherwise, if <var data-anolis-xref="">date present</var> is false, set <var data-anolis-xref="">position</var> back to the same position as <var data-anolis-xref="">start position</var>.</p>
      </li>

      <li>
        <p>If the <var data-anolis-xref="">time present</var> flag is true, then <a href="#parse-a-time-component">parse a time component</a> to obtain <var data-anolis-xref="">hour</var>, <var data-anolis-xref="">minute</var>, and <var data-anolis-xref="">second</var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If the <var data-anolis-xref="">date present</var> and <var data-anolis-xref="">time present</var> flags are both true, but <var data-anolis-xref="">position</var> is beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>If the <var data-anolis-xref="">date present</var> and <var data-anolis-xref="">time present</var> flags are both true, <a href="#parse-a-time-zone-offset-component">parse a time-zone offset component</a> to obtain <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var>. If this returns nothing, then fail.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is <em>not</em> beyond the end of <var data-anolis-xref="">input</var>, then fail.</p>
      </li>

      <li>
        <p>If the <var data-anolis-xref="">date present</var> flag is true and the <var data-anolis-xref="">time present</var> flag is false, then let <var data-anolis-xref="">date</var> be the date with year <var data-anolis-xref="">year</var>, month <var data-anolis-xref="">month</var>, and day <var data-anolis-xref="">day</var>, and return <var data-anolis-xref="">date</var>.</p>

        <p>Otherwise, if the <var data-anolis-xref="">time present</var> flag is true and the <var data-anolis-xref="">date present</var> flag is false, then let <var data-anolis-xref="">time</var> be the time with hour <var data-anolis-xref="">hour</var>, minute <var data-anolis-xref="">minute</var>, and second <var data-anolis-xref="">second</var>, and return <var data-anolis-xref="">time</var>.</p>

        <p>Otherwise, let <var data-anolis-xref="">time</var> be the moment in time at year <var data-anolis-xref="">year</var>, month <var data-anolis-xref="">month</var>, day <var data-anolis-xref="">day</var>, hours <var data-anolis-xref="">hour</var>, minute <var data-anolis-xref="">minute</var>, second <var data-anolis-xref="">second</var>, subtracting <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> hours and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> minutes, that moment in time being a moment in the UTC time zone; let <var data-anolis-xref="">timezone</var> be <var data-anolis-xref="">timezone<sub data-anolis-xref="">hours</sub></var> hours and <var data-anolis-xref="">timezone<sub data-anolis-xref="">minutes</sub></var> minutes from UTC; and return <var data-anolis-xref="">time</var> and <var data-anolis-xref="">timezone</var>.</p>
      </li>
    </ol>
  </div>

  <h4 id="colors"><span class="secno">2.4.6</span> 色</h4>

  <p><dfn id="simple-color">単純色</dfn>は、sRGB色空間の中で各色のコンポーネント赤、緑、青を表す、0から255までの範囲の8ビット数字3つからなる。<a href="references.html#refsSRGB">[SRGB]</a></p>

  <p>正確に7文字長である、最初の文字が"#"（U+0023）文字であり、残りの6文字がすべて<a href="#ascii-hex-digits">ASCII16進数字</a>である、最初の2桁は赤コンポーネントを表し、中の2桁は緑コンポーネントを表し、最後の2桁は青コンポーネントを表す16進数である場合、文字列は<dfn id="valid-simple-color">妥当な単純色</dfn>である。</p>

  <p><a href="#valid-simple-color">妥当な単純色</a>でかつU+0041 LATIN CAPITAL LETTER AからU+0046 LATIN CAPITAL LETTER Fまでの範囲の文字を一切使用しない場合、文字列は<dfn id="valid-lowercase-simple-color">妥当な小文字の単純色</dfn>である。</p>

  <div class="impl">
    <p>The <dfn id="rules-for-parsing-simple-color-values">rules for parsing simple color values</dfn> are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a <a href="#simple-color">simple color</a> or an error.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is not exactly seven characters long, then return an error.</p>
      </li>

      <li>
        <p>If the first character in <var data-anolis-xref="">input</var> is not a U+0023 NUMBER SIGN character (#), then return an error.</p>
      </li>

      <li>
        <p>If the last six characters of <var data-anolis-xref="">input</var> are not all <a href="#ascii-hex-digits">ASCII hex digits</a>, then return an error.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">result</var> be a <a href="#simple-color">simple color</a>.</p>
      </li>

      <li>
        <p>Interpret the second and third characters as a hexadecimal number and let the result be the red component of <var data-anolis-xref="">result</var>.</p>
      </li>

      <li>
        <p>Interpret the fourth and fifth characters as a hexadecimal number and let the result be the green component of <var data-anolis-xref="">result</var>.</p>
      </li>

      <li>
        <p>Interpret the sixth and seventh characters as a hexadecimal number and let the result be the blue component of <var data-anolis-xref="">result</var>.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">result</var>.</p>
      </li>
    </ol>

    <p>The <dfn id="rules-for-serializing-simple-color-values">rules for serializing simple color values</dfn> given a <a href="#simple-color">simple color</a> are as given in the following algorithm:</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">result</var> be a string consisting of a single "#" (U+0023) character.</p>
      </li>

      <li>
        <p>Convert the red, green, and blue components in turn to two-digit hexadecimal numbers using <a href="#lowercase-ascii-hex-digits">lowercase ASCII hex digits</a>, zero-padding if necessary, and append these numbers to <var data-anolis-xref="">result</var>, in the order red, green, blue.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">result</var>, which will be a <a href="#valid-lowercase-simple-color">valid lowercase simple color</a>.</p>
      </li>
    </ol>
    <hr>

    <p>Some obsolete legacy attributes parse colors in a more complicated manner, using the <dfn id="rules-for-parsing-a-legacy-color-value">rules for parsing a legacy color value</dfn>, which are given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a <a href="#simple-color">simple color</a> or an error.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is the empty string, then return an error.</p>
      </li>

      <li>
        <p><a href="#strip-leading-and-trailing-whitespace">Strip leading and trailing whitespace</a> from <var data-anolis-xref="">input</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is an <a href="#ascii-case-insensitive">ASCII case-insensitive</a> match for the string "<code data-anolis-xref="">transparent</code>", then return an error.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is an <a href="#ascii-case-insensitive">ASCII case-insensitive</a> match for one of the keywords listed in the <a href="http://www.w3.org/TR/css3-color/#svg-color">SVG color keywords</a> <!-- or <a href="http://www.w3.org/TR/css3-color/#css2-system">CSS2 System
    Colors</a> --> section<!--s--> of the CSS3 Color specification, then return the <a href="#simple-color">simple color</a> corresponding to that keyword. <a href="references.html#refsCSSCOLOR">[CSSCOLOR]</a></p>

        <p class="note"><a href="http://www.w3.org/TR/css3-color/#css2-system">CSS2 System Colors</a> are not recognised.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is four characters long, and the first character in <var data-anolis-xref="">input</var> is a "#" (U+0023) character, and the last three characters of <var data-anolis-xref="">input</var> are all <a href="#ascii-hex-digits">ASCII hex digits</a>, then run these substeps:</p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">result</var> be a <a href="#simple-color">simple color</a>.</p>
          </li>

          <li>
            <p>Interpret the second character of <var data-anolis-xref="">input</var> as a hexadecimal digit; let the red component of <var data-anolis-xref="">result</var> be the resulting number multiplied by 17.</p>
          </li>

          <li>
            <p>Interpret the third character of <var data-anolis-xref="">input</var> as a hexadecimal digit; let the green component of <var data-anolis-xref="">result</var> be the resulting number multiplied by 17.</p>
          </li>

          <li>
            <p>Interpret the fourth character of <var data-anolis-xref="">input</var> as a hexadecimal digit; let the blue component of <var data-anolis-xref="">result</var> be the resulting number multiplied by 17.</p>
          </li>

          <li>
            <p>Return <var data-anolis-xref="">result</var>.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>Replace any characters in <var data-anolis-xref="">input</var> that have a Unicode code point greater than U+FFFF (i.e. any characters that are not in the basic multilingual plane) with the two-character string "<code data-anolis-xref="">00</code>".</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is longer than 128 characters, truncate <var data-anolis-xref="">input</var>, leaving only the first 128 characters.</p>
      </li>

      <li>
        <p>If the first character in <var data-anolis-xref="">input</var> is a "#" (U+0023) character, remove it.</p>
      </li>

      <li>
        <p>Replace any character in <var data-anolis-xref="">input</var> that is not an <a data-anolis-xref="ASCII hex digits" href="#ascii-hex-digits">ASCII hex digit</a> with the character "0" (U+0030).</p>
      </li>

      <li>
        <p>While <var data-anolis-xref="">input</var>'s length is zero or not a multiple of three, append a "0" (U+0030) character to <var data-anolis-xref="">input</var>.</p>
      </li>

      <li>
        <p>Split <var data-anolis-xref="">input</var> into three strings of equal length, to obtain three components. Let <var data-anolis-xref="">length</var> be the length of those components (one third the length of <var data-anolis-xref="">input</var>).</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">length</var> is greater than 8, then remove the leading <span data-anolis-xref=""><var data-anolis-xref="">length</var>-8</span> characters in each component, and let <var data-anolis-xref="">length</var> be 8.</p>
      </li>

      <li>
        <p>While <var data-anolis-xref="">length</var> is greater than two and the first character in each component is a "0" (U+0030) character, remove that character and reduce <var data-anolis-xref="">length</var> by one.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">length</var> is <em>still</em> greater than two, truncate each component, leaving only the first two characters in each.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">result</var> be a <a href="#simple-color">simple color</a>.</p>
      </li>

      <li>
        <p>Interpret the first component as a hexadecimal number; let the red component of <var data-anolis-xref="">result</var> be the resulting number.</p>
      </li>

      <li>
        <p>Interpret the second component as a hexadecimal number; let the green component of <var data-anolis-xref="">result</var> be the resulting number.</p>
      </li>

      <li>
        <p>Interpret the third component as a hexadecimal number; let the blue component of <var data-anolis-xref="">result</var> be the resulting number.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">result</var>.</p>
      </li>
    </ol>
  </div>
  <hr>
  <!--2DCANVAS-->

  <h4 id="space-separated-tokens"><span class="secno">2.4.7</span> 空白区切りトークン</h4>

  <p><dfn id="set-of-space-separated-tokens">空白区切りトークンの組</dfn>は、1つ以上の<a data-anolis-xref="space character" href="#space-character">空白文字</a>によって区切られた0個以上の単語（トークンとして知られる）を含む文字列である。ここで、単語は1つ以上の文字を含み、<a data-anolis-xref="space character" href="#space-character">空白文字</a>を含まない。</p>

  <p><a href="#set-of-space-separated-tokens">空白区切りトークンの組</a>を構成する文字列は、先頭または末尾に<a data-anolis-xref="space character" href="#space-character">空白文字</a>を持ってもよい。</p>

  <p><dfn id="unordered-set-of-unique-space-separated-tokens">順序なし固有空白区切りトークンの組</dfn>は、繰り返しトークンのない<a href="#set-of-space-separated-tokens">空白区切りトークンの組</a>である。</p>

  <p><dfn id="ordered-set-of-unique-space-separated-tokens">順序あり固有空白区切りトークンの組</dfn>は、繰り返しトークンはないが、トークンの順序が意味のある<a href="#set-of-space-separated-tokens">空白区切りトークンの組</a>である。</p>

  <p><a data-anolis-xref="set of space-separated tokens" href="#set-of-space-separated-tokens">空白区切りトークンの組</a>は時折定義された許可される値の組を持つ。許可された値の組が定義される場合、トークンはすべて許可される値のリストでなければならない。その他の値は不適合である。そのような許可される値の組が用意されない場合、すべての値は適合である。</p>

  <p class="note"><a href="#set-of-space-separated-tokens">空白区切りトークンの組</a>のトークンがどのように比較されるか（たとえば、大文字小文字を区別するかどうか）は、セットごとに定義される。</p>

  <div class="impl">
    <p>When a user agent has to <dfn id="split-a-string-on-spaces">split a string on spaces</dfn>, it must use the following algorithm:</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">tokens</var> be an ordered list of tokens, initially empty.</p>
      </li>

      <li>
        <p><a href="#skip-whitespace">Skip whitespace</a></p>
      </li>

      <li>
        <p>While <var data-anolis-xref="">position</var> is not past the end of <var data-anolis-xref="">input</var>:</p>

        <ol>
          <li>
            <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are not <a data-anolis-xref="space character" href="#space-character">space characters</a>.</p>
          </li>

          <li>
            <p>Append the string collected in the previous step to <var data-anolis-xref="">tokens</var>.</p>
          </li>

          <li>
            <p><a href="#skip-whitespace">Skip whitespace</a></p>
          </li>
        </ol>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">tokens</var>.</p>
      </li>
    </ol>
  </div>

  <h4 id="comma-separated-tokens"><span class="secno">2.4.8</span> コンマ区切りトークン</h4>

  <p><dfn id="set-of-comma-separated-tokens">コンマ区切りトークンの組</dfn>は、それぞれ単一の","（U+002C）文字で区切られる0個以上のトークンを含む文字列である。ここでトークンは0個以上の任意の文字列からなり、先頭も末尾も<a data-anolis-xref="space character" href="#space-character">空白文字</a>でなく、","（U+002C）文字を含まず、任意で<a data-anolis-xref="space character" href="#space-character">空白文字</a>に囲まれるものである。</p>

  <p class="example">たとえば、文字列"<code data-anolis-xref="">&nbsp;a&nbsp;,b,,d&nbsp;d&nbsp;</code>"は4つのトークンからなる。"a"、"b"、空文字列および"d&nbsp;d"。各トークンの周りの先頭と末尾の空白はトークンの一部としてカウントされず、空文字列はトークンであるかもしれない。</p>

  <p><a data-anolis-xref="set of comma-separated tokens" href="#set-of-comma-separated-tokens">コンマ区切りトークンの組</a>は時に妥当なトークンを構成するさらなる制約を持つ。そのような制限が定義される場合、トークンはすべてその制限に収まるようにしなければならない。その他の値は不適合である。そのような制限が指定されない場合、すべての値は適合である。</p>

  <div class="impl">
    <p>When a user agent has to <dfn id="split-a-string-on-commas">split a string on commas</dfn>, it must use the following algorithm:</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the string being parsed.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">tokens</var> be an ordered list of tokens, initially empty.</p>
      </li>

      <li>
        <p><i>Token</i>: If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>, jump to the last step.</p>
      </li>

      <li>
        <p><a href="#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are not "," (U+002C) characters. Let <var data-anolis-xref="">s</var> be the resulting sequence (which might be the empty string).</p>
      </li>

      <li>
        <p><a href="#strip-leading-and-trailing-whitespace">Strip leading and trailing whitespace</a> from <var data-anolis-xref="">s</var>.</p>
      </li>

      <li>
        <p>Append <var data-anolis-xref="">s</var> to <var data-anolis-xref="">tokens</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">position</var> is not past the end of <var data-anolis-xref="">input</var>, then the character at <var data-anolis-xref="">position</var> is a "," (U+002C) character; advance <var data-anolis-xref="">position</var> past that character.</p>
      </li>

      <li>
        <p>Jump back to the step labeled <i>token</i>.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">tokens</var>.</p>
      </li>
    </ol>
  </div>

  <h4 id="syntax-references"><span class="secno">2.4.9</span> 参照</h4>

  <p>タイプ<var data-anolis-xref="">type</var>要素に対して<dfn id="valid-hash-name-reference">妥当なハッシュ名参照</dfn>は、"#"（U+0023）文字の後に文書でタイプ<var data-anolis-xref="">type</var>をもつ要素の<code data-anolis-xref="">name</code>属性値に正確に一致する文字列からなる文字列である。</p>

  <div class="impl">
    <p>The <dfn id="rules-for-parsing-a-hash-name-reference">rules for parsing a hash-name reference</dfn> to an element of type <var data-anolis-xref="">type</var> are as follows:</p>

    <ol>
      <li>
        <p>If the string being parsed does not contain a U+0023 NUMBER SIGN character, or if the first such character in the string is the last character in the string, then return null and abort these steps.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">s</var> be the string from the character immediately after the first U+0023 NUMBER SIGN character in the string being parsed up to the end of that string.</p>
      </li>

      <li>
        <p>Return the first element of type <var data-anolis-xref="">type</var> that has an <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute whose value is a <a href="#case-sensitive">case-sensitive</a> match for <var data-anolis-xref="">s</var> or a <code data-anolis-xref="">name</code> attribute whose value is a <a href="#compatibility-caseless">compatibility caseless</a> match for <var data-anolis-xref="">s</var>.</p>
      </li><!--
   IE is also doing case-insensitive id="" matching.
   Tests:
   http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A%3Cmap%20name%3D%22T%26eacute%3B%26%23x01F1%3B%26%23x2075%3B%22%3E%3Carea%20href%3D%22%2F%22%20shape%3Drect%20coords%3D0%2C0%2C200%2C200%3E%3C%2Fmap%3E%0A%3Cimg%20usemap%3D%22%23t%26Eacute%3BDZ5%22%20src%3Dimage%3E
   ...except that doesn't explain why this fails:
   http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0A%3Cmap%20name%3D%22T%26eacute%3B%26%23x01F1%3B%26%23x2075%3B%26%23xFB01%3B%22%3E%3Carea%20href%3D%22%2F%22%20shape%3Drect%20coords%3D0%2C0%2C200%2C200%3E%3C%2Fmap%3E%0A%3Cimg%20usemap%3D%22%23t%26Eacute%3BDZ5F%26%23x0131%3B%26%23x0307%3B%22%20src%3Dimage%3E
   maybe they just don't know about combining dot above?
   -->
    </ol>
  </div>

  <h4 id="mq"><span class="secno">2.4.10</span> メディアクエリ</h4>

  <p>メディアクエリ仕様の<code data-anolis-xref="">media_query_list</code>生成物に一致する場合、文字列は<dfn id="valid-media-query">妥当なメディアクエリ</dfn>である。<a href="references.html#refsMQ">[MQ]</a></p>

  <p>空文字列、<a data-anolis-xref="space character" href="#space-character">空白文字</a>のみからなる文字列、またはメディアクエリ仕様で与えられる定義に従ったユーザー環境にマッチするメディアクエリの場合、文字列はユーザー<dfn id="matches-the-environment">環境に一致する</dfn>。<a href="references.html#refsMQ">[MQ]</a></p>

  <h3 id="urls"><span class="secno">2.5</span> URL</h3>

  <h4 id="terminology-0"><span class="secno">2.5.1</span> 用語</h4>

  <p>URL標準でオーサリング適合性要件に準拠する場合、<span>URL</span>は<dfn id="valid-url">妥当なURL</dfn>である。<a href="references.html#refsURL">[URL]</a></p>

  <p><a href="#valid-url">妥当なURL</a>だが空文字列でない場合、文字列は<dfn id="valid-non-empty-url">妥当な空でないURL</dfn>である。</p>

  <p><a data-anolis-xref="strip leading and trailing whitespace" href="#strip-leading-and-trailing-whitespace">先頭と末尾の空白文字を取り除いた</a>あとに<a href="#valid-url">妥当なURL</a>である場合、文字列は<dfn id="valid-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当なURL</dfn>である。</p>

  <p><a data-anolis-xref="strip leading and trailing whitespace" href="#strip-leading-and-trailing-whitespace">先頭と末尾の空白文字を取り除いた</a>あとに、<a href="#valid-non-empty-url">妥当な空でないURL</a>である場合、文字列は<dfn id="valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</dfn>である。</p>

  <p>この仕様は、たとえ解決不可能でも、XMLツールの互換性のために必要な場合、<a href="#html-documents">HTML文書</a>の<a data-anolis-xref="syntax-doctype" href="syntax.html#syntax-doctype">DOCTYPE</a>で用いるための<code data-anolis-xref="">about:</code> URL予約としてURL <dfn id="about:legacy-compat"><code>about:legacy-compat</code></dfn>を定義する。<a href="references.html#refsABOUT">[ABOUT]</a></p>

  <p>この仕様は、たとえ解決不可能でも、<a data-anolis-xref="an iframe srcdoc document" href="embedded-content-0.html#an-iframe-srcdoc-document"><code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code>文書</a>の<a href="dom.html#the-document's-address">文書のアドレス</a>として用いられる<code data-anolis-xref="">about:</code> URLを予約としてURL <dfn id="about:srcdoc"><code>about:srcdoc</code></dfn>を定義する。<a href="references.html#refsABOUT">[ABOUT]</a></p>

  <p><code><a href="dom.html#document">Document</a></code>オブジェクトの<dfn id="fallback-base-url">フォールバック基底URL</dfn>は、以下のサブステップを実行して得られる<a href="#absolute-url">絶対URL</a>である：</p>

  <ol>
    <li>
      <p><code><a href="dom.html#document">Document</a></code>が<a href="embedded-content-0.html#an-iframe-srcdoc-document"><code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code>文書</a>である場合、<code><a href="dom.html#document">Document</a></code>の<a href="browsers.html#browsing-context">ブラウジングコンテキスト</a>がもつ<a href="browsers.html#browsing-context-container">ブラウジングコンテキストコンテナ</a>の<code><a href="dom.html#document">Document</a></code>に属する<a href="#document-base-url">文書基底URL</a>を返し、これらの手順を中止する。</p>
    </li>

    <li>
      <!-- http://www.hixie.ch/tests/adhoc/html/navigation/javascript-url/ --><!-- this should be tested in the case of a browsing context that was navigated to about:blank
    after having been elsewhere, as opposed to the about:blank used at the time of the browsing
    context's creation. -->

      <p><a href="dom.html#the-document's-address">文書のアドレス</a>が<code><a href="#about:blank">about:blank</a></code>であり、かつ<code><a href="dom.html#document">Document</a></code>の<a href="browsers.html#browsing-context">ブラウジングコンテキスト</a>が<a href="browsers.html#creator-browsing-context">クリエーターブラウジングコンテキスト</a>を持つ場合、<a href="browsers.html#creator-document">クリエーター<code>Document</code></a>の<a href="#document-base-url">文書基底URL</a>を返し、これらの手順を中止する。</p>
    </li><!-- http://www.hixie.ch/tests/adhoc/dom/level0/history/pushState/001/ -->

    <li>
      <p><a href="dom.html#the-document's-address">文書のアドレス</a>を返す。</p>
    </li>
  </ol>

  <p><code><a href="dom.html#document">Document</a></code>オブジェクトの<dfn id="document-base-url">文書基底URL</dfn>は、以下のサブステップを実行して得られる<a href="#absolute-url">絶対URL</a>である：</p>

  <ol>
    <li>
      <p><code><a href="dom.html#document">Document</a></code>に<code data-anolis-xref="attr-base-href"><a href="document-metadata.html#attr-base-href">href</a></code>属性を持つ<code><a href="document-metadata.html#the-base-element">base</a></code>要素が存在しない場合、<a href="#document-base-url">文書基底URL</a>は<code><a href="dom.html#document">Document</a></code>の<a href="#fallback-base-url">フォールバック基底URL</a>であり、これらの手順を中止する。</p>
    </li>

    <li>
      <p>そうでなければ、<a href="#document-base-url">文書基底URL</a>は<a href="#tree-order">ツリー順</a>で、<code data-anolis-xref="attr-base-href"><a href="document-metadata.html#attr-base-href">href</a></code>属性を持つ<code><a href="dom.html#document">Document</a></code>で最初の<code><a href="document-metadata.html#the-base-element">base</a></code>要素の<a href="document-metadata.html#frozen-base-url">凍結基底URL</a>である。</p>
    </li>
  </ol>

  <div class="impl">
    <h4 id="resolving-urls"><span class="secno">2.5.2</span> Resolving URLs</h4>

    <p>Resolving a URL is the process of taking a <a href="#relative-url">relative URL</a> and obtaining the <a href="#absolute-url">absolute URL</a> that it implies.</p>

    <p>To <dfn id="resolve-a-url">resolve a URL</dfn> to an <a href="#absolute-url">absolute URL</a> relative to either another <a href="#absolute-url">absolute URL</a> or an element, the user agent must use the following steps. Resolving a URL can result in an error, in which case the URL is not resolvable.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">url</var> be the <span>URL</span> being resolved.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">encoding</var> be determined as follows:</p>

        <dl class="switch">
          <dt>If the URL had a character encoding defined when the URL was created or defined or when this algorithm was invoked</dt>

          <dd>The URL character encoding is as defined.</dd>

          <dt>If the URL came from a script (e.g. as an argument to a method)</dt><!--CLEANUP-->

          <dd>
            The URL character encoding is the <a href="webappapis.html#api-url-character-encoding">API URL character encoding</a> specified by the script's <a href="webappapis.html#settings-object">settings object</a>.
          </dd>

          <dt>If the URL came from a DOM node (e.g. from an element)</dt>

          <dd>
            The node has a <code><a href="dom.html#document">Document</a></code>, and the URL character encoding is the <a href="#document's-character-encoding">document's character encoding</a>.
          </dd>
        </dl>
      </li>

      <li>
        <p>If <var data-anolis-xref="">encoding</var> is <a href="#a-utf-16-encoding">a UTF-16 encoding</a>, then change the value of <var data-anolis-xref="">encoding</var> to UTF-8.</p>
      </li>

      <li>
        <p>If the algorithm was invoked with an <a href="#absolute-url">absolute URL</a> to use as the base URL, let <var data-anolis-xref="">base</var> be that <a href="#absolute-url">absolute URL</a>.</p>

        <p>Otherwise, let <var data-anolis-xref="">base</var> be <a href="#the-element's-base-url">the element's base URL</a>.</p>
      </li>

      <li>
        <p>Apply the <a href="#url-parser-0">URL parser</a> to <var data-anolis-xref="">url</var>, with <var data-anolis-xref="">base</var> as the base URL, with <var data-anolis-xref="">encoding</var> as the encoding.</p>
      </li>

      <li>
        <p>If this returns failure, then abort these steps with an error.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">parsed URL</var> be the result of the <a href="#url-parser-0">URL parser</a>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">serialized URL</var> be the result of apply the <a data-anolis-xref="concept-url-serializer" href="#concept-url-serializer">URL serializer</a> to <var data-anolis-xref="">parsed URL</var>.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">serialized URL</var> as the <dfn id="resulting-absolute-url">resulting absolute URL</dfn> and <var data-anolis-xref="">parsed URL</var> as the <dfn id="resulting-parsed-url">resulting parsed URL</dfn>.</p>
      </li>
    </ol>

    <p>Given an element, <dfn id="the-element's-base-url">the element's base URL</dfn> is the <i>base URI of the element</i>, as defined by the XML Base specification, with <i>the base URI of the document entity</i> being defined as the <a href="#document-base-url">document base URL</a> of the <code><a href="dom.html#document">Document</a></code> that owns the element. <a href="references.html#refsXMLBASE">[XMLBASE]</a></p>

    <p>For the purposes of the XML Base specification, user agents must act as if all <code><a href="dom.html#document">Document</a></code> objects represented XML documents.</p>

    <p class="note">It is possible for <code data-anolis-xref="attr-xml-base"><a href="dom.html#the-xml:base-attribute-(xml-only)">xml:base</a></code> attributes to be present even in HTML fragments, as such attributes can be added dynamically using script. (Such scripts would not be conforming, however, as <code data-anolis-xref="attr-xml-base"><a href="dom.html#the-xml:base-attribute-(xml-only)">xml:base</a></code> attributes are not allowed in <a href="#html-documents">HTML documents</a>.)</p>
  </div>

  <div class="impl">
    <h4 id="dynamic-changes-to-base-urls"><span class="secno">2.5.3</span> Dynamic changes to base URLs</h4>

    <p>When an <code data-anolis-xref="attr-xml-base"><a href="dom.html#the-xml:base-attribute-(xml-only)">xml:base</a></code> attribute is set, changed, or removed, the attribute's element, and all descendant elements, are <a href="#affected-by-a-base-url-change">affected by a base URL change</a>.</p>

    <p>When a document's <a href="#document-base-url">document base URL</a> changes, all elements in that document are <a href="#affected-by-a-base-url-change">affected by a base URL change</a>.</p>

    <p>The following are <a href="#base-url-change-steps">base URL change steps</a>, which run when an element is <a href="#affected-by-a-base-url-change">affected by a base URL change</a> (as defined by the DOM specification):</p>

    <dl class="switch">
      <dt>
        If the element creates a <a href="links.html#hyperlink">hyperlink</a>
      </dt>

      <dd>
        <p>If the <a href="#absolute-url">absolute URL</a> identified by the hyperlink is being shown to the user, or if any data derived from that URL is affecting the display, then the <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> attribute should be <a data-anolis-xref="resolve a url" href="#resolve-a-url">re-resolved</a> relative to the element and the UI updated appropriately.</p>

        <p class="example">For example, the CSS <code data-anolis-xref="selector-link"><a href="disabled-elements.html#selector-link">:link</a></code>/<code data-anolis-xref="selector-visited"><a href="disabled-elements.html#selector-visited">:visited</a></code> pseudo-classes might have been affected.</p><!--PING-->
      </dd>

      <dt>If the element is a <code><a href="text-level-semantics.html#the-q-element">q</a></code>, <code><a href="grouping-content.html#the-blockquote-element">blockquote</a></code>, <code><a href="edits.html#the-ins-element">ins</a></code>, or <code><a href="edits.html#the-del-element">del</a></code> element with a <code data-anolis-xref="">cite</code> attribute</dt>

      <dd>
        <p>If the <a href="#absolute-url">absolute URL</a> identified by the <code data-anolis-xref="">cite</code> attribute is being shown to the user, or if any data derived from that URL is affecting the display, then the <span>URL</span> should be <a data-anolis-xref="resolve a url" href="#resolve-a-url">re-resolved</a> relative to the element and the UI updated appropriately.</p>
      </dd>

      <dt>Otherwise</dt>

      <dd>
        <p>The element is not directly affected.</p>

        <p class="example">For instance, changing the base URL doesn't affect the image displayed by <code><a href="embedded-content-0.html#the-img-element">img</a></code> elements, although subsequent accesses of the <code data-anolis-xref="dom-img-src"><a href="embedded-content-0.html#dom-img-src">src</a></code> IDL attribute from script will return a new <a href="#absolute-url">absolute URL</a> that might no longer correspond to the image being shown.</p>
      </dd>
    </dl>
  </div>

  <div class="impl">
    <h3 id="fetching-resources"><span class="secno">2.6</span> Fetching resources</h3>

    <h4 id="terminology-1"><span class="secno">2.6.1</span> Terminology</h4>

    <p id="concept-http-equivalent">User agents can implement a variety of transfer protocols, but this specification mostly defines behavior in terms of HTTP. <a href="references.html#refsHTTP">[HTTP]</a></p>

    <p>The <dfn data-anolis-xref="concept-http-equivalent-get" id="concept-http-equivalent-get">HTTP GET method</dfn> is equivalent to the default retrieval action of the protocol. For example, RETR in FTP. Such actions are idempotent and safe, in HTTP terms.</p>

    <p>The <dfn data-anolis-xref="concept-http-equivalent-codes" id="concept-http-equivalent-codes">HTTP response codes</dfn> are equivalent to statuses in other protocols that have the same basic meanings. For example, a "file not found" error is equivalent to a 404 code, a server error is equivalent to a 5xx code, and so on.</p>

    <p>The <dfn data-anolis-xref="concept-http-equivalent-headers" id="concept-http-equivalent-headers">HTTP headers</dfn> are equivalent to fields in other protocols that have the same basic meaning. For example, the HTTP authentication headers are equivalent to the authentication aspects of the FTP protocol.</p>

    <p>A <dfn id="referrer-source">referrer source</dfn> is either a <code><a href="dom.html#document">Document</a></code> or a <span>URL</span>.</p>

    <h4 id="processing-model"><span class="secno">2.6.2</span> Processing model</h4>

    <p>When a user agent is to <dfn id="fetch">fetch</dfn><!--FETCH--> a resource or <span>URL</span>, optionally <strong>from</strong> an origin <i data-anolis-xref="">origin</i>, optionally <strong>using</strong> a specific <a href="#referrer-source">referrer source</a> as an <i>override referrer source</i>, and optionally with any of a <i>synchronous flag</i>, a <i>manual redirect flag</i>, a <i>force same-origin flag</i>, and a <i>block cookies flag</i>, the following steps must be run. (When a <em>URL</em> is to be fetched, the URL identifies a resource to be obtained.)</p><!-- if invoked with the synchronous flag, make sure to release the storage mutex first -->
    <!-- synchronous flag is only to be used in algorithms that are themselves asynchronous! Only
  sync-XHR is allowed to make the mistake of screwing that up. :-P -->
    <!-- the force same-origin flag is for use in places where we'll be moving to CORS one day; when
  used, the algorithm must be invoked with a URL (not something else, like a POST request) whose
  origin is the same as the /origin/, which must also be present, and the algorithm must not be
  invoked with the manual redirect flag. -->
    <!-- "block cookies" is currently only used by XHR -->

    <ol>
      <li>
        <p>If there is a specific <i>override referrer source</i>, and it is a <span>URL</span>, then let <var data-anolis-xref="">referrer</var> be the <i>override referrer source</i>, and jump to the step labeled <i>clean referrer</i>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">document</var> be the appropriate <code><a href="dom.html#document">Document</a></code> as given by the following list:</p>

        <dl class="switch">
          <dt>If there is a specific <i>override referrer source</i></dt>

          <dd>The <i>override referrer source</i>.</dd>

          <dt>
            When <a data-anolis-xref="navigate" href="browsers.html#navigate">navigating</a>
          </dt>

          <dd>
            The <a href="browsers.html#active-document">active document</a> of the <a href="browsers.html#source-browsing-context">source browsing context</a>.
          </dd>

          <dt>When fetching resources for an element</dt>

          <dd>The element's <code><a href="dom.html#document">Document</a></code>.</dd>
        </dl>
      </li>

      <li>
        <p>While <var data-anolis-xref="">document</var> is <a href="embedded-content-0.html#an-iframe-srcdoc-document">an <code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code> document</a>, let <var data-anolis-xref="">document</var> be <var data-anolis-xref="">document</var>'s <a href="browsers.html#browsing-context">browsing context</a>'s <a href="browsers.html#browsing-context-container">browsing context container</a>'s <code><a href="dom.html#document">Document</a></code> instead.</p>
      </li>

      <li>
        <p>If the <a href="browsers.html#origin-0">origin</a> of <var data-anolis-xref="">Document</var> is not a scheme/host/port tuple, then set <var data-anolis-xref="">referrer</var> to the empty string and jump to the step labeled <i>clean referrer</i>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">referrer</var> be <a href="dom.html#the-document's-address">the document's address</a> of <var data-anolis-xref="">document</var>.</p>
      </li>

      <li>
        <p><i>Clean referrer</i>: Apply the <a href="#url-parser-0">URL parser</a> to <var data-anolis-xref="">referrer</var> and let <var data-anolis-xref="">parsed referrer</var> be the <a href="#resulting-parsed-url">resulting parsed URL</a>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">referrer</var> be the result of applying the <a data-anolis-xref="concept-url-serializer" href="#concept-url-serializer">URL serializer</a> to <var data-anolis-xref="">parsed referrer</var>, with the <i>exclude fragment flag</i> set.</p><!-- RFC2616 says "The URI MUST NOT include a fragment." (section 14.36) -->
      </li>

      <li>
        <p>If <var data-anolis-xref="">referrer</var> is not the empty string, is not a <a data-anolis-xref="data protocol" href="#data-protocol"><code data-anolis-xref="">data:</code> URL</a>, and is not the <span>URL</span> "<code><a href="#about:blank">about:blank</a></code>", then generate the <i>address of the resource from which Request-URIs are obtained</i> as required by HTTP for the <code data-anolis-xref="http-referer">Referer</code> (sic) header from <var data-anolis-xref="">referrer</var>. <a href="references.html#refsHTTP">[HTTP]</a></p>

        <p>Otherwise, the <code data-anolis-xref="http-referer">Referer</code> (sic) header must be omitted, regardless of its value.</p>
      </li>

      <li>
        <p>If the algorithm was not invoked with the <i>synchronous flag</i>, perform the remaining steps asynchronously.</p>
      </li>

      <li>
        <p>If the <code><a href="dom.html#document">Document</a></code> with which any <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by this algorithm would be associated doesn't have an associated <a href="browsers.html#browsing-context">browsing context</a>, then abort these steps.</p>
      </li><!--(redundant with 'at a time convenient...' below)
   <li><p>Optionally, wait until the <code>Document</code> with which any <span
   data-x="concept-task">tasks</span> <span data-x="queue a task">queued</span> by this algorithm
   would be associated is <span data-x="active document">active</span>.</p></li>
-->

      <li>
        <p>This is the <i>main step</i>.</p>

        <p>If the resource is to be obtained from an <a href="browsers.html#application-cache">application cache</a>, then use the data from that <a href="browsers.html#application-cache">application cache</a>, as if it had been obtained in the manner appropriate given its <span>URL</span>.</p>

        <p>If the resource is identified by an <a href="#absolute-url">absolute URL</a>, and the resource is to be obtained using an idempotent action (such as an HTTP GET <a data-anolis-xref="concept-http-equivalent-get" href="#concept-http-equivalent-get">or equivalent</a>), and it is already being downloaded for other reasons (e.g. another invocation of this algorithm), and this request would be identical to the previous one (e.g. same <code data-anolis-xref="http-accept">Accept</code> and <code data-anolis-xref="http-origin">Origin</code> headers), and the user agent is configured such that it is to reuse the data from the existing download instead of initiating a new one, then use the results of the existing download instead of starting a new one.</p>

        <p>Otherwise, if the resource is identified by an <a href="#absolute-url">absolute URL</a> with a scheme that does not define a mechanism to obtain the resource (e.g. it is a <code data-anolis-xref="">mailto:</code> URL) or that the user agent does not support, then act as if the resource was an HTTP 204 No Content response with no other metadata.</p>

        <p>Otherwise, if the resource is identified by the <span>URL</span> <dfn id="about:blank"><code>about:blank</code></dfn>, then the resource is immediately available and consists of the empty string, with no metadata.</p><!--CLEANUP-->

        <p>Otherwise, at a time convenient to the user and the user agent, download (or otherwise obtain) the resource, applying the semantics of the relevant specifications (e.g. performing an HTTP GET or POST operation, or reading the file from disk, or expanding <a data-anolis-xref="data protocol" href="#data-protocol"><code data-anolis-xref="">data:</code> URLs</a>, etc).</p>

        <p>For the purposes of the <code data-anolis-xref="http-referer">Referer</code> (sic) header, use the <i>address of the resource from which Request-URIs are obtained</i> generated in the earlier step.</p>

        <p>For the purposes of the <code data-anolis-xref="http-origin">Origin</code> header, if the <a data-anolis-xref="fetch" href="#fetch">fetching algorithm</a> was explicitly initiated from an <i data-anolis-xref="">origin</i>, then <i data-anolis-xref="">the origin that initiated the HTTP request</i> is <i data-anolis-xref="">origin</i>. Otherwise, this is <i data-anolis-xref="">a request from a "privacy-sensitive" context</i>. <a href="references.html#refsORIGIN">[ORIGIN]</a></p>
      </li>

      <li>
        <p>If the algorithm was not invoked with the <i>block cookies flag</i>, and there are cookies to be set, then the user agent must run the following substeps:</p>

        <ol>
          <li>
            <p>Wait until ownership of the <a href="webappapis.html#storage-mutex">storage mutex</a> can be taken by this instance of the <a data-anolis-xref="fetch" href="#fetch">fetching</a> algorithm.</p>
          </li>

          <li>
            <p>Take ownership of the <a href="webappapis.html#storage-mutex">storage mutex</a>.</p>
          </li>

          <li>
            <p>Update the cookies. <a href="references.html#refsCOOKIES">[COOKIES]</a> <a class="fingerprint" data-anolis-xref="fingerprinting vector" href="introduction.html#fingerprinting-vector"><img alt="(This is a fingerprinting vector.)" height="21" src="images/fingerprint.png" width="15"></a></p>
          </li>

          <li>
            <p>Release the <a href="webappapis.html#storage-mutex">storage mutex</a> so that it is once again free.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>If the fetched resource is an HTTP redirect <a data-anolis-xref="concept-http-equivalent-codes" href="#concept-http-equivalent-codes">or equivalent</a>, then:</p>

        <dl class="switch">
          <dt>
            If the <i>force same-origin flag</i> is set and the <span>URL</span> of the target of the redirect does not have the <a href="browsers.html#same-origin">same origin</a> as the <span>URL</span> for which the <a href="#fetch">fetch</a> algorithm was invoked
          </dt>

          <dd>
            <p>Abort these steps and return failure from this algorithm, as if the remote host could not be contacted.</p>
          </dd>

          <dt>If the <i>manual redirect flag</i> is set</dt>

          <dd>
            <p>Continue, using the fetched resource (the redirect) as the result of the algorithm. If the calling algorithm subsequently requires the user agent to <dfn id="transparently-follow-the-redirect">transparently follow the redirect</dfn>, then the user agent must resume this algorithm from the <i>main step</i>, but using the target of the redirect as the resource to fetch, rather than the original resource.</p>
          </dd>

          <dt>Otherwise</dt>

          <dd>
            <p>First, apply any relevant requirements for redirects (such as showing any appropriate prompts). Then, redo <i>main step</i>, but using the target of the redirect as the resource to fetch, rather than the original resource. For HTTP requests, the new request must include the same headers as the original request, except for headers for which other requirements are specified (such as the <code data-anolis-xref="http-host">Host</code> header). <a href="references.html#refsHTTP">[HTTP]</a></p>

            <p class="note">The HTTP specification requires that 301, 302, and 307 redirects, when applied to methods other than the safe methods, not be followed without user confirmation. That would be an appropriate prompt for the purposes of the requirement in the paragraph above. <a href="references.html#refsHTTP">[HTTP]</a></p>
          </dd>
        </dl>
      </li>

      <li>
        <p>If the algorithm was not invoked with the <i>synchronous flag</i>: When the resource is available, or if there is an error of some description, <a href="webappapis.html#queue-a-task">queue a task</a> that uses the resource as appropriate. If the resource can be processed incrementally, as, for instance, with a progressively interlaced JPEG or an HTML file, additional tasks may be queued to process the data as it is downloaded. The <a href="webappapis.html#task-source">task source</a> for these <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> is the <a href="webappapis.html#networking-task-source">networking task source</a>.</p>

        <p>Otherwise, return the resource or error information to the calling algorithm.</p>
      </li>
    </ol>

    <p>If the user agent can determine the actual length of the resource being <a data-anolis-xref="fetch" href="#fetch">fetched</a> for an instance of this algorithm, and if that length is finite, then that length is the file's <dfn data-anolis-xref="concept-fetch-total" id="concept-fetch-total">size</dfn>. Otherwise, the subject of the algorithm (that is, the resource being fetched) has no known <a data-anolis-xref="concept-fetch-total" href="#concept-fetch-total">size</a>. (For example, the HTTP <code data-anolis-xref="http-content-length">Content-Length</code> header might provide this information.)</p>

    <p>The user agent must also keep track of the <dfn data-anolis-xref="concept-fetch-loaded" id="concept-fetch-loaded">number of bytes downloaded</dfn> for each instance of this algorithm. This number must exclude any out-of-band metadata, such as HTTP headers.</p>

    <p class="note">The <a href="browsers.html#application-cache">application cache</a> processing model introduces some <a href="browsers.html#changesToNetworkingModel">changes to the networking model</a> to handle the returning of cached resources.</p>

    <p class="note">The <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> processing model handles redirects itself, overriding the redirection handling that would be done by the fetching algorithm.</p>

    <p class="note">Whether the <a href="#content-type-sniffing">type sniffing rules</a> apply to the fetched resource depends on the algorithm that invokes the rules — they are not always applicable.</p><!--ADD-TOPIC:Security-->

    <h4 id="encrypted-http-and-related-security-concerns"><span class="secno">2.6.3</span> Encrypted HTTP and related security concerns</h4>

    <p>Anything in this specification that refers to HTTP also applies to HTTP-over-TLS, as represented by <span data-anolis-xref="url">URLs</span> representing the <code data-anolis-xref="">https</code> scheme. <a href="references.html#refsHTTP">[HTTP]</a></p>

    <p class="warning">User agents should report certificate errors to the user and must either refuse to download resources sent with erroneous certificates or must act as if such resources were in fact served with no encryption.</p>

    <p>User agents should warn the user that there is a potential problem whenever the user visits a page that the user has previously visited, if the page uses less secure encryption on the second visit.</p>

    <p>Not doing so can result in users not noticing man-in-the-middle attacks.</p>

    <div class="example">
      <p>If a user connects to a server with a self-signed certificate, the user agent could allow the connection but just act as if there had been no encryption. If the user agent instead allowed the user to override the problem and then displayed the page as if it was fully and safely encrypted, the user could be easily tricked into accepting man-in-the-middle connections.</p>

      <p>If a user connects to a server with full encryption, but the page then refers to an external resource that has an expired certificate, then the user agent will act as if the resource was unavailable, possibly also reporting the problem to the user. If the user agent instead allowed the resource to be used, then an attacker could just look for "secure" sites that used resources from a different host and only apply man-in-the-middle attacks to that host, for example taking over scripts in the page.</p>

      <p>If a user bookmarks a site that uses a CA-signed certificate, and then later revisits that site directly but the site has started using a self-signed certificate, the user agent could warn the user that a man-in-the-middle attack is likely underway, instead of simply acting as if the page was not encrypted.</p>
    </div><!--REMOVE-TOPIC:Security-->

    <h4 id="content-type-sniffing"><span class="secno">2.6.4</span> Determining the type of a resource</h4>

    <p>The <dfn data-anolis-xref="Content-Type" id="content-type">Content-Type metadata</dfn> of a resource must be obtained and interpreted in a manner consistent with the requirements of the MIME Sniffing specification. <a href="references.html#refsMIMESNIFF">[MIMESNIFF]</a></p>

    <p>The <dfn data-anolis-xref="Content-Type sniffing" id="content-type-sniffing-0">sniffed type of a resource</dfn> must be found in a manner consistent with the requirements given in the MIME Sniffing specification for finding the <i>sniffed media type</i> of the relevant sequence of octets. <a href="references.html#refsMIMESNIFF">[MIMESNIFF]</a></p>

    <p>The <dfn data-anolis-xref="Content-Type sniffing: image" id="content-type-sniffing:-image">rules for sniffing images specifically</dfn> and the <dfn data-anolis-xref="Content-Type sniffing: text or binary" id="content-type-sniffing:-text-or-binary">rules for distinguishing if a resource is text or binary</dfn> are also defined in the MIME Sniffing specification. Both sets of rules return a <a href="#mime-type">MIME type</a> as their result. <a href="references.html#refsMIMESNIFF">[MIMESNIFF]</a></p>

    <p class="warning">It is imperative that the rules in the MIME Sniffing specification be followed exactly. When a user agent uses different heuristics for content type detection than the server expects, security problems can occur. For more details, see the MIME Sniffing specification. <a href="references.html#refsMIMESNIFF">[MIMESNIFF]</a></p>

    <h4 id="extracting-character-encodings-from-meta-elements"><span class="secno">2.6.5</span> Extracting character encodings from <code><a href="document-metadata.html#the-meta-element">meta</a></code> elements</h4>

    <p>The <dfn id="algorithm-for-extracting-a-character-encoding-from-a-meta-element">algorithm for extracting a character encoding from a <code>meta</code> element</dfn>, given a string <var data-anolis-xref="">s</var>, is as follows. It either returns a character encoding or nothing.</p>

    <ol>
      <!-- http://www.hixie.ch/tests/adhoc/html/parsing/encoding/all.html -->

      <li>
        <p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">s</var>, initially pointing at the start of the string.</p>
      </li>

      <li>
        <p><i>Loop</i>: Find the first seven characters in <var data-anolis-xref="">s</var> after <var data-anolis-xref="">position</var> that are an <a href="#ascii-case-insensitive">ASCII case-insensitive</a> match for the word "<code data-anolis-xref="">charset</code>". If no such match is found, return nothing and abort these steps.</p>
      </li>

      <li>
        <p>Skip any <a data-anolis-xref="space character" href="#space-character">space characters</a> that immediately follow the word "<code data-anolis-xref="">charset</code>" (there might not be any).</p>
      </li>

      <li>
        <p>If the next character is not a "=" (U+003D), then move <var data-anolis-xref="">position</var> to point just before that next character, and jump back to the step labeled <i>loop</i>.</p>
      </li>

      <li>
        <p>Skip any <a data-anolis-xref="space character" href="#space-character">space characters</a> that immediately follow the equals sign (there might not be any).</p>
      </li>

      <li>
        <p>Process the next character as follows:</p>

        <dl class="switch">
          <dt>If it is a """ (U+0022) character and there is a later """ (U+0022) character in <var data-anolis-xref="">s</var></dt>

          <dt>If it is a "'" (U+0027) character and there is a later "'" (U+0027) character in <var data-anolis-xref="">s</var></dt>

          <dd>
            Return the result of <a href="#getting-an-encoding">getting an encoding</a> from the substring that is between this character and the next earliest occurrence of this character.
          </dd>

          <dt>If it is an unmatched """ (U+0022) character</dt>

          <dt>If it is an unmatched "'" (U+0027) character</dt>

          <dt>If there is no next character</dt>

          <dd>Return nothing.</dd>

          <dt>Otherwise</dt>

          <dd>
            Return the result of <a href="#getting-an-encoding">getting an encoding</a> from the substring that consists of this character up to but not including the first <a href="#space-character">space character</a> or ";" (U+003B) character, or the end of <var data-anolis-xref="">s</var>, whichever comes first.
          </dd>
        </dl>
      </li>
    </ol>

    <p class="note">This algorithm is distinct from those in the HTTP specification (for example, HTTP doesn't allow the use of single quotes and requires supporting a backslash-escape mechanism that is not supported by this algorithm<!-- not to mention not having any rules for error-handling,
  which is of course why we're having to define it ourselves -->). While the algorithm is used in contexts that, historically, were related to HTTP, the syntax as supported by implementations diverged some time ago. <a href="references.html#refsHTTP">[HTTP]</a></p>
  </div>

  <h4 id="cors-settings-attributes"><span class="secno">2.6.6</span> CORS設定属性</h4>

  <p><dfn id="cors-settings-attribute">CORS設定属性</dfn>は、<a href="#enumerated-attribute">列挙属性</a>である。次の表は、キーワードと属性の状態を示す。1列目のキーワードは、キーワードと同じ行で2列目のセル内の状態に対応づける。</p>

  <table>
    <thead>
      <tr>
        <th>キーワード</th>

        <th>状態</th>

        <th>概要</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td><dfn data-anolis-xref="attr-crossorigin-anonymous-keyword" id="attr-crossorigin-anonymous-keyword"><code>anonymous</code></dfn></td>

        <td><dfn data-anolis-xref="attr-crossorigin-anonymous" id="attr-crossorigin-anonymous">Anonymous</dfn></td>

        <td>Cross-origin CORSは、<i><a href="#omit-credentials-flag">省略認証情報フラグ</a></i>設定を持つ要素を要求する。</td>
      </tr>

      <tr>
        <td><dfn data-anolis-xref="attr-crossorigin-use-credentials-keyword" id="attr-crossorigin-use-credentials-keyword"><code>use-credentials</code></dfn></td>

        <td><dfn data-anolis-xref="attr-crossorigin-use-credentials" id="attr-crossorigin-use-credentials">Use Credentials</dfn></td>

        <td>Cross-origin CORSは、<i><a href="#omit-credentials-flag">省略認証情報フラグ</a></i>設定を持たない要素を要求する。</td>
      </tr>
    </tbody>
  </table>

  <p>空文字列も妥当なキーワードであり、<a data-anolis-xref="attr-crossorigin-anonymous" href="#attr-crossorigin-anonymous">匿名</a>状態に対応づける。属性の<i>妥当でない値のデフォルト</i>は、<a data-anolis-xref="attr-crossorigin-anonymous" href="#attr-crossorigin-anonymous">匿名</a>状態である。<a data-anolis-xref="reflect" href="#reflect">反射</a>のために、<a data-anolis-xref="attr-crossorigin-anonymous" href="#attr-crossorigin-anonymous">匿名</a>状態の正規ケースは<code data-anolis-xref="attr-crossorigin-anonymous-keyword"><a href="#attr-crossorigin-anonymous-keyword">anonymous</a></code>キーワードである。属性が省略された場合に用いられる、<i>欠落した値のデフォルト</i>は、<dfn data-anolis-xref="attr-crossorigin-none" id="attr-crossorigin-none">No CORS</dfn>状態である。</p>

  <div class="impl">
    <h4 id="cors-enabled-fetch"><span class="secno">2.6.7</span> CORS-enabled fetch</h4>

    <p>When the user agent is required to perform a <dfn id="potentially-cors-enabled-fetch">potentially CORS-enabled fetch</dfn> of an <a href="#absolute-url">absolute URL</a> <var data-anolis-xref="">URL</var> with a mode <var data-anolis-xref="">mode</var> that is either "<a data-anolis-xref="attr-crossorigin-none" href="#attr-crossorigin-none">No CORS</a>", "<a data-anolis-xref="attr-crossorigin-anonymous" href="#attr-crossorigin-anonymous">Anonymous</a>", or "<a data-anolis-xref="attr-crossorigin-use-credentials" href="#attr-crossorigin-use-credentials">Use Credentials</a>", optionally using a <a href="#referrer-source">referrer source</a> <var data-anolis-xref="">referrer source</var>, with an <a href="browsers.html#origin-0">origin</a> <var data-anolis-xref="">origin</var>, and with a default origin behaviour <var data-anolis-xref="">default</var> which is either "<i>taint</i>" or "<i>fail</i>", it must run the first applicable set of steps from the following list. The default origin behaviour is only used if <var data-anolis-xref="">mode</var> is "<a data-anolis-xref="attr-crossorigin-none" href="#attr-crossorigin-none">No CORS</a>". This algorithm wraps the <a href="#fetch">fetch</a> algorithm above, and labels the obtained resource as either <dfn id="cors-same-origin">CORS-same-origin</dfn> or <dfn id="cors-cross-origin">CORS-cross-origin</dfn>, or blocks the resource entirely.</p>

    <dl class="switch">
      <dt>
        If the <var data-anolis-xref="">URL</var> has the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>
      </dt>

      <dt>
        If the <var data-anolis-xref="">URL</var> is a <a data-anolis-xref="data protocol" href="#data-protocol"><code data-anolis-xref="">data:</code> URL</a>
      </dt>

      <dt>If the <var data-anolis-xref="">URL</var> is <code><a href="#about:blank">about:blank</a></code></dt>

      <dd>
        <p>Run these substeps:</p>

        <ol>
          <li>
            <p><a href="#fetch">Fetch</a><!--FETCH--> <var data-anolis-xref="">URL</var>, using <var data-anolis-xref="">referrer source</var> if one was specified, with the <i>manual redirect flag</i> set.</p>
          </li><!--
     http-origin privacy sensitive -->

          <li>
            <p><i>Loop</i>: Wait for the <a href="#fetch">fetch</a> algorithm to know if the result is a redirect or not.</p>
          </li>

          <li>
            <p>Follow the first appropriate steps from the following list:</p>

            <dl class="switch">
              <dt>
                If the result of the <a href="#fetch">fetch</a> is a redirect, and the <a href="browsers.html#origin-0">origin</a> of the target URL of the redirect is not the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>
              </dt>

              <dd>
                <p>Set <var data-anolis-xref="">URL</var> to the target URL of the redirect and return to the top of the <a href="#potentially-cors-enabled-fetch">potentially CORS-enabled fetch</a> algorithm (this time, one of the other branches below might be taken, based on the value of <var data-anolis-xref="">mode</var><!-- but if
        it's a data: URL, we'll stay here -->).</p>
              </dd>

              <dt>
                If the result of the <a href="#fetch">fetch</a> is a redirect
              </dt>

              <dd>
                <p class="note">The <a href="browsers.html#origin-0">origin</a> of the target URL of the redirect is the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>.</p>

                <p><a href="#transparently-follow-the-redirect">Transparently follow the redirect</a> and jump to the step labeled <i>loop</i> above.</p>
              </dd>

              <dt>Otherwise</dt>

              <dd>
                <p class="note">The resource is available, it is not a redirect, and its <a href="browsers.html#origin-0">origin</a> is the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>.</p>

                <p>The <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> from the <a href="#fetch">fetch</a> algorithm are <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> normally, and for the purposes of the calling algorithm, the obtained resource is <a href="#cors-same-origin">CORS-same-origin</a>.</p>
              </dd>
            </dl>
          </li>
        </ol>
      </dd>

      <dt>
        If <var data-anolis-xref="">mode</var> is "<a data-anolis-xref="attr-crossorigin-none" href="#attr-crossorigin-none">No CORS</a>" and <var data-anolis-xref="">default</var> is <i>taint</i>
      </dt>

      <dd>
        <p class="note">The <var data-anolis-xref="">URL</var> does not have the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>.</p>

        <p><a href="#fetch">Fetch</a><!--FETCH--> <var data-anolis-xref="">URL</var>, using <var data-anolis-xref="">referrer source</var> if one was specified.</p><!-- http-origin privacy sensitive -->

        <p>The <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> from the <a href="#fetch">fetch</a> algorithm are <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> normally, but for the purposes of the calling algorithm, the obtained resource is <a href="#cors-cross-origin">CORS-cross-origin</a>. The user agent may report a cross-origin resource access failure to the user (e.g. in a debugging console).</p>
      </dd>

      <dt>
        If <var data-anolis-xref="">mode</var> is "<a data-anolis-xref="attr-crossorigin-none" href="#attr-crossorigin-none">No CORS</a>"
      </dt>

      <dd>
        <p class="note">The <var data-anolis-xref="">URL</var> does not have the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>, and <var data-anolis-xref="">default</var> is <i>fail</i>.</p>

        <p>Discard any data fetched as part of this algorithm, and prevent any <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> from such invocations of the <a href="#fetch">fetch</a> algorithm from being <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a>. For the purposes of the calling algorithm, the user agent must act as if there was a fatal network error and no resource was obtained. The user agent may report a cross-origin resource access failure to the user (e.g. in a debugging console).</p>
      </dd>

      <dt>
        If <var data-anolis-xref="">mode</var> is "<a data-anolis-xref="attr-crossorigin-anonymous" href="#attr-crossorigin-anonymous">Anonymous</a>" or "<a data-anolis-xref="attr-crossorigin-use-credentials" href="#attr-crossorigin-use-credentials">Use Credentials</a>"
      </dt>

      <dd>
        <p class="note">The <var data-anolis-xref="">URL</var> does not have the <a href="browsers.html#same-origin">same origin</a> as <var data-anolis-xref="">origin</var>.</p>

        <p>Run these steps:</p>

        <ol>
          <li>
            <p>Perform a <a href="#cross-origin-request">cross-origin request</a><!--FETCH--> with the <i>request URL</i> set to <var data-anolis-xref="">URL</var>, with the CORS <i data-anolis-xref="">referrer source</i> set to <var data-anolis-xref="">referrer source</var> if one was specified, the <i>source origin</i> set to <var data-anolis-xref="">origin</var>, and with the <i><a href="#omit-credentials-flag">omit credentials flag</a></i> set if <var data-anolis-xref="">mode</var> is "<a data-anolis-xref="attr-crossorigin-anonymous" href="#attr-crossorigin-anonymous">Anonymous</a>" and not set otherwise. <a href="references.html#refsCORS">[CORS]</a></p>
          </li>

          <li>
            <p>Wait for the CORS <a href="#cross-origin-request-status">cross-origin request status</a> to have a value.</p>
          </li>

          <li>
            <p>Jump to the appropriate step from the following list:</p>

            <dl class="switch">
              <dt>
                If the CORS <a href="#cross-origin-request-status">cross-origin request status</a> is not <i>success</i>
              </dt>

              <dd>
                <p>Discard all fetched data and prevent any <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> from the <a href="#fetch">fetch</a> algorithm from being <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a>. For the purposes of the calling algorithm, the user agent must act as if there was a fatal network error and no resource was obtained. If a CORS <a href="#resource-sharing-check">resource sharing check</a> failed, the user agent may report a cross-origin resource access failure to the user (e.g. in a debugging console).</p>
              </dd>

              <dt>
                If the CORS <a href="#cross-origin-request-status">cross-origin request status</a> is <i>success</i>
              </dt>

              <dd>
                <p>The <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> from the <a href="#fetch">fetch</a> algorithm are <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> normally, and for the purposes of the calling algorithm, the obtained resource is <a href="#cors-same-origin">CORS-same-origin</a>.</p>
              </dd>
            </dl>
          </li>
        </ol>
      </dd>
    </dl>
  </div>

  <h3 id="common-dom-interfaces"><span class="secno">2.7</span> 共通DOMインターフェース</h3>

  <h4 id="reflecting-content-attributes-in-idl-attributes"><span class="secno">2.7.1</span> IDL属性におけるコンテンツ属性の反映</h4>

  <p>一部のIDL属性は、特定のコンテンツ属性の<dfn id="reflect">反映</dfn>を定義する。これは、IDL属性がコンテンツ属性の現在値を返し、IDL属性が与えられた値にコンテンツ属性の値を変更することを意味する。</p><!-- v2 for completeness: (also search for REFLECTIDL)
  <p class="note">A list of <span>reflecting IDL attributes</span> and
  their corresponding content attributes is given in the index.</p>
-->

  <div class="impl">
    <p>In general, on getting, if the content attribute is not present, the IDL attribute must act as if the content attribute's value is the empty string; and on setting, if the content attribute is not present, it must first be added.</p>

    <p>If a reflecting IDL attribute is a <code>DOMString</code> attribute whose content attribute is defined to contain a <span>URL</span>, then on getting, the IDL attribute must <a data-anolis-xref="resolve a url" href="#resolve-a-url">resolve</a> the value of the content attribute relative to the element and return the resulting <a href="#absolute-url">absolute URL</a> if that was successful, or the empty string otherwise; and on setting, must set the content attribute to the specified literal value. If the content attribute is absent, the IDL attribute must return the default value, if the content attribute has one, or else the empty string.</p>

    <p>If a reflecting IDL attribute is a <code>DOMString</code> attribute whose content attribute is defined to contain one or more <span data-anolis-xref="URL">URLs</span>, then on getting, the IDL attribute must <a data-anolis-xref="split a string on spaces" href="#split-a-string-on-spaces">split the content attribute on spaces</a> and return the concatenation of <a data-anolis-xref="resolve a URL" href="#resolve-a-url">resolving</a> each token URL to an <a href="#absolute-url">absolute URL</a> relative to the element, with a single U+0020 SPACE character between each URL, ignoring any tokens that did not resolve successfully. If the content attribute is absent, the IDL attribute must return the default value, if the content attribute has one, or else the empty string. On setting, the IDL attribute must set the content attribute to the specified literal value.</p>

    <p>If a reflecting IDL attribute is a <code>DOMString</code> attribute whose content attribute is an <a href="#enumerated-attribute">enumerated attribute</a>, and the IDL attribute is <dfn id="limited-to-only-known-values">limited to only known values</dfn>, then, on getting, the IDL attribute must return the conforming value associated with the state the attribute is in (in its canonical case), if any, or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is not in a defined state (e.g. the attribute is missing and there is no <i>missing value default</i>); and on setting, the content attribute must be set to the specified new value.</p>

    <p>If a reflecting IDL attribute is a <code>DOMString</code> attribute but doesn't fall into any of the above categories, then the getting and setting must be done in a transparent, case-preserving manner.</p>

    <p>If a reflecting IDL attribute is a <code data-anolis-xref="">boolean</code> attribute, then on getting the IDL attribute must return true if the content attribute is set, and false if it is absent. On setting, the content attribute must be removed if the IDL attribute is set to false, and must be set to the empty string if the IDL attribute is set to true. (This corresponds to the rules for <a data-anolis-xref="boolean attribute" href="#boolean-attribute">boolean content attributes</a>.)</p>

    <p>If a reflecting IDL attribute has a signed integer type (<code>long</code>) then, on getting, the content attribute must be parsed according to the <a data-anolis-xref="rules for parsing integers" href="#rules-for-parsing-integers">rules for parsing signed integers</a>, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, then the default value must be returned instead, or 0 if there is no default value. On setting, the given value must be converted to the shortest possible string representing the number as a <a href="#valid-integer">valid integer</a> and then that string must be used as the new content attribute value.</p>

    <p>If a reflecting IDL attribute has a signed integer type (<code>long</code>) that is <dfn id="limited-to-only-non-negative-numbers">limited to only non-negative numbers</dfn> then, on getting, the content attribute must be parsed according to the <a href="#rules-for-parsing-non-negative-integers">rules for parsing non-negative integers</a>, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or −1 if there is no default value. On setting, if the value is negative, the user agent must throw an <code><a href="#indexsizeerror">IndexSizeError</a></code> exception. Otherwise, the given value must be converted to the shortest possible string representing the number as a <a href="#valid-non-negative-integer">valid non-negative integer</a> and then that string must be used as the new content attribute value.</p>

    <p>If a reflecting IDL attribute has an <em>unsigned</em> integer type (<code>unsigned long</code>) then, on getting, the content attribute must be parsed according to the <a href="#rules-for-parsing-non-negative-integers">rules for parsing non-negative integers</a>, and if that is successful, and the value is in the range 0 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0 if there is no default value. On setting, first, if the new value is in the range 0 to 2147483647, then let <var data-anolis-xref="">n</var> be the new value, otherwise let <var data-anolis-xref="">n</var> be the default value, or 0 if there is no default value; then, <var data-anolis-xref="">n</var> must be converted to the shortest possible string representing the number as a <a href="#valid-non-negative-integer">valid non-negative integer</a> and that string must be used as the new content attribute value.</p><!-- see http://www.w3.org/Bugs/Public/show_bug.cgi?id=10352
  https://bugzilla.mozilla.org/show_bug.cgi?id=586118 and
  https://www.w3.org/Bugs/Public/show_bug.cgi?id=17705 for why the
  range is clamped to 2147483647 rather the normal unsigned long
  maximum value of 4294967295 -->

    <p>If a reflecting IDL attribute has an unsigned integer type (<code>unsigned long</code>) that is <dfn id="limited-to-only-non-negative-numbers-greater-than-zero">limited to only non-negative numbers greater than zero</dfn>, then the behavior is similar to the previous case, but zero is not allowed. On getting, the content attribute must first be parsed according to the <a href="#rules-for-parsing-non-negative-integers">rules for parsing non-negative integers</a>, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 1 if there is no default value. On setting, if the value is zero, the user agent must throw an <code><a href="#indexsizeerror">IndexSizeError</a></code> exception. Otherwise, first, if the new value is in the range 1 to 2147483647, then let <var data-anolis-xref="">n</var> be the new value, otherwise let <var data-anolis-xref="">n</var> be the default value, or 1 if there is no default value; then, <var data-anolis-xref="">n</var> must be converted to the shortest possible string representing the number as a <a href="#valid-non-negative-integer">valid non-negative integer</a> and that string must be used as the new content attribute value.</p><!-- see previous paragraph for note about the weird range -->

    <p>If a reflecting IDL attribute has a floating-point number type (<code>double</code> or <code>unrestricted double</code>), then, on getting, the content attribute must be parsed according to the <a href="#rules-for-parsing-floating-point-number-values">rules for parsing floating-point number values</a>, and if that is successful, the resulting value must be returned. If, on the other hand, it fails, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, the given value must be converted to the <a href="#best-representation-of-the-number-as-a-floating-point-number">best representation of the number as a floating-point number</a> and then that string must be used as the new content attribute value.</p>

    <p>If a reflecting IDL attribute has a floating-point number type (<code>double</code> or <code>unrestricted double</code>) that is <dfn id="limited-to-numbers-greater-than-zero">limited to numbers greater than zero</dfn>, then the behavior is similar to the previous case, but zero and negative values are not allowed. On getting, the content attribute must be parsed according to the <a href="#rules-for-parsing-floating-point-number-values">rules for parsing floating-point number values</a>, and if that is successful and the value is greater than 0.0, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, if the value is less than or equal to zero, then the value must be ignored. Otherwise, the given value must be converted to the <a href="#best-representation-of-the-number-as-a-floating-point-number">best representation of the number as a floating-point number</a> and then that string must be used as the new content attribute value.</p>

    <p class="note">The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in the Web IDL specification. <a href="references.html#refsWEBIDL">[WEBIDL]</a></p>

    <p>If a reflecting IDL attribute has the type <code><a href="#domtokenlist">DOMTokenList</a></code> or <code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code>, then on getting it must return a <code><a href="#domtokenlist">DOMTokenList</a></code> or <code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code> object (as appropriate) whose associated element is the element in question and whose associated attribute's local name is the name of the attribute in question. The same <code><a href="#domtokenlist">DOMTokenList</a></code> or <code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code> object must be returned every time for each attribute.</p>

    <p>If a reflecting IDL attribute has the type <code><a href="dom.html#htmlelement">HTMLElement</a></code>, or an interface that descends from <code><a href="dom.html#htmlelement">HTMLElement</a></code>, then, on getting, it must run the following algorithm (stopping at the first point where a value is returned):</p>

    <ol>
      <li>If the corresponding content attribute is absent, then the IDL attribute must return null.</li>

      <li>Let <var data-anolis-xref="">candidate</var> be the element that the <code data-anolis-xref="dom-Document-getElementById"><a href="#dom-document-getelementbyid">document.getElementById()</a></code> method would find when called on the content attribute's document if it were passed as its argument the current value of the corresponding content attribute.</li>

      <li>If <var data-anolis-xref="">candidate</var> is null, or if it is not type-compatible with the IDL attribute, then the IDL attribute must return null.</li>

      <li>Otherwise, it must return <var data-anolis-xref="">candidate</var>.</li>
    </ol>

    <p>On setting, if the given element has an <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute, and has the same <a href="#home-subtree">home subtree</a> as the element of the attribute being set, and the given element is the first element in that <a href="#home-subtree">home subtree</a> whose <a data-anolis-xref="concept-ID" href="#concept-id">ID</a> is the value of that <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute, then the content attribute must be set to the value of that <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute. Otherwise, the content attribute must be set to the empty string.</p>
  </div><!--TOPIC:DOM APIs-->

  <h4 id="collections"><span class="secno">2.7.2</span> コレクション</h4>

  <p><code><a href="#htmlallcollection-0">HTMLAllCollection</a></code>、<code><a href="#htmlformcontrolscollection-0">HTMLFormControlsCollection</a></code>、<code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> <!--MD-->
   インターフェースは、<code><a href="#htmlcollection">HTMLCollection</a></code>インターフェースから派生する<a href="#collections-0">コレクション</a>である。</p>

  <h5 id="htmlallcollection"><span class="secno">2.7.2.1</span> HTMLAllCollection</h5>

  <p><code><a href="#htmlallcollection-0">HTMLAllCollection</a></code>インターフェースは、複数の一致する要素が存在する場合、インターフェースの<code data-anolis-xref="dom-HTMLAllCollection-namedItem"><a href="#dom-htmlallcollection-nameditem">namedItem()</a></code>メソッドが<code><a href="#htmlcollection">HTMLCollection</a></code>オブジェクトを返す例外、およびインターフェースの<code data-anolis-xref="dom-HTMLAllCollection-item">item()</code>メソッドがその<code data-anolis-xref="dom-HTMLAllCollection-namedItem"><a href="#dom-htmlallcollection-nameditem">namedItem()</a></code>メソッドと同義に用いられる例外とともに、ちょうど<code><a href="#htmlcollection">HTMLCollection</a></code>のような要素の汎用<a href="#collections-0">コレクション</a>に使用される。これはレガシー<code data-anolis-xref="dom-document-all"><a href="obsolete.html#dom-document-all">document.all</a></code>属性のみを意図する。</p>
  <pre class="idl">
interface <dfn id="htmlallcollection-0">HTMLAllCollection</dfn> : <a href="#htmlcollection">HTMLCollection</a> {
  // inherits <span data-anolis-xref="dom-HTMLCollection-length">length</span> and <a data-anolis-xref="dom-HTMLCollection-item" href="#dom-htmlcollection-item">item</a>(unsigned long index)
  (<a href="#htmlcollection">HTMLCollection</a> or <a href="#element">Element</a>)? <a data-anolis-xref="dom-HTMLAllCollection-item-string" href="#dom-htmlallcollection-item-string">item</a>(DOMString name);
  legacycaller getter (<a href="#htmlcollection">HTMLCollection</a> or <a href="#element">Element</a>)? <a data-anolis-xref="dom-HTMLAllCollection-namedItem" href="#dom-htmlallcollection-nameditem">namedItem</a>(DOMString name); // shadows inherited namedItem()
  <a href="#htmlallcollection-0">HTMLAllCollection</a> <a data-anolis-xref="dom-HTMLAllCollection-tags" href="#dom-htmlallcollection-tags">tags</a>(DOMString tagName);
};
</pre>

  <dl class="domintro">
    <dt><var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLCollection-length">length</code></dt>

    <dd>
      <p>コレクションの要素数を返す。</p>
    </dd>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLCollection-item"><a href="#dom-htmlcollection-item">item</a></code>(<var data-anolis-xref="">index</var>)</dt>

    <dt><var data-anolis-xref="">collection</var>[<var data-anolis-xref="">index</var>]</dt>

    <dd>
      <p>コレクションからのインデックス<var data-anolis-xref="">index</var>とともにアイテムを返す。アイテムは<a href="#tree-order">ツリー順</a>にソートされる。</p>
    </dd>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLAllCollection-item-string"><a href="#dom-htmlallcollection-item-string">item</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">collection</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLAllCollection-item-string"><a href="#dom-htmlallcollection-item-string">item</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLAllCollection-namedItem"><a href="#dom-htmlallcollection-nameditem">namedItem</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">collection</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLAllCollection-namedItem"><a href="#dom-htmlallcollection-nameditem">namedItem</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">collection</var>[<var data-anolis-xref="">name</var>]</dt>

    <dt><var data-anolis-xref="">collection</var>(<var data-anolis-xref="">name</var>)</dt>

    <dd>
      <p>コレクションからの<a data-anolis-xref="concept-id" href="#concept-id">ID</a>または名前<var data-anolis-xref="">name</var>とともにアイテムを返す。</p>

      <p>複数のマッチするアイテムが存在する場合、それらの要素すべてを含む<code><a href="#htmlcollection">HTMLCollection</a></code>オブジェクトが返される。</p>

      <p>ただし<code><a href="text-level-semantics.html#the-a-element">a</a></code>、<code><a href="obsolete.html#the-applet-element">applet</a></code>、<code><a href="embedded-content-0.html#the-area-element">area</a></code>、<code><a href="embedded-content-0.html#the-embed-element">embed</a></code>、<code><a href="forms.html#the-form-element">form</a></code>、<code><a href="obsolete.html#frame">frame</a></code>、<code><a href="obsolete.html#frameset">frameset</a></code>、<code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code>、<code><a href="embedded-content-0.html#the-img-element">img</a></code>、および<code><a href="embedded-content-0.html#the-object-element">object</a></code>要素はこのメソッドのために名前を持ってもよい。それらの名前は<code data-anolis-xref="">name</code>属性値によって与えられる。</p>
    </dd>

    <dt><var data-anolis-xref="">collection</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLAllCollection-tags"><a href="#dom-htmlallcollection-tags">tags</a></code>(<var data-anolis-xref="">tagName</var>)</dt>

    <dd>
      <p>指定されたタグ名を持つ要素のみを含む、現在のコレクションのフィルタリングされた表示であるコレクションを返す。</p>
    </dd>
  </dl>

  <div class="impl">
    <p>The object's <a href="#supported-property-indices">supported property indices</a> are as defined for <code><a href="#htmlcollection">HTMLCollection</a></code> objects.</p>

    <p>The <a href="#supported-property-names">supported property names</a> consist of the non-empty values of all the <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attributes of all the elements <a href="#represented-by-the-collection">represented by the collection</a>, and the non-empty values of all the <code data-anolis-xref="">name</code> attributes of all the <code><a href="text-level-semantics.html#the-a-element">a</a></code>, <code><a href="obsolete.html#the-applet-element">applet</a></code>, <code><a href="embedded-content-0.html#the-area-element">area</a></code>, <code><a href="embedded-content-0.html#the-embed-element">embed</a></code>, <code><a href="forms.html#the-form-element">form</a></code>, <code><a href="obsolete.html#frame">frame</a></code>, <code><a href="obsolete.html#frameset">frameset</a></code>, <code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code>, <code><a href="embedded-content-0.html#the-img-element">img</a></code>, and <code><a href="embedded-content-0.html#the-object-element">object</a></code> elements <a href="#represented-by-the-collection">represented by the collection</a>, in <a href="#tree-order">tree order</a>, ignoring later duplicates, with the <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> of an element preceding its <code data-anolis-xref="">name</code> if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.</p>

    <p>The <dfn data-anolis-xref="dom-HTMLAllCollection-item-string" id="dom-htmlallcollection-item-string"><code>item(<var data-anolis-xref="">name</var>)</code></dfn> and <dfn data-anolis-xref="dom-HTMLAllCollection-namedItem" id="dom-htmlallcollection-nameditem"><code>namedItem(<var data-anolis-xref="">name</var>)</code></dfn> methods must act according to the following algorithm:</p>

    <ol>
      <li>If <var data-anolis-xref="">name</var> is the empty string, return null and stop the algorithm.</li>

      <li>
        <p>Let <var data-anolis-xref="">collection</var> be an <code><a href="#htmlcollection">HTMLCollection</a></code> object rooted at the same node as the <code><a href="#htmlallcollection-0">HTMLAllCollection</a></code> object on which the method was invoked, whose filter matches only elements that already match the filter of the <code><a href="#htmlallcollection-0">HTMLAllCollection</a></code> object on which the method was invoked and that are either:</p>

        <ul>
          <li><code><a href="text-level-semantics.html#the-a-element">a</a></code>, <code><a href="obsolete.html#the-applet-element">applet</a></code>, <code><a href="embedded-content-0.html#the-area-element">area</a></code>, <code><a href="embedded-content-0.html#the-embed-element">embed</a></code>, <code><a href="forms.html#the-form-element">form</a></code>, <code><a href="obsolete.html#frame">frame</a></code>, <code><a href="obsolete.html#frameset">frameset</a></code>, <code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code>, <code><a href="embedded-content-0.html#the-img-element">img</a></code>, or <code><a href="embedded-content-0.html#the-object-element">object</a></code> elements with a <code data-anolis-xref="">name</code> attribute equal to <var data-anolis-xref="">name</var>, or,</li>

          <li>elements with an <a data-anolis-xref="concept-id" href="#concept-id">ID</a> equal to <var data-anolis-xref="">name</var>.
          </li>
        </ul>
      </li>

      <li>If, at the time the method is called, there is exactly one node in <var data-anolis-xref="">collection</var>, then return that node and stop the algorithm.</li>

      <li>Otherwise, if, at the time the method is called, <var data-anolis-xref="">collection</var> is empty, return null and stop the algorithm.</li>

      <li>Otherwise, return <var data-anolis-xref="">collection</var>.</li>
    </ol>

    <p>The <dfn data-anolis-xref="dom-HTMLAllCollection-tags" id="dom-htmlallcollection-tags"><code>tags(<var data-anolis-xref="">tagName</var>)</code></dfn> method must return an <code><a href="#htmlallcollection-0">HTMLAllCollection</a></code> rooted at the same node as the <code><a href="#htmlallcollection-0">HTMLAllCollection</a></code> object on which the method was invoked, whose filter matches only <a href="#html-elements">HTML elements</a> whose local name is the <var data-anolis-xref="">tagName</var> argument and that already match the filter of the <code><a href="#htmlallcollection-0">HTMLAllCollection</a></code> object on which the method was invoked. In <a href="#html-documents">HTML documents</a>, the argument must first be <a href="#converted-to-ascii-lowercase">converted to ASCII lowercase</a>.</p><!--if legacycaller is removed:
  <p>In addition to the above, <code>HTMLAllCollection</code> objects, in JavaScript, must be
  callable. Calling such an object must implicitly invoke the index getter with the same
  arguments.</p>
-->
  </div>

  <h5 id="htmlformcontrolscollection"><span class="secno">2.7.2.2</span> HTMLFormControlsCollection</h5>

  <p><code><a href="#htmlformcontrolscollection-0">HTMLFormControlsCollection</a></code>インターフェースは、<code><a href="forms.html#the-form-element">form</a></code>と<code><a href="forms.html#the-fieldset-element">fieldset</a></code>要素で<a data-anolis-xref="category-listed" href="forms.html#category-listed">記載要素</a>の<a href="#collections-0">コレクション</a>に使用される。</p>
  <pre class="idl">
interface <dfn id="htmlformcontrolscollection-0">HTMLFormControlsCollection</dfn> : <a href="#htmlcollection">HTMLCollection</a> {
  // inherits <span data-anolis-xref="dom-HTMLCollection-length">length</span> and <a data-anolis-xref="dom-HTMLCollection-item" href="#dom-htmlcollection-item">item</a>()
  legacycaller getter (<a href="#radionodelist">RadioNodeList</a> or <a href="#element">Element</a>)? <a data-anolis-xref="dom-HTMLFormControlsCollection-namedItem" href="#dom-htmlformcontrolscollection-nameditem">namedItem</a>(DOMString name); // shadows inherited namedItem()
};

interface <dfn id="radionodelist">RadioNodeList</dfn> : <a href="#nodelist">NodeList</a> {
          attribute DOMString <a data-anolis-xref="dom-RadioNodeList-value" href="#dom-radionodelist-value">value</a>;
};
</pre>

  <dl class="domintro">
    <dt><var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLCollection-length">length</code></dt>

    <dd>
      <p>コレクションの要素数を返す。</p>
    </dd>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLCollection-item"><a href="#dom-htmlcollection-item">item</a></code>(<var data-anolis-xref="">index</var>)</dt>

    <dt><var data-anolis-xref="">collection</var>[<var data-anolis-xref="">index</var>]</dt>

    <dd>
      <p>コレクションからのインデックス<var data-anolis-xref="">index</var>とともにアイテムを返す。アイテムは<a href="#tree-order">ツリー順</a>にソートされる。</p>
    </dd>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLFormControlsCollection-namedItem"><a href="#dom-htmlformcontrolscollection-nameditem">namedItem</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">radioNodeList</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLFormControlsCollection-namedItem"><a href="#dom-htmlformcontrolscollection-nameditem">namedItem</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">collection</var>[<var data-anolis-xref="">name</var>]</dt>

    <dt><var data-anolis-xref="">collection</var>(<var data-anolis-xref="">name</var>)</dt>

    <dd>
      <p>コレクションからの<a data-anolis-xref="concept-id" href="#concept-id">ID</a>または<code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> <var data-anolis-xref="">name</var>とともにアイテムを返す。</p>

      <p>複数のマッチするアイテムが存在する場合、それらの要素すべてを含む<code><a href="#radionodelist">RadioNodeList</a></code>オブジェクトが返される。</p>
    </dd>

    <dt><var data-anolis-xref="">radioNodeList</var> . <var data-anolis-xref="">value</var> [ = <var data-anolis-xref="">value</var> ]</dt>

    <dd>
      <p>オブジェクトによって表される最初にチェックされたラジオボタンの値を返す。</p>

      <p>設定される場合、オブジェクトによって表される与えられた値を持つ最初のラジオボタンをチェックする。</p>
    </dd>
  </dl>

  <div class="impl">
    <p>The object's <a href="#supported-property-indices">supported property indices</a> are as defined for <code><a href="#htmlcollection">HTMLCollection</a></code> objects.</p>

    <p>The <a href="#supported-property-names">supported property names</a> consist of the non-empty values of all the <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> and <code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> attributes of all the elements <a href="#represented-by-the-collection">represented by the collection</a>, in <a href="#tree-order">tree order</a>, ignoring later duplicates, with the <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> of an element preceding its <code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.</p>

    <p>The <dfn data-anolis-xref="dom-HTMLFormControlsCollection-namedItem" id="dom-htmlformcontrolscollection-nameditem"><code>namedItem(<var data-anolis-xref="">name</var>)</code></dfn> method must act according to the following algorithm:</p>

    <ol>
      <li>If <var data-anolis-xref="">name</var> is the empty string, return null and stop the algorithm.</li>

      <li>If, at the time the method is called, there is exactly one node in the collection that has either an <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute or a <code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> attribute equal to <var data-anolis-xref="">name</var>, then return that node and stop the algorithm.</li>

      <li>Otherwise, if there are no nodes in the collection that have either an <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute or a <code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> attribute equal to <var data-anolis-xref="">name</var>, then return null and stop the algorithm.</li>

      <li>Otherwise, create a new <code><a href="#radionodelist">RadioNodeList</a></code> object representing a <a href="#live">live</a> view of the <code><a href="#htmlformcontrolscollection-0">HTMLFormControlsCollection</a></code> object, further filtered so that the only nodes in the <code><a href="#radionodelist">RadioNodeList</a></code> object are those that have either an <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute or a <code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> attribute equal to <var data-anolis-xref="">name</var>. The nodes in the <code><a href="#radionodelist">RadioNodeList</a></code> object must be sorted in <a href="#tree-order">tree order</a>.
      </li>

      <li>Return that <code><a href="#radionodelist">RadioNodeList</a></code> object.</li>
    </ol>
    <hr>

    <p>Members of the <code><a href="#radionodelist">RadioNodeList</a></code> interface inherited from the <code><a href="#nodelist">NodeList</a></code> interface must behave as they would on a <code><a href="#nodelist">NodeList</a></code> object.</p>

    <p>The <dfn data-anolis-xref="dom-RadioNodeList-value" id="dom-radionodelist-value"><code>value</code></dfn> IDL attribute on the <code><a href="#radionodelist">RadioNodeList</a></code> object, on getting, must return the value returned by running the following steps:</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">element</var> be the first element in <a href="#tree-order">tree order</a> represented by the <code><a href="#radionodelist">RadioNodeList</a></code> object that is an <code><a href="forms.html#the-input-element">input</a></code> element whose <code data-anolis-xref="attr-input-type"><a href="forms.html#attr-input-type">type</a></code> attribute is in the <a data-anolis-xref="attr-input-type-radio" href="forms.html#radio-button-state-(type=radio)">Radio Button</a> state and whose <a data-anolis-xref="concept-fe-checked" href="forms.html#concept-fe-checked">checkedness</a> is true. Otherwise, let it be null.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">element</var> is null, or if it is an element with no <code data-anolis-xref="attr-input-value"><a href="forms.html#attr-input-value">value</a></code> attribute, return the empty string.</p>
      </li>

      <li>
        <p>Otherwise, return the value of <var data-anolis-xref="">element</var>'s <code data-anolis-xref="attr-input-value"><a href="forms.html#attr-input-value">value</a></code> attribute.</p>
      </li>
    </ol>

    <p>On setting, the <code data-anolis-xref="dom-RadioNodeList-value"><a href="#dom-radionodelist-value">value</a></code> IDL attribute must run the following steps:</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">element</var> be the first element in <a href="#tree-order">tree order</a> represented by the <code><a href="#radionodelist">RadioNodeList</a></code> object that is an <code><a href="forms.html#the-input-element">input</a></code> element whose <code data-anolis-xref="attr-input-type"><a href="forms.html#attr-input-type">type</a></code> attribute is in the <a data-anolis-xref="attr-input-type-radio" href="forms.html#radio-button-state-(type=radio)">Radio Button</a> state and whose <code data-anolis-xref="attr-input-value"><a href="forms.html#attr-input-value">value</a></code> content attribute is present and equal to the new value, if any. Otherwise, let it be null.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">element</var> is not null, then set its <a data-anolis-xref="concept-fe-checked" href="forms.html#concept-fe-checked">checkedness</a> to true.</p>
      </li>
    </ol><!--
http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C%21DOCTYPE%20html%3E...%0A%3Cform%20name%3D%22a%22%3E%3Cinput%20id%3D%22x%22%20name%3D%22y%22%3E%3Cinput%20name%3D%22x%22%20id%3D%22y%22%3E%3C/form%3E%0A%3Cscript%3E%0A%20%20var%20x%3B%0A%20%20w%28x%20%3D%20document.forms%5B%27a%27%5D%5B%27x%27%5D%29%3B%0A%20%20w%28x.length%29%3B%0A%20%20x%5B0%5D.parentNode.removeChild%28x%5B0%5D%29%3B%0A%20%20w%28x.length%29%3B%0A%20%20w%28x%20%3D%3D%20document.forms%5B%27a%27%5D%5B%27x%27%5D%29%3B%0A%3C/script%3E%0A
-->
  </div>

  <h5 id="htmloptionscollection"><span class="secno">2.7.2.3</span> HTMLOptionsCollection</h5>

  <p><code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code>インターフェースは、<code><a href="forms.html#the-option-element">option</a></code>要素の<a href="#collections-0">コレクション</a>に使用される。常に<code><a href="forms.html#the-select-element">select</a></code>要素がルートであり、要素の子孫をコントロールする属性およびメソッドを持つ。</p>
  <pre class="idl">
interface <dfn id="htmloptionscollection-0">HTMLOptionsCollection</dfn> : <a href="#htmlcollection">HTMLCollection</a> {
  // inherits <a data-anolis-xref="dom-HTMLCollection-item" href="#dom-htmlcollection-item">item</a>()
           attribute unsigned long <a data-anolis-xref="dom-HTMLOptionsCollection-length" href="#dom-htmloptionscollection-length">length</a>; // shadows inherited length
  <a data-anolis-xref="dom-HTMLOptionsCollection-namedItem" href="#dom-htmloptionscollection-nameditem">legacycaller</a> <a href="forms.html#htmloptionelement">HTMLOptionElement</a>? (DOMString name);
  <a data-anolis-xref="dom-HTMLOptionsCollection-setter" href="#dom-htmloptionscollection-setter">setter creator</a> void (unsigned long index, <a href="forms.html#htmloptionelement">HTMLOptionElement</a>? option);
  void <a data-anolis-xref="dom-HTMLOptionsCollection-add" href="#dom-htmloptionscollection-add">add</a>((<a href="forms.html#htmloptionelement">HTMLOptionElement</a> or <a href="forms.html#htmloptgroupelement">HTMLOptGroupElement</a>) element, optional (<a href="dom.html#htmlelement">HTMLElement</a> or long)? before = null);
  void <a data-anolis-xref="dom-HTMLOptionsCollection-remove" href="#dom-htmloptionscollection-remove">remove</a>(long index);
           attribute long <a data-anolis-xref="dom-HTMLOptionsCollection-selectedIndex" href="#dom-htmloptionscollection-selectedindex">selectedIndex</a>;
};
</pre>

  <dl class="domintro">
    <dt><var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLOptionsCollection-length"><a href="#dom-htmloptionscollection-length">length</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

    <dd>
      <p>コレクションの要素数を返す。</p>

      <p>より小さい数に設定する場合、対応するコンテナ内の<code><a href="forms.html#the-option-element">option</a></code>要素数は切り捨てられる。</p>

      <p>より大きい数に設定する場合、そのコンテナに新しい空白の<code><a href="forms.html#the-option-element">option</a></code>要素を追加する。</p>
    </dd>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLCollection-item"><a href="#dom-htmlcollection-item">item</a></code>(<var data-anolis-xref="">index</var>)</dt>

    <dt><var data-anolis-xref="">collection</var>[<var data-anolis-xref="">index</var>]</dt>

    <dd>
      <p>コレクションからのインデックス<var data-anolis-xref="">index</var>とともにアイテムを返す。アイテムは<a href="#tree-order">ツリー順</a>にソートされる。</p>
    </dd>

    <dt><var data-anolis-xref="">element</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLOptionsCollection-namedItem"><a href="#dom-htmloptionscollection-nameditem">namedItem</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">nodeList</var> = <var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLOptionsCollection-namedItem"><a href="#dom-htmloptionscollection-nameditem">namedItem</a></code>(<var data-anolis-xref="">name</var>)</dt>

    <dt><var data-anolis-xref="">collection</var>[<var data-anolis-xref="">name</var>]</dt>

    <dt><var data-anolis-xref="">collection</var>(<var data-anolis-xref="">name</var>)</dt>

    <dd>
      <p>コレクションからの<a data-anolis-xref="concept-id" href="#concept-id">ID</a>または<code data-anolis-xref="attr-option-name"><a href="obsolete.html#attr-option-name">name</a></code> <var data-anolis-xref="">name</var>とともにアイテムを返す。</p>

      <p>複数のマッチするアイテムが存在する場合、最初のものが返される。</p>
    </dd>

    <dt><var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLOptionsCollection-add"><a href="#dom-htmloptionscollection-add">add</a></code>(<var data-anolis-xref="">element</var> [, <var data-anolis-xref="">before</var> ] )</dt>

    <dd>
      <p><var data-anolis-xref="">before</var>によって与えられるノードの前の<var data-anolis-xref="">要素</var>を挿入する。</p>

      <p><var data-anolis-xref="">before</var>引数は数字でもよく、その場合<var data-anolis-xref="">element</var>はその数字をもつアイテムの前に挿入され、またはコレクションからの要素でもよい。その場合<var data-anolis-xref="">element</var>はその要素の前に挿入される。</p>

      <p><var data-anolis-xref="">before</var>が省略された、null、または範囲外の数字の場合、<var data-anolis-xref="">element</var>はリストの最後に加えられるだろう。</p>

      <p><var data-anolis-xref="">要素</var>に挿入された要素が親要素の場合、このメソッドは<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>例外を投げるだろう。</p>
    </dd>

    <dt><var data-anolis-xref="">collection</var> . <code data-anolis-xref="dom-HTMLOptionsCollection-selectedIndex"><a href="#dom-htmloptionscollection-selectedindex">selectedIndex</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

    <dd>
      <p>もしあるならば、最初に選ばれたアイテムのインデックスを、または選択したアイテムが存在しない場合−1を返す。</p>

      <p>選択を変更する設定が可能である。</p>
    </dd>
  </dl>

  <div class="impl">
    <p>The object's <a href="#supported-property-indices">supported property indices</a> are as defined for <code><a href="#htmlcollection">HTMLCollection</a></code> objects.</p>

    <p>On getting, the <dfn data-anolis-xref="dom-HTMLOptionsCollection-length" id="dom-htmloptionscollection-length"><code>length</code></dfn> attribute must return the number of nodes <a href="#represented-by-the-collection">represented by the collection</a>.</p>

    <p>On setting, the behavior depends on whether the new value is equal to, greater than, or less than the number of nodes <a href="#represented-by-the-collection">represented by the collection</a> at that time. If the number is the same, then setting the attribute must do nothing. If the new value is greater, then <var data-anolis-xref="">n</var> new <code><a href="forms.html#the-option-element">option</a></code> elements with no attributes and no child nodes must be appended to the <code><a href="forms.html#the-select-element">select</a></code> element on which the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> is rooted, where <var data-anolis-xref="">n</var> is the difference between the two numbers (new value minus old value). Mutation events must be fired as if a <code><a href="#documentfragment">DocumentFragment</a></code> containing the new <code><a href="forms.html#the-option-element">option</a></code> elements had been inserted. If the new value is lower, then the last <var data-anolis-xref="">n</var> nodes in the collection must be removed from their parent nodes, where <var data-anolis-xref="">n</var> is the difference between the two numbers (old value minus new value).</p>

    <p class="note">Setting <code data-anolis-xref="dom-HTMLOptionsCollection-length"><a href="#dom-htmloptionscollection-length">length</a></code> never removes or adds any <code><a href="forms.html#the-optgroup-element">optgroup</a></code> elements, and never adds new children to existing <code><a href="forms.html#the-optgroup-element">optgroup</a></code> elements (though it can remove children from them).</p>

    <p>The <a href="#supported-property-names">supported property names</a> consist of the non-empty values of all the <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> and <code data-anolis-xref="attr-option-name"><a href="obsolete.html#attr-option-name">name</a></code> attributes of all the elements <a href="#represented-by-the-collection">represented by the collection</a>, in <a href="#tree-order">tree order</a>, ignoring later duplicates, with the <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> of an element preceding its <code data-anolis-xref="attr-option-name"><a href="obsolete.html#attr-option-name">name</a></code> if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.</p>

    <p>The <dfn data-anolis-xref="dom-HTMLOptionsCollection-namedItem" id="dom-htmloptionscollection-nameditem">legacy caller</dfn> of the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> interface must act like the <code data-anolis-xref="dom-HTMLCollection-namedItem">namedItem()</code> method on the ancestor <code><a href="#htmlcollection">HTMLCollection</a></code> interface.</p>

    <p>When the user agent is to <dfn data-anolis-xref="dom-HTMLOptionsCollection-setter" id="dom-htmloptionscollection-setter">set the value of a new indexed property or set the value of an existing indexed property</dfn> for a given property index <var data-anolis-xref="">index</var> to a new value <var data-anolis-xref="">value</var>, it must run the following algorithm:</p>

    <ol>
      <li>
        <p>If <var data-anolis-xref="">value</var> is null, invoke the steps for the <code data-anolis-xref="dom-HTMLOptionsCollection-remove"><a href="#dom-htmloptionscollection-remove">remove</a></code> method with <var data-anolis-xref="">index</var> as the argument, and abort these steps.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">length</var> be the number of nodes <a href="#represented-by-the-collection">represented by the collection</a>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">n</var> be <var data-anolis-xref="">index</var> minus <var data-anolis-xref="">length</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">n</var> is greater than zero, then <a data-anolis-xref="concept-node-append" href="#concept-node-append">append</a> a <code><a href="#documentfragment">DocumentFragment</a></code> consisting of <span data-anolis-xref=""><var data-anolis-xref="">n</var>-1</span> new <code><a href="forms.html#the-option-element">option</a></code> elements with no attributes and no child nodes to the <code><a href="forms.html#the-select-element">select</a></code> element on which the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> is rooted.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">n</var> is greater than or equal to zero, <a data-anolis-xref="concept-node-append" href="#concept-node-append">append</a> <var data-anolis-xref="">value</var> to the <code><a href="forms.html#the-select-element">select</a></code> element. Otherwise, <a data-anolis-xref="concept-node-replace" href="#concept-node-replace">replace</a> the <var data-anolis-xref="">index</var>th element in the collection by <var data-anolis-xref="">value</var>.</p>
      </li>
    </ol>

    <p>The <dfn data-anolis-xref="dom-HTMLOptionsCollection-add" id="dom-htmloptionscollection-add"><code>add(<var data-anolis-xref="">element</var>, <var data-anolis-xref="">before</var>)</code></dfn> method must act according to the following algorithm:</p>

    <ol>
      <li>
        <p>If <var data-anolis-xref="">element</var> is an ancestor of the <code><a href="forms.html#the-select-element">select</a></code> element on which the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> is rooted, then throw a <code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code> exception and abort these steps.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">before</var> is an element, but that element isn't a descendant of the <code><a href="forms.html#the-select-element">select</a></code> element on which the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> is rooted, then throw a <code><a href="#notfounderror">NotFoundError</a></code> exception and abort these steps.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">element</var> and <var data-anolis-xref="">before</var> are the same element, then return and abort these steps.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">before</var> is a node, then let <var data-anolis-xref="">reference</var> be that node. Otherwise, if <var data-anolis-xref="">before</var> is an integer, and there is a <var data-anolis-xref="">before</var>th node in the collection, let <var data-anolis-xref="">reference</var> be that node. Otherwise, let <var data-anolis-xref="">reference</var> be null.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">reference</var> is not null, let <var data-anolis-xref="">parent</var> be the parent node of <var data-anolis-xref="">reference</var>. Otherwise, let <var data-anolis-xref="">parent</var> be the <code><a href="forms.html#the-select-element">select</a></code> element on which the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> is rooted.</p>
      </li>

      <li>
        <p>Act as if the DOM <code data-anolis-xref="dom-Node-insertBefore"><a href="#dom-node-insertbefore">insertBefore()</a></code> method was invoked on the <var data-anolis-xref="">parent</var> node, with <var data-anolis-xref="">element</var> as the first argument and <var data-anolis-xref="">reference</var> as the second argument.</p>
      </li>
    </ol>

    <p>The <dfn data-anolis-xref="dom-HTMLOptionsCollection-remove" id="dom-htmloptionscollection-remove"><code>remove(<var data-anolis-xref="">index</var>)</code></dfn> method must act according to the following algorithm:</p>

    <ol>
      <li>
        <p>If the number of nodes <a href="#represented-by-the-collection">represented by the collection</a> is zero, abort these steps.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">index</var> is not a number greater than or equal to 0 and less than the number of nodes <a href="#represented-by-the-collection">represented by the collection</a>, abort these steps.</p>
      </li><!-- note that Web IDL converts 'a', NaN, -0.5, 0.5, and null to 0, and numbers in general
   truncate. so what we're checking against here in a way has very little to do with what's going on
   in the JS -->

      <li>
        <p>Let <var data-anolis-xref="">element</var> be the <var data-anolis-xref="">index</var>th element in the collection.</p>
      </li>

      <li>
        <p>Remove <var data-anolis-xref="">element</var> from its parent node.</p>
      </li>
    </ol>

    <p>The <dfn data-anolis-xref="dom-HTMLOptionsCollection-selectedIndex" id="dom-htmloptionscollection-selectedindex"><code>selectedIndex</code></dfn> IDL attribute must act like the identically named attribute on the <code><a href="forms.html#the-select-element">select</a></code> element on which the <code><a href="#htmloptionscollection-0">HTMLOptionsCollection</a></code> is rooted</p><!-- see also http://ln.hixie.ch/?start=1161042744&count=1 -->
  </div><!--MD--><!--TOPIC:DOM APIs-->

  <h4 id="domstringmap"><span class="secno">2.7.3</span> DOMStringMap</h4>

  <p><code><a href="#domstringmap-0">DOMStringMap</a></code>インターフェースは、名前と値のペアの組を表す。これは、プロパティーのアクセスのためにスクリプト言語のネイティヴメカニズムを使用して、ペアの組を公開する。</p>

  <div class="impl">
    <p>When a <code><a href="#domstringmap-0">DOMStringMap</a></code> object is instantiated, it is associated with three algorithms, one for getting the list of name-value pairs, one for setting names to certain values, and one for deleting names.</p>
    <pre class="idl">
[OverrideBuiltins]
interface <dfn id="domstringmap-0">DOMStringMap</dfn> {
  <a data-anolis-xref="dom-DOMStringMap-namedItem" href="#dom-domstringmap-nameditem">getter</a> DOMString (DOMString name);
  <a data-anolis-xref="dom-DOMStringMap-setItem" href="#dom-domstringmap-setitem">setter</a> <a data-anolis-xref="dom-DOMStringMap-addItem" href="#dom-domstringmap-additem">creator</a> void (DOMString name, DOMString value);
  <a data-anolis-xref="dom-DOMStringMap-removeItem" href="#dom-domstringmap-removeitem">deleter</a> void (DOMString name);
};
</pre>

    <p>The <a href="#supported-property-names">supported property names</a> on a <code><a href="#domstringmap-0">DOMStringMap</a></code> object at any instant are the names of each pair returned from the algorithm for getting the list of name-value pairs at that instant, in the order returned.</p>

    <p>To <dfn data-anolis-xref="dom-DOMStringMap-namedItem" id="dom-domstringmap-nameditem">determine the value of a named property</dfn> <var data-anolis-xref="">name</var> in a <code><a href="#domstringmap-0">DOMStringMap</a></code>, the user agent must return the value component of the name-value pair whose name component is <var data-anolis-xref="">name</var> in the list returned by the algorithm for getting the list of name-value pairs.</p>

    <p>To set the value of a <dfn data-anolis-xref="dom-DOMStringMap-addItem" id="dom-domstringmap-additem">new</dfn> or <dfn data-anolis-xref="dom-DOMStringMap-setItem" id="dom-domstringmap-setitem">existing</dfn> named property <var data-anolis-xref="">name</var> to value <var data-anolis-xref="">value</var>, the algorithm for setting names to certain values must be run, passing <var data-anolis-xref="">name</var> as the name and the result of converting <var data-anolis-xref="">value</var> to a <code>DOMString</code> as the value.</p>

    <p>To <dfn data-anolis-xref="dom-DOMStringMap-removeItem" id="dom-domstringmap-removeitem">delete an existing named property</dfn> <var data-anolis-xref="">name</var>, the algorithm for deleting names must be run, passing <var data-anolis-xref="">name</var> as the name.</p>

    <p class="note">The <code><a href="#domstringmap-0">DOMStringMap</a></code> interface definition here is only intended for JavaScript environments. Other language bindings will need to define how <code><a href="#domstringmap-0">DOMStringMap</a></code> is to be implemented for those languages.</p>
  </div>

  <div class="example">
    <p>要素の<code data-anolis-xref="dom-dataset"><a href="dom.html#dom-dataset">dataset</a></code>属性は、要素の<code data-anolis-xref="attr-data-*"><a href="dom.html#attr-data-*">data-*</a></code>属性を公開する。</p>

    <p>類似の構造とともに以下の引数および要素が与えられるとする：</p>
    <pre>
&lt;img class="tower" id="tower5" data-<!---->x="12" data-y="5"
     data-ai="robotarget" data-hp="46" data-ability="flames"
     src="towers/rocket.png alt="Rocket Tower"&gt;
</pre>

    <p>1つは関数<code data-anolis-xref="">splashDamage()</code>がいくつかの引数を取ることが考えられ、第1引数は処理する要素となる：</p>
    <pre>
function splashDamage(node, x, y, damage) {
  if (node.classList.contains('tower') &amp;&amp; // checking the 'class' attribute
      node.dataset.x == x &amp;&amp; // reading the 'data-x' attribute
      node.dataset.y == y) { // reading the 'data-y' attribute
    var hp = parseInt(node.dataset.hp); // reading the 'data-hp' attribute
    hp = hp - damage;
    if (hp &lt; 0) {
      hp = 0;
      node.dataset.ai = 'dead'; // setting the 'data-ai' attribute
      delete node.dataset.ability; // removing the 'data-ability' attribute
    }
    node.dataset.hp = hp; // setting the 'data-hp' attribute
  }
}
</pre>
  </div>

  <h4 id="transferable-objects"><span class="secno">2.7.4</span> 譲渡可能オブジェクト</h4>

  <p>一部のオブジェクトは、ある操作でコピーおよびクローズされることをサポートする。これはオブジェクトを<i>譲渡可能</i>と呼び、特に共有不可の所有権またはワーカーの境界を越えて高価なリソースを移転することに使用される。</p>

  <p>以下は<code><a href="#transferable">Transferable</a></code>型である：</p>

  <ul class="brief">
    <li>
      <code><a href="#arraybuffer">ArrayBuffer</a></code> <a href="references.html#refsTYPEDARRAY">[TYPEDARRAY]</a>
    </li>

    <li><code><a href="#messageport">MessagePort</a></code></li>
  </ul>

  <div class="impl">
    <p>The following IDL block formalizes this:</p>
    <pre class="idl">
[NoInterfaceObject]
interface <dfn id="transferable">Transferable</dfn> { };
<a href="#arraybuffer">ArrayBuffer</a> implements <a href="#transferable">Transferable</a>;
<a href="#messageport">MessagePort</a> implements <a href="#transferable">Transferable</a>;
</pre>

    <p>To <dfn id="transfer-a-transferable-object">transfer a <code>Transferable</code> object</dfn> to a new owner, the user agent must run the steps defined for the type of object in question. The steps will return a new object of the same type, and will permanently <dfn data-anolis-xref="concept-Transferable-neutered" id="concept-transferable-neutered">neuter</dfn> the original object. (This is an irreversible and non-idempotent operation; once an object has been transferred, it cannot be transferred, or indeed used, again.)</p>

    <p id="transferArrayBuffer">To <a data-anolis-xref="transfer a Transferable object" href="#transfer-a-transferable-object">transfer</a> an <code><a href="#arraybuffer">ArrayBuffer</a></code> object <var data-anolis-xref="">old</var> to a new owner <var data-anolis-xref="">owner</var>, a user agent must create a new <code><a href="#arraybuffer">ArrayBuffer</a></code> object pointing at the same underlying data as <var data-anolis-xref="">old</var>, thus obtaining <var data-anolis-xref="">new</var>, must <a data-anolis-xref="concept-Transferable-neutered" href="#concept-transferable-neutered">neuter</a> the <var data-anolis-xref="">old</var> object, and must finally return <var data-anolis-xref="">new</var>. <a href="references.html#refsTYPEDARRAY">[TYPEDARRAY]</a></p>

    <p class="note">Rules for how to <a href="references.html#refsWEBMSG">transfer a <code>MessagePort</code> object</a> are given in the relevant sections of this specification.</p>
  </div>

  <div class="impl">
    <h4 id="safe-passing-of-structured-data"><span class="secno">2.7.5</span> Safe passing of structured data</h4>

    <p>When a user agent is required to obtain a <dfn id="structured-clone">structured clone</dfn> of a value, optionally with a <i>transfer map</i>, it must run the following algorithm, which either returns a separate value, or throws an exception. If a <i>transfer map</i> is provided, it consists of an association list of <code><a href="#transferable">Transferable</a></code> objects to placeholder objects.</p>

    <ol>
      <li>
        <p>Let <var data-anolis-xref="">input</var> be the value being cloned.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">transfer map</var> be the <i>transfer map</i> passed to the algorithm, if any, or the empty list otherwise.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">memory</var> be an association list of pairs of objects, initially empty. This is used to handle duplicate references. In each pair of objects, one is called the <em><a href="embedded-content-0.html#the-source-element">source</a></em> object and the other the <em>destination</em> object.</p>
      </li>

      <li>
        <p>For each mapping in <var data-anolis-xref="">transfer map</var>, add a mapping from the <code><a href="#transferable">Transferable</a></code> object (the source object) to the placeholder object (the destination object) to <var data-anolis-xref="">memory</var>.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">output</var> be the value resulting from calling the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> with <var data-anolis-xref="">input</var> as the "<var data-anolis-xref="">input</var>" argument, and <var data-anolis-xref="">memory</var> as the "<var data-anolis-xref="">memory</var>" argument.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">output</var>.</p>
      </li>
    </ol>

    <p>The <dfn id="internal-structured-cloning-algorithm">internal structured cloning algorithm</dfn> is always called with two arguments, <var data-anolis-xref="">input</var> and <var data-anolis-xref="">memory</var>, and its behavior is as follows:</p>

    <ol>
      <li>
        <p>If <var data-anolis-xref="">input</var> is the source object of a pair of objects in <var data-anolis-xref="">memory</var>, then return the destination object in that pair of objects and abort these steps.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">input</var> is a primitive value, then return that value and abort these steps.</p>
      </li>

      <li>
        <p>Let <var data-anolis-xref="">deep clone</var> be <i>none</i>.</p>
      </li>

      <li>
        <p>The <var data-anolis-xref="">input</var> value is an object. Jump to the appropriate step below:</p>

        <dl class="switch">
          <dt>If <var data-anolis-xref="">input</var> is a <code>Boolean</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed Boolean object with the same value as <var data-anolis-xref="">input</var>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code>Number</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed Number object with the same value as <var data-anolis-xref="">input</var>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code>String</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed String object with the same value as <var data-anolis-xref="">input</var>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code>Date</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed <code>Date</code> object with the same value as <var data-anolis-xref="">input</var>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code>RegExp</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed <code>RegExp</code> object with the same pattern and flags as <var data-anolis-xref="">input</var>.</p>

            <p class="note">The value of the <code data-anolis-xref="">lastIndex</code> property is not copied.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code><a href="#blob">Blob</a></code> object</dt>

          <dd>
            <p></p>

            <p>If <var data-anolis-xref="">input</var> has been disabled through the <code data-anolis-xref="dom-Blob-close"><a href="#dom-blob-close">close()</a></code> method, throw a <code><a href="#datacloneerror">DataCloneError</a></code> exception and abort the overall <a href="#structured-clone">structured clone</a> algorithm. Otherwise, let <var data-anolis-xref="">output</var> be a newly constructed object of the same class as <var data-anolis-xref="">input</var>, corresponding to the same underlying data.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code><a href="#filelist">FileList</a></code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed <code><a href="#filelist">FileList</a></code> object containing a list of newly constructed <code><a href="#file">File</a></code> objects corresponding to the same underlying data as those in <var data-anolis-xref="">input</var>, maintaining their relative order.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is an <code>ImageData</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed <code>ImageData</code> object whose <code data-anolis-xref="dom-imagedata-width">width</code>, <code data-anolis-xref="dom-imagedata-height">height</code>, and <code data-anolis-xref="dom-imagedata-resolution">resolution</code> attributes have values equal to the corresponding attributes on <var data-anolis-xref="">input</var>, and whose <code data-anolis-xref="dom-imagedata-data">data</code> attribute has the value obtained from invoking the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> recursively with the value of the <code data-anolis-xref="dom-imagedata-data">data</code> attribute on <var data-anolis-xref="">input</var> as the new "<var data-anolis-xref="">input</var>" argument and <var data-anolis-xref="">memory</var> as the new "<var data-anolis-xref="">memory</var>" argument.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is an <code><a href="#arraybuffer">ArrayBuffer</a></code> object</dt><!--CLEANUP-->

          <dd>
            <p>If <var data-anolis-xref="">input</var> has been <a data-anolis-xref="concept-Transferable-neutered" href="#concept-transferable-neutered">neutered</a>, throw a <code><a href="#datacloneerror">DataCloneError</a></code> exception and abort the overall <a href="#structured-clone">structured clone</a> algorithm. Otherwise, let <var data-anolis-xref="">output</var> be a newly constructed <code><a href="#arraybuffer">ArrayBuffer</a></code> object whose contents are a copy of <var data-anolis-xref="">input</var>'s contents, with the same length.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is an <code><a href="#arraybufferview">ArrayBufferView</a></code> object</dt>

          <dd>
            <!--CLEANUP-->

            <p>Let <var data-anolis-xref="">output</var> be a newly constructed object of the same class as <var data-anolis-xref="">input</var>, with each IDL attribute defined for that class being set to the value obtained from invoking the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> recursively with the value of the attribute on <var data-anolis-xref="">input</var> as the new "<var data-anolis-xref="">input</var>" argument and <var data-anolis-xref="">memory</var> as the new "<var data-anolis-xref="">memory</var>" argument.</p>

            <p class="note">Only IDL attributes defined on the class (including the <code><a href="#arraybufferview">ArrayBufferView</a></code> attributes) are cloned. Properties added by a script, for example, are not cloned.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is an <code>Array</code> object</dt>

          <dd>
            <!--CLEANUP-->

            <p>Let <var data-anolis-xref="">output</var> be a newly constructed empty <code>Array</code> object whose <code data-anolis-xref="">length</code> is equal to the <code data-anolis-xref="">length</code> of <var data-anolis-xref="">input</var>, and set <var data-anolis-xref="">deep clone</var> to <i>own</i>.</p>

            <p class="note">This means that the length of sparse arrays is preserved.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is an <code data-anolis-xref="">Object</code> object</dt><!--CLEANUP-->

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed empty <code data-anolis-xref="">Object</code> object, and set <var data-anolis-xref="">deep clone</var> to <i>own</i>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code><a href="embedded-content-0.html#the-map-element">Map</a></code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed empty <code data-anolis-xref="">Map</code> object, and set <var data-anolis-xref="">deep clone</var> to <i><a href="embedded-content-0.html#the-map-element">map</a></i>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is a <code>Set</code> object</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a newly constructed empty <code data-anolis-xref="">Set</code> object, and set <var data-anolis-xref="">deep clone</var> to <i>set</i>.</p>
          </dd>

          <dt>If <var data-anolis-xref="">input</var> is an object that another specification defines how to clone</dt>

          <dd>
            <p>Let <var data-anolis-xref="">output</var> be a clone of the object as defined by the other specification.</p>
          </dd><!--CLEANUP-->

          <dt>If <var data-anolis-xref="">input</var> is another native object type (e.g. <code>Error</code>, <code>Function</code>)</dt>

          <dt>If <var data-anolis-xref="">input</var> is a host object (e.g. a DOM node)</dt>

          <dd>
            <p>Throw a <code><a href="#datacloneerror">DataCloneError</a></code> exception and abort the overall <a href="#structured-clone">structured clone</a> algorithm.</p>
          </dd>
        </dl>

        <p>For the purposes of the algorithm above, an object is a particular type of object <var data-anolis-xref="">class</var> if its [[Class]] internal property is equal to <var data-anolis-xref="">class</var>.</p><!--CLEANUP-->

        <p class="example">For example, "<var data-anolis-xref="">input</var> is an <code data-anolis-xref="">Object</code> object" if <var data-anolis-xref="">input</var>'s [[Class]] internal property is equal to the string "<code data-anolis-xref="">Object</code>".</p>
      </li>

      <li>
        <p>Add a mapping from <var data-anolis-xref="">input</var> (the source object) to <var data-anolis-xref="">output</var> (the destination object) to <var data-anolis-xref="">memory</var>.</p>
      </li>

      <li>
        <p>If <var data-anolis-xref="">deep clone</var> is set to <i><a href="embedded-content-0.html#the-map-element">map</a></i>, then run these substeps. These substeps use the terminology and typographic conventions used in the JavaScript specification's definition of Maps. <a href="references.html#refsECMA262">[ECMA262]</a></p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">source</var> be the List that is the value of <var data-anolis-xref="">input</var>'s [[MapData]] internal slot, if any. If there is no such slot, then instead throw a <code><a href="#datacloneerror">DataCloneError</a></code> exception and abort the overall <a href="#structured-clone">structured clone</a> algorithm. <a href="references.html#refsECMA262">[ECMA262]</a></p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">target</var> be the List that is the value of <var data-anolis-xref="">output</var>'s [[MapData]] internal slot.</p>
          </li>

          <li>
            <p>For each Record {[[key]], [[value]]} <var data-anolis-xref="">entry</var> that is an element of <var data-anolis-xref="">source</var>, run the following substeps:</p>

            <ol>
              <li>
                <p>Let <var data-anolis-xref="">key</var> have the value obtained from invoking the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> recursively with <var data-anolis-xref="">entry</var>.[[key]] as the new "<var data-anolis-xref="">input</var>" argument and <var data-anolis-xref="">memory</var> as the new "<var data-anolis-xref="">memory</var>" argument.</p>
              </li>

              <li>
                <p>Let <var data-anolis-xref="">value</var> have the value obtained from invoking the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> recursively with <var data-anolis-xref="">entry</var>.[[value]] as the new "<var data-anolis-xref="">input</var>" argument and <var data-anolis-xref="">memory</var> as the new "<var data-anolis-xref="">memory</var>" argument.</p>
              </li>

              <li>
                <p>Let <var data-anolis-xref="">new entry</var> be the Record {[[key]]: <var data-anolis-xref="">key</var>, [[value]]: <var data-anolis-xref="">value</var>}.</p>
              </li>

              <li>
                <p>Append <var data-anolis-xref="">new entry</var> as the last element of <var data-anolis-xref="">target</var>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>Set <var data-anolis-xref="">deep clone</var> to <i>own</i>.</p>
          </li>
        </ol>
      </li>

      <li>
        <p>If <var data-anolis-xref="">deep clone</var> is set to <i>set</i>, then run these substeps. These substeps use the terminology and typographic conventions used in the JavaScript specification's definition of Sets. <a href="references.html#refsECMA262">[ECMA262]</a></p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">source</var> be the List that is the value of <var data-anolis-xref="">input</var>'s [[SetData]] internal slot, if any. If there is no such slot, then instead throw a <code><a href="#datacloneerror">DataCloneError</a></code> exception and abort the overall <a href="#structured-clone">structured clone</a> algorithm. <a href="references.html#refsECMA262">[ECMA262]</a></p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">target</var> be the List that is the value of <var data-anolis-xref="">output</var>'s [[SetData]] internal slot.</p>
          </li>

          <li>
            <p>For each <var data-anolis-xref="">entry</var> that is an element of <var data-anolis-xref="">source</var> that is not <i>empty</i>, run the following substeps:</p>

            <ol>
              <li>
                <p>Let <var data-anolis-xref="">new entry</var> have the value obtained from invoking the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> recursively with <var data-anolis-xref="">entry</var> as the new "<var data-anolis-xref="">input</var>" argument and <var data-anolis-xref="">memory</var> as the new "<var data-anolis-xref="">memory</var>" argument.</p>
              </li>

              <li>
                <p>Append <var data-anolis-xref="">new entry</var> as the last element of <var data-anolis-xref="">target</var>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>Set <var data-anolis-xref="">deep clone</var> to <i>own</i>.</p>
          </li>
        </ol>
      </li>

      <li>
        <!--CLEANUP-->

        <p>If <var data-anolis-xref="">deep clone</var> is set to <i>own</i>, then, for each enumerable own property in <var data-anolis-xref="">input</var>, run the following steps:</p>

        <ol>
          <li>
            <p>Let <var data-anolis-xref="">name</var> be the name of the property.</p>
          </li><!--CLEANUP-->

          <li>
            <p>Let <var data-anolis-xref="">source value</var> be the result of calling the [[Get]] internal method of <var data-anolis-xref="">input</var> with the argument <var data-anolis-xref="">name</var>. If the [[Get]] internal method of a property involved executing script, and that script threw an uncaught exception, then abort the overall <a href="#structured-clone">structured clone</a> algorithm, with that exception being passed through to the caller.</p>
          </li>

          <li>
            <p>Let <var data-anolis-xref="">cloned value</var> be the result of invoking the <a href="#internal-structured-cloning-algorithm">internal structured cloning algorithm</a> recursively with <var data-anolis-xref="">source value</var> as the "<var data-anolis-xref="">input</var>" argument and <var data-anolis-xref="">memory</var> as the "<var data-anolis-xref="">memory</var>" argument. If this results in an exception, then abort the overall <a href="#structured-clone">structured clone</a> algorithm, with that exception being passed through to the caller.</p>
          </li>

          <li>
            <p>Add a new property to <var data-anolis-xref="">output</var> having the name <var data-anolis-xref="">name</var>, and having the value <var data-anolis-xref="">cloned value</var>.</p>
          </li>
        </ol>

        <p>The order of the properties in the <var data-anolis-xref="">input</var> and <var data-anolis-xref="">output</var> objects must be the same, and any properties whose [[Get]] internal method involves running script must be processed in that same order.</p>

        <p class="note">This does not walk the prototype chain.</p>

        <p class="note">Property descriptors, setters, getters, and analogous features are not copied in this process. For example, the property in the input could be marked as read-only, but in the output it would just have the default state (typically read-write, though that could depend on the scripting environment).</p>

        <p class="note">Properties of Array objects are not treated any differently than those of other Objects. In particular, this means that non-index properties of arrays are copied as well.</p>
      </li>

      <li>
        <p>Return <var data-anolis-xref="">output</var>.</p>
      </li>
    </ol>

    <p class="note">This algorithm preserves cycles and preserves the identity of duplicate objects in graphs.</p>
  </div>

  <h4 id="callbacks"><span class="secno">2.7.6</span> コールバック</h4>

  <p>次のコールバック関数型は、<code><a href="#file">File</a></code>オブジェクトと対話するさまざまなAPIで使用される：</p>
  <pre class="idl">
callback <dfn id="filecallback">FileCallback</dfn> = void (<a href="#file">File</a> file);
</pre>

  <div class="impl">
    <h4 id="garbage-collection"><span class="secno">2.7.7</span> Garbage collection</h4>

    <p>There is an <dfn id="implied-strong-reference">implied strong reference</dfn> from any IDL attribute that returns a pre-existing object to that object.</p>

    <div class="example">
      <p>For example, the <code>document.location</code> attribute means that there is a strong reference from a <code><a href="dom.html#document">Document</a></code> object to its <code><a href="browsers.html#location">Location</a></code> object. Similarly, there is always a strong reference from a <code><a href="dom.html#document">Document</a></code> to any descendant nodes, and from any node to its owner <code><a href="dom.html#document">Document</a></code>.</p>
    </div>
  </div><!--TOPIC:HTML Syntax and Parsing-->

  <h3 id="namespaces"><span class="secno">2.8</span> 名前空間</h3>

  <p><dfn id="html-namespace-0">HTML名前空間</dfn>は<code>http://www.w3.org/1999/xhtml</code>である。</p>

  <p><dfn id="mathml-namespace">MathML名前空間</dfn>は<code>http://www.w3.org/1998/Math/MathML</code>である。</p>

  <p><dfn id="svg-namespace">SVG名前空間</dfn>は<code>http://www.w3.org/2000/svg</code>である。</p>

  <p><dfn id="xlink-namespace">XLink名前空間</dfn>は<code>http://www.w3.org/1999/xlink</code>である。</p>

  <p><dfn id="xml-namespace">XML名前空間</dfn>は<code>http://www.w3.org/XML/1998/namespace</code>である。</p>

  <p><dfn id="xmlns-namespace">XMLNS名前空間</dfn>は<code>http://www.w3.org/2000/xmlns/</code>である。</p>
  <hr>

  <p>データマイニングツールおよび、スクリプトを実行、CSSやXPathを評価、または別の方法で任意のコンテンツにDOMの結果を公開することなく、コンテンツに対する操作を実行するユーザーエージェントは、それらのDOMノードの類似体が実際に上記の文字列を公開することなく、特定の名前空間であることを相応の主張することによって"名前空間をサポート"してもよい。</p>
  <hr>

  <p class="note"><a href="syntax.html#syntax">HTML構文</a>において、名前空間接頭辞および名前空間宣言は、XMLと同一の効果を持たない。たとえば、HTML要素名においてコロンは特別な意味を持たない。</p><!--TOPIC:DOM APIs-->
</body>
</html>