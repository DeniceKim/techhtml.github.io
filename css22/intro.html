<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="ko">
<HEAD>
<TITLE>CSS&nbsp;2.2 소개</TITLE>
<link rel="stylesheet" href="style/default.css" type="text/css">
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2016/W3C-WD.css" type="text/css">
<link rel="stylesheet" href="style/trans.css" type="text/css">
<link rel="prev" href="about.html">
<link rel="next" href="conform.html">
<link rel="contents" href="Overview.html#minitoc">
<link rel="CSS-properties" href="propidx.html" title="properties">
<link rel="index" href="indexlist.html" title="index">
<link rel="first" href="Overview.html">
<script type="text/javascript" src="https://www.w3.org/scripts/TR/2016/fixup.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

</HEAD>
<BODY>
<div class="navbar">
<p><a href="about.html">previous</a> &nbsp;
<a href="conform.html">next</a> &nbsp;
<a href="Overview.html#minitoc">contents</a> &nbsp;
<a href="propidx.html">properties</a> &nbsp;
<a href="indexlist.html">index</a> &nbsp;
</div>
<hr class="navbar">

<H1><a name="q0">2 CSS&nbsp;2.2</a> 소개</H1>
<div id="toc" class="subtoc">
<p><strong>Contents</strong>
  <ul class="toc">
    <li><a href="intro.html#html-tutorial" class="tocxref">2.1 HTML을 위한 간단한 CSS&nbsp;2.2 튜토리얼</a>
    <li><a href="intro.html#xml-tutorial" class="tocxref">2.2 XML을 위한 간단한 CSS&nbsp;2.2 튜토리얼</a>
    <li><a href="intro.html#processing-model" class="tocxref">2.3 CSS&nbsp;2.2 프로세싱 모델</a>
    <ul class="toc">
      <li><a href="intro.html#the-canvas" class="tocxref">2.3.1 캔버스</a>
      <li><a href="intro.html#addressing" class="tocxref">2.3.2 CSS&nbsp;2.2 어드레싱 모델</a>
    </ul>
    <li><a href="intro.html#design-principles" class="tocxref">2.4 CSS 설계 원칙</a>
  </ul>
</div>


<H2>2.1 <a name="html-tutorial">HTML을 위한 간단한 CSS&nbsp;2.2 튜토리얼</a></H2>

<p>This section is non-normative.

<P>
  이 튜토리얼에서, 간단한 스타일 시트를 이용해 얼마나 쉽게 디자인할 수 있는 지 모여줍니다.
  이 튜토리얼을 위해, 당신은 간단한 HTML 지식이 있어야 하며(see <a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span class="informref">[HTML4]</span></a>),
  기본적인 데스크탑 퍼블리싱 용어에 대해 알아야합니다.

<P>작은 HTML 문서로 시작합니다:</p>

<PRE class="html example">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Bach's home page&lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;H1&gt;Bach's home page&lt;/H1&gt;
    &lt;P&gt;Johann Sebastian Bach was a prolific composer.
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>
H1 요소의 텍스트 컬러를 빨강색으로 표현하기 위해, 다음과 같은 CSS 룰을 작성할 수 있습니다:
</P>

<PRE class="example">
  h1 { color: red }
</PRE>

<P>CSS 룰은 두 메인 파트를 가집니다: <a
href="selector.html">셀렉터</a> ('h1') 와 선언
('color:&nbsp;red')입니다.
HTML에서, 요소 이름은 대소문자를 구분하지 않으므로 'h1'은 'H1'과 동일하게 동작합니다.
선언은 두 파트로 나뉩니다:
속성 명('color')과 속성 값 ('red')입니다.

위 예제는 HTML 문서를 렌더링 하기 위해 필요한 속성 중 하나에 영향을 주며, 그 자체가 스타일시트입니다.
다른 스타일 시트와 결합하고(CSS의 근본적인 특징 중 하나는 스타일시트가 합쳐지는 것입니다.),
룰들이 문서의 최종 표시형태를 결정합니다.

<P>
  HTML 4 스펙에서 스타일 시트 룰이 HTML 문서를 위해 어떻게 정의되어야 하는지 정의합니다:
  HTML 문서 내에 포함되거나, 외부 스타일 시트를 사용합니다.
  스타일 시트를 문서 내에 넣기 위해, STYLE 요소를 사용합니다:
</p>

<PRE class="html example">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Bach's home page&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    h1 { color: red }
  &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;H1&gt;Bach's home page&lt;/H1&gt;
    &lt;P&gt;Johann Sebastian Bach was a prolific composer.
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>
  유연성을 최대로 하기 위해, 우리는 작성자가 외부 스타일시트를 정의하기를 권장합니다;
  이 방법을 사용하면 HTML 문서의 수정 없이 변경이 가능하며,
  몇 문서에서 공통으로 공유할 수 있습니다.
  외부 스타일 시트를 연결하기 위해, LINK 요소를 사용할 수 있습니다:
</p>

<PRE class="html example">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Bach's home page&lt;/TITLE&gt;
  &lt;LINK rel="stylesheet" href="bach.css" type="text/css"&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;H1&gt;Bach's home page&lt;/H1&gt;
    &lt;P&gt;Johann Sebastian Bach was a prolific composer.
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>LINK 요소의 정의는:</p>

<ul>
<li>link:의 타입을 "stylesheet"로 정의합니다.
<li>스타일 시트의 위치를 "href" 속성으로 지정합니다.
<li>연결된 스타일 시트의 타입은 "text/css"입니다.
</ul>

<P>
스타일시트와 구조화된 마크업의 밀접한 관계를 나타내기 위해,
우리는 튜토리얼에서 STYLE 요소를 사용합니다.
더 많은 색을 추가해봅시다:

<PRE class="html example">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Bach's home page&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    body { color: black; background: white }
    h1 { color: red; background: white }
  &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;H1&gt;Bach's home page&lt;/H1&gt;
    &lt;P&gt;Johann Sebastian Bach was a prolific composer.
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>
지금 스타일 시트는 네개의 룰을 가지고 있습니다.
첫번째 두 세트는 BODY 요소의 color와 background고 (텍스트 컬러와 배경 컬러를 함께 지정하는 건 좋은 아이디어입니다),
마지막 두 세트는 H1 요소의 color와 background입니다.

P 요소를 위한 컬러가 정의되어있지 않지만,
BODY라 명명된, 부모 요소로부터 컬러를 상속받습니다.

H1 요소도 BODY 요소의 자식이지만 두번째 룰이 상속값을 덮어씌울겁니다.

CSS에서 다른 값 사이에 충돌이 일어나기도 하며,
이 스펙문서에서는 그를 어떻게 해결하는 지 설명합니다.

<P>CSS&nbsp;2.2는 <a href="colors.html#propdef-color" class="noxref"><span
class="propinst-color">'color'</span></a> 속성을 포함한 90개 이상의 속성을 가집니다.
다른 것들도 살펴봅시다:

<PRE class="example">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Bach's home page&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    body {
      font-family: "Gill Sans", sans-serif;
      font-size: 12pt;
      margin: 3em;
    }
  &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;H1&gt;Bach's home page&lt;/H1&gt;
    &lt;P&gt;Johann Sebastian Bach was a prolific composer.
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>
첫번째는 여러개의 선언이 중괄호로 에워싼 블록을 통해 그룹화 시킬 수 있고,
각 선언은 세미콜론에 의해 나뉘어지며, 마지막 선언 또한 이어서 세미콜론을 가질 수도 있다를 나타냅니다.

<P>
첫번째 선언은 BODY 요소의 폰트 패밀리를 "Gill Sans"로 설정합니다.
만약 그 폰트를 사용할 수 없다면, 유저 에이전트(보통 "browser"를 참조합니다)는
모든 유저에이전트가 알고 있는 다섯개의 범용적인 폰트 패밀리 중 하나인 'sans-serif' 폰트 패밀리를 사용할 겁니다.
BODY의 자식 요소는 <a href="fonts.html#propdef-font-family" class="noxref"><span
class="propinst-font-family">'font-family'</span></a> 속성의 값을 상속받을 겁니다.

<P>
두번째 선언은 BODY 요소의 폰트 사이즈를 12 포인트로 설정합니다.
"point" 단위는 보통 프린트 기반의 폰트 사이즈와 다른 길이 값을 가리키는 타이포그래피를 위해 사용합니다.
이는 환경의 스케일에 영향을 받지 않는 절대 단위 예제입니다.

<P>
세번째 선언은 주변과 관련해 스케일에 영향을 받는 상대 단위를 사용합니다.
"em" 단위는 요소의 폰트 사이즈를 참조합니다.
이 케이스의 결과로는 BODY 요소의 사이 마진은 폰트 사이즈보다 3배 크게 나타날겁니다.

<H2>2.2 <a name="xml-tutorial">XML을 위한 간단한 CSS&nbsp;2.2 튜토리얼</a></H2>

<p>This section is non-normative.

<P>
CSS는 어떤 구조적 문서 포맷에서도 사용할 수 있습니다. 예를 들면 확장형 마크업 언어
<a href="refs.html#ref-XML11" rel="biblioentry" class="noxref"><span class="informref">[XML11]</span></a>로 이루어진 어플리케이션입니다.
사실상, XML은 HTML보다 스타일 시트에 더 영향을 받으며,
작성자가 그 스스로 요소를 생성하기 때문에, 유저 에이전트는 어떻게 표시해야할 지 알 수 없습니다.

<P>여기 간단한 XML 코드 조각입니다:

<PRE class="xml example">
&lt;ARTICLE&gt;
  &lt;HEADLINE&gt;Fredrick the Great meets Bach&lt;/HEADLINE&gt;
  &lt;AUTHOR&gt;Johann Nikolaus Forkel&lt;/AUTHOR&gt;
  &lt;PARA&gt;
    One evening, just as he was getting his
    &lt;INSTRUMENT&gt;flute&lt;/INSTRUMENT&gt; ready and his
    musicians were assembled, an officer brought him a list of
    the strangers who had arrived.
  &lt;/PARA&gt;
&lt;/ARTICLE&gt;
</PRE>

<P>
  이 조각을 문서와 비슷하게 보여주기 위해,
  우리는 첫번째로 몇몇 요소를 inline-level(즉, 줄바꿈이 일어나지 않습니다)로,
  몇몇 요소는 block-level(즉, 줄바꿈이 일어납니다)로 지정해야 합니다.

<PRE class="example">
INSTRUMENT { display: inline }
ARTICLE, HEADLINE, AUTHOR, PARA { display: block }
</PRE>

<P>
첫번째 룰은 INSTRUMENT를 inline으로 지정하고,
두번째 룰은 콤마로 구분된 셀렉터 목록과 함께, 다른 모든 요소를 block-level로 지정합니다.
XML 내 요소 이름은 대소문자를 구분하기 때문에, 셀렉터는 소문자로 작성 된 것(즉, 'instrument')과
대문자로 작성된 것(즉, 'INSTRUMENT')이 다릅니다.

<P>
XML 문서에서 스타일 시트를 연결하는 방법 중 하나로 프로세싱 지침을 사용할 수 있습니다:

<PRE class="xml example">
&lt;?xml-stylesheet type="text/css" href="bach.css"?&gt;
&lt;ARTICLE&gt;
  &lt;HEADLINE&gt;Fredrick the Great meets Bach&lt;/HEADLINE&gt;
  &lt;AUTHOR&gt;Johann Nikolaus Forkel&lt;/AUTHOR&gt;
  &lt;PARA&gt;
    One evening, just as he was getting his
    &lt;INSTRUMENT&gt;flute&lt;/INSTRUMENT&gt; ready and his
    musicians were assembled, an officer brought him a list of
    the strangers who had arrived.
  &lt;/PARA&gt;
&lt;/ARTICLE&gt;
</PRE>

<P>비주얼 유저 에이전트는 위 예제를 다음과 같이 보여줍니다:

<div class="figure">
<p><img src="images/bach1.png" alt="Example rendering"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-bach1" href="images/longdesc/bach1-desc.html" title="Long description for the first Bach/XML formatting example">[D]</A></SPAN>
</div>

<P>
"flute"가 인라인 요소 INSTRUMENT의 콘텐츠이기 때문에 문장 내에 남아 있는 걸 알 수 있습니다.

<P>
여전히, 텍스트는 당신이 원하는 대로 보이지 않습니다.
예를 들어, 헤드라인 폰트 사이즈는 다른 텍스트의 폰트 사이즈보다는 커야할 거 같고,
작성자의 이름을 기울임꼴(이탤릭)으로 보이게 하고 싶습니다:</P>

<PRE class="example">
INSTRUMENT { display: inline }
ARTICLE, HEADLINE, AUTHOR, PARA { display: block }
HEADLINE { font-size: 1.3em }
AUTHOR { font-style: italic }
ARTICLE, HEADLINE, AUTHOR, PARA { margin: 0.5em }
</PRE>

<P>비주얼 유저 에이전트는 위 예제를 다음과 같이 보여줍니다:

<div class="figure">
<p><img src="images/bach2.png" alt="Example rendering"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-bach2" href="images/longdesc/bach2-desc.html" title="Long description for the second Bach/XML formatting example">[D]</A></SPAN>
</div>

<P>
유저 에이전트에 더 많은 룰을 추가하여 문서의 표시 방법을 더욱 설명할 수 있습니다.


<H2>2.3 <a name="processing-model">CSS&nbsp;2.2 처리 모델</a></H2>

<p>This section up to but not including its subsections is non-normative.

<P>
이 섹션은 유저 에이전트가 CSS 동작을 어떻게 지원할지에 대한 처리 모델 중 하나를 나타냅니다.
이는 컨셉 모델이며, 실제 구현체와는 다를 수 있습니다.

<P>
이 모델에서, 유저 에이전트는 소스를 아래 스텝대로 처리해야합니다.
</P>

<ol>
<li>
  문서 소스를 파싱하고 <a
href="conform.html#doctree">문서 트리</a>를 생성합니다.</li>

<li>대상 <a href="media.html">미디어 타입</a>을 정의합니다.

<li>대상 <a href="media.html">미디어 타입</a> 정의와 관련된 문서의 모든 스타일 시트를 가져옵니다.

<li>
  대상 <a href="media.html">미디어 타입</a>에 적용할 수 있는 모든 <a href="syndata.html#properties">속성</a>에
  단일 값을 부여하여 문서 트리의 각 요소에 주석을 붙입니다. 속성에는 <a href="cascade.html">캐스케이딩과 상속</a> 섹션에서 설명하는
  메커니즘에 따라 값을 할당합니다.</a>.

<P>일부 값 계산은 대상 <a href="media.html">미디어 타입</a>에 적합한 형식 지정 알고리즘에 따라 다릅니다.
  예를 들어, 만약 대상 미디어가 스크린이라면, 유저 에이전트는 <a href="visuren.html">비주얼 형식 모델</a>을 따릅니다.

<li>
  주석이 달린 문서 트리를 이용해, <span class="index-def" title="formatting structure">
  <a name="formatting-structure"><dfn>formatting structure</dfn></a></span>를 생성합니다.
  때로, formatting structure는 문서 트리와 매우 유사하지만 크게 다를 수도 있으며,
  특히 작성자가 의사 요소나 생성된 콘텐츠를 사용할 때 그렇습니다.

  먼저, formatting structure가 "트리 구조"일 필요는 없습니다.
  구조의 특성은 구현에 따라 다릅니다.

  둘째로, formatting structure는 문서 트리보다 많거나 적은 정보를 포함할 수 있습니다.
  예를 들어, 문서 트리의 요소가 <a href="visuren.html#propdef-display" class="noxref"><span
  class="propinst-display">'display'</span></a> 속성 값을 'none'으로 가지는 경우,
  그 요소는 formatting structure에 생성되지 않습니다.
  
  한편 리스트 요소는 formatting structure에서 리스트 요소의 콘텐츠나 리스트의 (불렛 이미지 등의) 스타일 정보와 같이 
  더 많은 정보를 생성할 수 있습니다.

<P>
  CSS 유저 에이전트는 이 단계에서 문서 트리를 변경하지 않습니다.
  특히, 스타일 시트에서 생성된 콘텐츠는 문서 언어 프로세서에 다시 전달되지 않습니다. (예를 들어, 재해석 같은 것)

<li>formatting structure를 대상 미디어로 전달합니다.
  (예를 들어, 결과 인쇄, 화면에 표시, 음성으로 렌더링 등)
</ol>

<h3>2.3.1 <a name="the-canvas">The canvas</a></h3>

<P>
  모든 미디어에서, <span class="index-def" title="canvas"> <a
    name="canvas"><dfn>canvas</dfn></a></span>라는 용어는 "formatting structure가 
    렌더링 될 공간"을 의미합니다. canvas는 공간의 각 차원마다 무한하지만,
    보통 렌더링은 대상 미디어에 따라 유저 에이전트가 설정한 캔버스의 유한 영역 내에 발생합니다.
    예를 들어, 화면에 렌더링하는 유저 에이전트는 보통 최소 너비를 지정하고
    <a href="visuren.html#viewport">뷰포트</a>의 크기에 따라 초기 너비를 지정합니다.
    페이지에 렌더링하는 유저 에이전트는 보통 너비와 높이에 제약을 둡니다.
    청각 유저 에이전트는 오디오 공간에 제한을 주지만 시간은 제한하지 않을 수 있습니다.

<h3>2.3.2 <a name="addressing">CSS&nbsp;2.2 연결 모델</a></h3>

<P>스타일 시트는 CSS&nbsp;2.2 <a href="selector.html">셀렉터</a>와 속성을 사용하여
  문서 또는 유저 에이전트의 아래 부분을 참조할 수 있습니다.</p>

<ul>
<li>
  문서 트리 내 요소와 그 사이 특정 관계 (<a href="selector.html">셀렉터</a> 섹션 참고)

<li>
  문서 트리 내 요소 속성과 속성값 (<a href="selector.html#attribute-selectors">속성 셀렉터</a> 섹션 참고).

<li>요소 콘텐츠의 일부 (<a
href="selector.html#first-line">:first-line</a>과 <a
href="selector.html#first-letter">:first-letter</a> 의사 요소 참고).

<li>특정 상태에 있는 문서 트리 내 요소
(<a href="selector.html#pseudo-classes">의사 클래스</a> 섹션 참고).

<li>문서가 렌더링 될 <a href="#canvas">canvas</a>의 일부

<li>일부 시스템 정보 (<a href="ui.html">유저 인터페이스</a> 섹션 참고).
</ul>

<H2>2.4 <a name="design-principles">CSS 설계 원칙</a></H2>

<p>This section is non-normative.

<P>CSS&nbsp;2.2, 그 이전의 CSS2와 CSS1는 몇몇 설계 원칙에 기반을 둡니다:</p>

<UL>

<LI>
<P><STRONG>상위 및 하위호환성</STRONG>.
CSS&nbsp;2.2 유저 에이전트는 CSS1 스타일 시트를 이해할 수 있습니다.
CSS1 유저 에이전트는 CSS&nbsp;2.2 스타일 시트를 읽는 게 가능하며, 이해하지 못하는 폐기 파트도 있습니다.
또한, CSS를 지원하지 않는 유저 에이전트는 스타일이 강화된 문서를 표현할 수 있습니다.
당연히, CSS에 의한 스타일 향상 부분은 렌더링되지 않겠지만, 모든 콘텐츠는 제대로 보여줄 수 있습니다.
</P>
</LI>

<LI>
<P><STRONG>구조화된 문서에 대한 보완</STRONG>.
스타일 시트는 구조화된 문서를 보완하며 (즉 HTML과 XML 어플리케이션),
마크업 텍스트에 스타일적 정보를 제공합니다.
마크업에 약간의 영향을 주거나 아예 영향 없이 스타일을 바꾸는 게 쉽습니다.
</P>
</LI>

<LI>
<P><STRONG>벤더, 플랫폼, 기기 독립</STRONG>.
스타일 시트가 사용 가능한 문서는 벤더, 플랫폼, 그리고 디바이스에 독립적입니다.
스타일 시트 자체 또한 벤더와 플랫폼에 독립적이며,
CSS&nbsp;2.2는 디바이스의 그룹(예를 들면, 프린터)을 위한 스타일 시트를 타겟으로 허용하기도 합니다.
</P>
</LI>

<LI>
<P><STRONG>유지보수성</STRONG>.
문서로부터의 스타일 시트로 초점을 두면,
웹 마스터는 간단히 사이트를 유지보수할 수 있고, 사이트 전체의 룩과 느낌의 일관성을 유지할 수 있습니다.
예를 들어, 조직의 배경 색을 바꾸고자 할 때, 하나의 파일만 변경하면 됩니다.
</P>
</LI>

<LI>
<P><STRONG>간소함</STRONG>.
CSS는 사람이 읽고 쓰기에 좋은 간단한 스타일 언어입니다.
CSS 속성은 가능한 한 최대로 독립적으로 유지되며 특정 효과를 얻는 한가지 방법이 있습니다.</P>
</LI>

<LI>
<P><STRONG>네트워크 성능</STRONG>. 
  CSS는 콘텐츠를 표현하는 방법을 간결하게 인코딩합니다.
  이미지나 오디오 파일과 비교했을 때, 유저가 자주 사용하는 특정 렌더링 효과를 얻기 위해서, 스타일 시트는 콘텐츠 사이즈를 많이 줄입니다.
  또한, 네트워크 연결 수를 줄이면 네트워크 성능이 향상됩니다.</P> </LI>

<LI>
<P><STRONG>유연성</STRONG>. 
  CSS는 여러가지 방법으로 콘텐츠에 적용될 수 있습니다.
  주요 기능은 기본 (유저 에이전트) 스타일 시트, 유저 스타일 시트, 연결된 스타일 시트,
  문서 head 및 문서 body 내의 요소의 속성에 지정된 스타일 정보를 캐스케이딩 하는 것입니다.</P>
</LI>

<LI>
<P><STRONG>풍부함</STRONG>. 
  작성자에게 다양한 렌더링 효과를 제공하면 표현식의 미디어로써 웹의 풍부함을 높일 수 있습니다.
  디자이너는 데스크톱 게시 및 슬라이드 쇼 어플리케이션에서 흔히 볼 수 있는 기능을 원합니다.
  요청된 렌더링 효과 중 일부는 기기 독립성과 상충되지만,
  CSS&nbsp;2.2는 디자이너의 요구사항을 충족하는 데 많은 도움을 줍니다.</P>
</LI>

<LI>
<P><STRONG>대체 언어 바인딩</STRONG>. 
  이 스펙에서 설명하는 CSS 속성 그룹은 시각 및 청각 표현을 위한 일관된 형식 모델을 구성합니다.
  이 형식 모델은 CSS 언어를 통해 접근할 수 있으나, 다른 언어에서도 바인딩하는 것도 가능합니다.
  예를 들어, JavaScript 프로그램은 특정 요소의 <a href="colors.html#propdef-color" class="noxref"><span
    class="propinst-color">'color'</span></a> 속성 값을 동적으로 변경할 수 있습니다.
</LI>

<LI>
<P><STRONG>접근성</STRONG>. 몇가지 CSS 특성은 웹을 장애인 유저에게 더 접근가능하게 만듭니다.</p>

<UL>

<LI>
  글꼴 모양을 제어하는 속성을 사용하면 접근할 수 없는 
  비트맵 텍스트 이미지를 작성자가 제거할 수 있습니다.

<li>
  위치 지정 속성을 사용하면 (보이지 않는 이미지 같은) 마크업 트릭을 제거하고
  레이아웃을 적용할 수 있습니다.

<LI>
  <tt>!important</tt> 룰은 특정 표시 요구사항을 가진 유저가
  작성자의 스타일 시트를 무시할 수 있음을 의미합니다.

<li>
  모든 속성에 적용할 수 있는 'inherit' 값은
  캐스케이딩 일반성을 개선하고 보다 쉽고 일관된 스타일 조정을 허용합니다.

<li>
  미디어 그룹, 점자, 엠보싱 및 tty 미디어 타입을 포함한 향상된 미디어 지원을 이용하여
  사용자와 작성자는 페이지를 해당 장치에 맞출 수 있습니다.

</UL>

<div class="note"><P> <em><strong>Note.</strong> 
  HTML과 CSS를 이용한 접근가능한 문서를 설계하는 법에 대한 더 자세한 정보는 
  <a href="refs.html#ref-WCAG20" rel="biblioentry" class="noxref"><span class="informref">[WCAG20]</span></a>를 보시길 바랍니다.</em>
</div>
</UL>


<hr class="navbar">

<div class="navbar">
<p><a href="about.html">previous</a> &nbsp;
<a href="conform.html">next</a> &nbsp;
<a href="Overview.html#minitoc">contents</a> &nbsp;
<a href="propidx.html">properties</a> &nbsp;
<a href="indexlist.html">index</a> &nbsp;
</div>
</BODY>
</HTML>
