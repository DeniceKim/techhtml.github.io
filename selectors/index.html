<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html lang=ko>
 <head>
  <title>셀렉터 레벨 3</title>
  <link href=default.css rel=stylesheet type="text/css">
  <link href=trans.css rel=stylesheet type="text/css">
  <link href="http://www.w3.org/StyleSheets/TR/W3C-REC.css" rel=stylesheet type="text/css">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <body>
  <div class=head> <!--begin-logo-->
   <p><a href="http://www.w3.org/"><img alt=W3C height=48
    src="http://www.w3.org/Icons/w3c_home" width=72></a> <!--end-logo-->

   <h1 id=title>셀렉터 레벨 3</h1>

   <h2 class="no-num no-toc" id=longstatus-date>2011년 9월 29일 W3C 권고안</h2>

   <dl>
    <dt>이 버전:

    <dd> <a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/">
     http://www.w3.org/TR/2011/REC-css3-selectors-20110929/</a>
     <!-- <a href="http://dev.w3.org/csswg/selectors3">
             http://dev.w3.org/csswg/selectors3</a> -->
     
     <dt>최신 버전:

    <dd><a href="http://www.w3.org/TR/css3-selectors/">
     http://www.w3.org/TR/css3-selectors/</a>
     
    <dt>최신 셀렉터 스펙 문서:

    <dd><a href="http://www.w3.org/TR/selectors/">
     http://www.w3.org/TR/selectors/</a>

    <dt>이전 버전:

    <dd> <a href="http://www.w3.org/TR/2009/PR-css3-selectors-20091215/">
     http://www.w3.org/TR/2009/PR-css3-selectors-20091215/</a>

    <dt><a name=editors-list></a>Editors:

    <dd class=vcard><a class="url fn" href="http://www.tantek.com/"
     lang=tr>Tantek &Ccedil;elik</a> (Invited Expert)

    <dd class=vcard><a class="url fn"
     href="http://fantasai.inkedblade.net/contact">Elika J. Etemad</a>
     (Invited Expert)

    <dd class=vcard><span class=fn>Daniel Glazman</span> (Disruptive
     Innovations SARL)

    <dd class=vcard><a class="url fn" href="mailto:ian@hixie.ch">Ian
     Hickson</a> (<span class=company><a
     href="http://www.google.com/">Google</a></span>)

    <dd class=vcard><span class=fn>Peter Linss</span> (former editor, <span
     class=company><a
     href="http://www.netscape.com/">Netscape/AOL</a></span>)

    <dd class=vcard><span class=fn>John Williams</span> (former editor, <span
     class=company><a href="http://www.quark.com/">Quark, Inc.</a></span>)
   </dl>
   
   <p>스펙 문서의 규범적인 정의에 수정이 있을 가능성이 있기 때문에 <a href="http://www.w3.org/Style/2011/REC-css3-selectors-20110929-errata.html"><strong>errata</strong></a>도 확인하시길 바랍니다</p>
   
   <p><a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=css3-selectors"><strong>번역본</strong></a>도 있습니다.</p>
   
   <!--begin-copyright-->
<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2011 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
   <!--end-copyright-->
   <hr title="Separator for header">
  </div>

  <h2 class="no-num no-toc" id=abstract>개요</h2>
  <p lang="ko"><em>셀렉터</em>는 트리 요소에 매치하는 패턴이며 
  XML 문서에서 노드를 선택할 때 사용하는 방법 중 하나입니다.
  셀렉터는 HTML이나 XML에서 사용하는 것에 최적화 되어있으며
  성능이 중요한 코드에서 사용하기 쉽게 설계하였습니다.
  <p lang="en"><em>Selectors</em> are patterns that match against elements in a tree,
   and as such form one of several technologies that can be used to select
   nodes in an XML document. Selectors have been optimized for use with HTML
   and XML, and are designed to be usable in performance-critical code.

  <p lang="ko"><acronym title="Cascading Style Sheets">CSS</acronym> (Cascading Style Sheets)는 
  <acronym title="Hypertext Markup Language">HTML</acronym>과 <acronym title="Extensible Markup Language">XML</acronym> 문서가
  스크린, 종이 매체, 음성 매체 등에서 렌더링 되는 방법을 정의하는 언어입니다.
  CSS는 문서 내의 요소에 style 속성을 묶어주기 위해 셀렉터를 사용합니다.
  <p lang="en"><acronym title="Cascading Style Sheets">CSS</acronym> (Cascading Style
   Sheets) is a language for describing the rendering of <acronym
   title="Hypertext Markup Language">HTML</acronym> and <acronym
   title="Extensible Markup Language">XML</acronym> documents on screen, on
   paper, in speech, etc. CSS uses Selectors for binding style properties to
   elements in the document.
  
  <p lang="ko">이 문서는 <abbr title="CSS level 1">CSS1</abbr> <a href="#CSS1" rel=biblioentry>[CSS1]<!--{{CSS1}}--></a> 및 
    <abbr title="CSS level 2">CSS2</abbr> <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>에 이미 존재하던 셀렉터에
    <abbr title="CSS level 3">CSS3</abbr> 및 다른 언어에서 필요로 하는 셀렉터를 소개합니다.
  
  <p lang="en">This document describes the selectors that already exist in <abbr
   title="CSS level 1">CSS1</abbr> <a href="#CSS1"
   rel=biblioentry>[CSS1]<!--{{CSS1}}--></a> and <abbr title="CSS level
   2">CSS2</abbr> <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>, and further introduces new
   selectors for <abbr title="CSS level 3">CSS3</abbr> and other languages
   that may need them.

  <p lang="ko">셀렉터는 아래 함수를 정의합니다:
  <p lang="en">Selectors define the following function:

  <pre>expression &#x2217; element &rarr; boolean</pre>
  <p lang="ko">
    즉 요소와 셀렉터가 주어졌을 때,
    그 요소가 어떤 셀렉터에 매치하는 지 이 스펙문서에서 정의합니다.
  
  <p lang="en">That is, given an element and a selector, this specification defines
   whether that element matches the selector.
  <p lang="ko">
    이 식은 일련의 요소 혹은 요소 그룹 안의 자식 요소, 서브트리 안 모든 요소에 대해 식을 계산하여 선택할 때 사용합니다.
    XML 트리 변환 언어 <acronym title="Simple
   Tree Transformation Sheets">STTS</acronym> (Simple Tree Transformation
   Sheets)는 이 메커니즘을 이용합니다. <a href="#STTS3" rel=biblioentry>[STTS3]<!--{{STTS3}}--></a>
  <p lang="en">These expressions can also be used, for instance, to select a set of
   elements, or a single element from a set of elements, by evaluating the
   expression across all the elements in a subtree. <acronym title="Simple
   Tree Transformation Sheets">STTS</acronym> (Simple Tree Transformation
   Sheets), a language for transforming XML trees, uses this mechanism. <a
   href="#STTS3" rel=biblioentry>[STTS3]<!--{{STTS3}}--></a>

  <h2 class="no-num no-toc" id=status>이 문서의 상태</h2>
  <!--begin-status-->
  <p lang=ko><em>
    이 섹션은 이 문서를 공개했을 때 상태에 대해 설명합니다.
    다른 문서가 이 문서를 덮어쓸 가능성이 있으니 주의하시길 바랍니다.
    이 문서 및 W3C에서 공개한 다른 문서의 최신 버전은 
    <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/에서
    확인 가능합니다.</em>
  </p>
  <p lang="en"><em>This section describes the status of this document at the time of
   its publication. Other documents may supersede this document. A list of
   current W3C publications and the latest revision of this technical report
   can be found in the <a href="http://www.w3.org/TR/">W3C technical reports
   index at http://www.w3.org/TR/.</a></em>
  <p lang="ko">
    이 문서는 <a href="http://www.w3.org/Style/CSS/members">CSS Working Group</a>에서 제공하는 <a
   href="http://www.w3.org/Consortium/Process/tr#RecsPR">후보 권고안</a>입니다.
   <span class="transnote">역주: 현재 권고안이나 PR때 문서가 그대로 권고안이 되었습니다.</span>
  <p lang="en">This document was produced by the <a
   href="http://www.w3.org/Style/CSS/members">CSS Working Group</a> as a <a
   href="http://www.w3.org/Consortium/Process/tr#RecsPR">Proposed
   Recommendation.</a>
  <p lang="ko">
    W3C 권고안은, 구현 가능하도록 광범위하게 리뷰를 받은 뒤 공개한 성숙한 문서입니다.
    이 스펙문서와 관련한 토론은 (<a
   href="http://lists.w3.org/Archives/Public/www-style/">archived</a>) 공개 메일링 리스트 <a
   href="mailto:www-style@w3.org?Subject=%5Bcss3-selectors%5D%20PUT%20SUBJECT%20HERE">
   www-style@w3.org</a> (<a href="http://www.w3.org/Mail/Request">참가안내서</a>)에서 하는 것이 바람직하며,
   메일을 보낼 때에는 제목에 &#8220;css3-selectors&#8221;를 기입해주시길 바랍니다. 이는 곧,
   &#8220;[<!---->css3-selectors<!---->] <em>&hellip;본문 요약&hellip;</em>&#8221; 같은 형태일 것입니다.
  </p>
  <p lang="en">A W3C Recommendation is a mature document that has been widely
   reviewed and has been shown to be implementable. W3C encourages everybody
   to implement this specification. Comments may be sent to the (<a
   href="http://lists.w3.org/Archives/Public/www-style/">archived</a>) public
   mailing list <a
   href="mailto:www-style@w3.org?Subject=%5Bcss3-selectors%5D%20PUT%20SUBJECT%20HERE">www-style@w3.org</a>
   (see <a href="http://www.w3.org/Mail/Request">instructions</a>). When
   sending e-mail, please put the text &#8220;css3-selectors&#8221; in the
   subject, preferably like this: &#8220;[<!---->css3-selectors<!---->]
   <em>&hellip;summary of comment&hellip;</em>&#8221;
   <p lang="ko">이 문서는 W3C 멤버, 소프트웨어 개발자, 그리고 다른 W3C 그룹 및 관계자들이 평가를 진행하여, 디렉터에 의해 W3C 권고안으로 발표했습니다. 
    이 문서는 안정적이며, 참고자료로 사용하거나 다른 문서에서 인용해도 좋습니다. 
    스펙 문서의 권고를 통해 W3C가 하는 역할은 스펙 문서에 관심을 모으고 다방면으로 퍼뜨리는 일입니다. 
    이를 통해 웹의 기능과 상호운용성 향상을 기대할 수 있습니다.</p>
   <p lang="en">This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>
  <p lang="ko">이 문서는 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">2004년 2월 6일 W3C 특허 정책</a>을 따르는 그룹에서 작성하였습니다.
    W3C는 그룹의 성과물에 관련하여 <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">모든 공개 특허 공개 리스트</a>를 관리합니다.
    여기에는 특허 공개에 대한 지시사항도 포함합니다.
    특허에 대해서 충분한 지식이 있는 사람이, 스펙 문서의 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>에 인정된다고 파악되는 경우, <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C 특허 정책 제 6장</a>에 의거하여 정보를 공개해야 할 필요가 있습니다.</p>

  <p lang="en">This document was produced by a group operating under the <a
   href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5&nbsp;February
   2004 W3C Patent Policy</a>. W3C maintains a <a
   href="http://www.w3.org/2004/01/pp-impl/32061/status"
   rel=disclosure>public list of any patent disclosures</a> made in
   connection with the deliverables of the group; that page also includes
   instructions for disclosing a patent. An individual who has actual
   knowledge of a patent which the individual believes contains <a
   href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
   Claim(s)</a> must disclose the information in accordance with <a
   href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
   section&nbsp;6 of the W3C Patent Policy</a>.</p>
  <!--end-status-->
  <p lang="ko">
    이 스펙문서에 대한 여러개의 구현체 및 test suite를 포함한 <a
    href="/Style/CSS/Test/CSS3/Selectors/20091025/reports/CR-ImpReport.html">구현보고서</a>를 제공합니다.
  </p>
  <p lang="en">A separate <a
   href="/Style/CSS/Test/CSS3/Selectors/20091025/reports/CR-ImpReport.html">
   implementation report</a> contains a test suite and shows several
   implementations of the specification.
  <p lang="ko" id=changes>이 문서는 보여지는 부분에 대한 편집내용 변경, 참고문서 업데이트를 제외하곤,
    이전 버전의 후보 권고안과 동일합니다.
  <p lang="en">This document is the same as the previous, Proposed Recommendation
   version, except for editorial changes to the front matter, and updating of references.


  <h2 class="no-num no-toc" id=contents>목차</h2>
  <!--begin-toc-->

  <ul class=toc>
   <li><a href="#context"><span class=secno>1. </span>Introduction</a>
    <ul class=toc>
     <li><a href="#dependencies"><span class=secno>1.1.
      </span>Dependencies</a>

     <li><a href="#terminology"><span class=secno>1.2. </span>Terminology</a>
      

     <li><a href="#changesFromCSS2"><span class=secno>1.3. </span>Changes
      from CSS2</a>
    </ul>

   <li><a href="#selectors"><span class=secno>2. </span>Selectors</a>

   <li><a href="#casesens"><span class=secno>3. </span>Case sensitivity</a>

   <li><a href="#selector-syntax"><span class=secno>4. </span>Selector
    syntax</a>

   <li><a href="#grouping"><span class=secno>5. </span>Groups of
    selectors</a>

   <li><a href="#simple-selectors"><span class=secno>6. </span>Simple
    selectors</a>
    <ul class=toc>
     <li><a href="#type-selectors"><span class=secno>6.1. </span>Type
      selector</a>
      <ul class=toc>
       <li><a href="#typenmsp"><span class=secno>6.1.1. </span>Type selectors
        and namespaces</a>
      </ul>

     <li><a href="#universal-selector"><span class=secno>6.2.
      </span>Universal selector </a>
      <ul class=toc>
       <li><a href="#univnmsp"><span class=secno>6.2.1. </span>Universal
        selector and namespaces</a>
      </ul>

     <li><a href="#attribute-selectors"><span class=secno>6.3.
      </span>Attribute selectors</a>
      <ul class=toc>
       <li><a href="#attribute-representation"><span class=secno>6.3.1.
        </span>Attribute presence and value selectors</a>

       <li><a href="#attribute-substrings"><span class=secno>6.3.2.
        </span>Substring matching attribute selectors</a>

       <li><a href="#attrnmsp"><span class=secno>6.3.3. </span>Attribute
        selectors and namespaces</a>

       <li><a href="#def-values"><span class=secno>6.3.4. </span>Default
        attribute values in DTDs</a>
      </ul>

     <li><a href="#class-html"><span class=secno>6.4. </span>Class
      selectors</a>

     <li><a href="#id-selectors"><span class=secno>6.5. </span>ID
      selectors</a>

     <li><a href="#pseudo-classes"><span class=secno>6.6.
      </span>Pseudo-classes</a>
      <ul class=toc>
       <li><a href="#dynamic-pseudos"><span class=secno>6.6.1. </span>Dynamic
        pseudo-classes</a>
        <ul class=toc>
         <li><a href="#the-link-pseudo-classes-link-and-visited"><span
          class=secno>6.6.1.1. </span>The link pseudo-classes: :link and
          :visited</a>

         <li><a href="#the-user-action-pseudo-classes-hover-act"><span
          class=secno>6.6.1.2. </span>The user action pseudo-classes :hover,
          :active, and :focus</a>
        </ul>

       <li><a href="#target-pseudo"><span class=secno>6.6.2. </span>The
        target pseudo-class :target</a>

       <li><a href="#lang-pseudo"><span class=secno>6.6.3. </span>The
        language pseudo-class :lang</a>

       <li><a href="#UIstates"><span class=secno>6.6.4. </span>The UI element
        states pseudo-classes</a>
        <ul class=toc>
         <li><a href="#enableddisabled"><span class=secno>6.6.4.1. </span>The
          :enabled and :disabled pseudo-classes</a>

         <li><a href="#checked"><span class=secno>6.6.4.2. </span>The
          :checked pseudo-class</a>

         <li><a href="#indeterminate"><span class=secno>6.6.4.3. </span>The
          :indeterminate pseudo-class</a>
        </ul>

       <li><a href="#structural-pseudos"><span class=secno>6.6.5.
        </span>Structural pseudo-classes</a>
        <ul class=toc>
         <li><a href="#root-pseudo"><span class=secno>6.6.5.1. </span>:root
          pseudo-class</a>

         <li><a href="#nth-child-pseudo"><span class=secno>6.6.5.2.
          </span>:nth-child() pseudo-class</a>

         <li><a href="#nth-last-child-pseudo"><span class=secno>6.6.5.3.
          </span>:nth-last-child() pseudo-class</a>

         <li><a href="#nth-of-type-pseudo"><span class=secno>6.6.5.4.
          </span>:nth-of-type() pseudo-class</a>

         <li><a href="#nth-last-of-type-pseudo"><span class=secno>6.6.5.5.
          </span>:nth-last-of-type() pseudo-class</a>

         <li><a href="#first-child-pseudo"><span class=secno>6.6.5.6.
          </span>:first-child pseudo-class</a>

         <li><a href="#last-child-pseudo"><span class=secno>6.6.5.7.
          </span>:last-child pseudo-class</a>

         <li><a href="#first-of-type-pseudo"><span class=secno>6.6.5.8.
          </span>:first-of-type pseudo-class</a>

         <li><a href="#last-of-type-pseudo"><span class=secno>6.6.5.9.
          </span>:last-of-type pseudo-class</a>

         <li><a href="#only-child-pseudo"><span class=secno>6.6.5.10.
          </span>:only-child pseudo-class</a>

         <li><a href="#only-of-type-pseudo"><span class=secno>6.6.5.11.
          </span>:only-of-type pseudo-class</a>

         <li><a href="#empty-pseudo"><span class=secno>6.6.5.12.
          </span>:empty pseudo-class</a>
        </ul>

       <li><a href="#content-selectors"><span class=secno>6.6.6.
        </span>Blank</a>

       <li><a href="#negation"><span class=secno>6.6.7. </span>The negation
        pseudo-class</a>
      </ul>
    </ul>

   <li><a href="#pseudo-elements"><span class=secno>7.
    </span>Pseudo-elements</a>
    <ul class=toc>
     <li><a href="#first-line"><span class=secno>7.1. </span>The ::first-line
      pseudo-element</a>
      <ul class=toc>
       <li><a href="#first-formatted-line"><span class=secno>7.1.1.
        </span>First formatted line definition in CSS</a>
      </ul>

     <li><a href="#first-letter"><span class=secno>7.2. </span>The
      ::first-letter pseudo-element</a>
      <ul class=toc>
       <li><a href="#application-in-css"><span class=secno>7.2.1.
        </span>Application in CSS</a>
      </ul>

     <li><a href="#selection"><span class=secno>7.3. </span>Blank</a>

     <li><a href="#gen-content"><span class=secno>7.4. </span>The ::before
      and ::after pseudo-elements</a>
    </ul>

   <li><a href="#combinators"><span class=secno>8. </span>Combinators</a>
    <ul class=toc>
     <li><a href="#descendant-combinators"><span class=secno>8.1.
      </span>Descendant combinator</a>

     <li><a href="#child-combinators"><span class=secno>8.2. </span>Child
      combinators</a>

     <li><a href="#sibling-combinators"><span class=secno>8.3. </span>Sibling
      combinators</a>
      <ul class=toc>
       <li><a href="#adjacent-sibling-combinators"><span class=secno>8.3.1.
        </span>Adjacent sibling combinator</a>

       <li><a href="#general-sibling-combinators"><span class=secno>8.3.2.
        </span>General sibling combinator</a>
      </ul>
    </ul>

   <li><a href="#specificity"><span class=secno>9. </span>Calculating a
    selector's specificity</a>

   <li><a href="#w3cselgrammar"><span class=secno>10. </span>The grammar of
    Selectors</a>
    <ul class=toc>
     <li><a href="#grammar"><span class=secno>10.1. </span>Grammar</a>

     <li><a href="#lex"><span class=secno>10.2. </span>Lexical scanner</a>
    </ul>

   <li><a href="#profiling"><span class=secno>11. </span>Profiles</a>

   <li><a href="#Conformance"><span class=secno>12. </span>Conformance and
    requirements</a>

   <li><a href="#Tests"><span class=secno>13. </span>Tests</a>

   <li><a href="#ACKS"><span class=secno>14. </span>Acknowledgements</a>

   <li><a href="#references"><span class=secno>15. </span>References</a>
    <ul class=toc>
     <li><a href="#normative-references"><span class=secno>15.1.
      </span>Normative References</a>

     <li><a href="#informative-references"><span class=secno>15.2.
      </span>Informative References</a>
    </ul>
  </ul>
  <!--end-toc-->

  <h2 id=context><span class=secno>1. </span>소개</h2>
  <p lang="ko">
   셀렉터 레벨 1과 셀렉터 레벨 2는 <a href="http://www.w3.org/TR/REC-CSS1">CSS1</a> 및 
   <a href="http://www.w3.org/TR/CSS21/">CSS2.1</a>에서 각자 기능적으로 정의한 셀렉터의 서브셋을 정의하였습니다.
  <p lang="en">
   Selectors Level 1 and Selectors Level 2 are defined as the subsets of
   selector functionality defined in the <a
   href="http://www.w3.org/TR/REC-CSS1">CSS1</a> and <a
   href="http://www.w3.org/TR/CSS21/">CSS2.1</a> specifications,
   respectively.

  <h3 id=dependencies><span class=secno>1.1. </span>의존성</h3>
  <p lang="ko">
    스펙 내 몇가지 기능은 CSS 고유 기능이며, 특정 제한사항 혹은 CSS 고유의 룰을 가집니다.
    이 스펙에서는, 이러한 내용을 CSS 2.1의 조건대로 설명합니다. <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>
  <p lang="en">Some features of this specification are specific to CSS, or have
   particular limitations or rules specific to CSS. In this specification,
   these have been described in terms of CSS2.1. <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>

  <h3 id=terminology><span class=secno>1.2. </span>용어</h3>

  <p lang="ko">
    이 스펙문서 내에서 예제, 노트, 명시적으로 '이 섹션은 표준에 준하는 내용이 아닙니다'라 표기된 내용을 제외한 텍스트는 
    모두 표준에 준하는 내용입니다.
  </p>
  <p lang="en">All of the text of this specification is normative except examples,
   notes, and sections explicitly marked as non-normative.
  <p lang="ko">
    <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>의
    <a href="http://www.w3.org/TR/CSS21/conform.html#defs">Definitions</a> 섹션에서
    더 많은 용어를 정의하고 있습니다.
    문서 소스 코드 예제 및 XML [[XML10]] 혹은 HTML [[HTML40]] 문법 제공 등입니다.
  <p lang="en">Additional terminology is defined in the <a
   href="http://www.w3.org/TR/CSS21/conform.html#defs">Definitions</a>
   section of <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>.
   Examples of document source code and fragments are given in XML [[XML10]
   or HTML [[HTML40]] syntax.

  <h3 id=changesFromCSS2><span class=secno>1.3. </span>CSS2와 다른 점</h3>

  <p lang="ko"><em>이 섹션은 표준에 준하는 내용이 아닙니다.</em>
  <p lang="en"><em>This section is non-normative.</em>

  <p lang="ko">CSS2 셀렉터와 이 스펙문서에서 소개하는 셀렉터 간의 큰 차이점은 다음과 같습니다:
  <p lang="en">The main differences between the selectors in CSS2 and those in
   Selectors are:

  <ul>
   <li>
    기본 정의(셀렉터, 셀렉터 그룹, 심플 셀렉터, 등)가 변했습니다.
    특히, CSS에서 심플 셀렉터(simple selector)라 불리던 게 지금은
    시퀀스 컴포넌트로 사용되고 있으며, "심플 셀렉터"는 그 시퀀스에서 이루어지는
    컴포넌트를 나타내는 언어로 사용하고 있습니다.
    <div lang="en">the list of basic definitions (selector, group of selectors, simple
    selector, etc.) has been changed; in particular, what was referred to in
    CSS2 as a simple selector is now called a sequence of simple selectors,
    and the term "simple selector" is now used for the components of this
    sequence</div>

   <li>
    타입 셀렉터, 전역 셀렉터, 속성 셀렉터가 임의의 네임스페이스 컴포넌트를 허용합니다.
    <div lang="en">
    an optional namespace component is now allowed in element type
    selectors, the universal selector and attribute selectors</div>

   <li>
    <a href="#general-sibling-combinators">새로운 콤비네이터</a>를 소개합니다.
    <div lang="en">a <a href="#general-sibling-combinators">new combinator</a> has been
    introduced</div>

   <li>
    부분 매칭 속성 셀렉터 (substring matching attribute selectors)를 포함하는 새로운 심플 셀렉터와 새로운 의사 클래스를 추가했습니다.
    <div lang="en">new simple selectors including substring matching attribute selectors,
    and new pseudo-classes</div>

   <li>
    새로운 의사 클래스와 의사 요소를 위한 "::" 컨벤션을 소개합니다. 
    <div lang="en">new pseudo-elements, and introduction of the "::" convention for
    pseudo-elements</div>

   <li>
     문법을 새로 작성하였습니다.
     <div lang="en">the grammar has been rewritten</div>

   <li>
    셀렉터 관련 스펙을 하나로 통합하고 각 스펙 문서에서 실제로 지원하는 셀렉터가 무엇인지 정의하는 프로파일을 추가하였습니다.
    <div lang="en">profiles to be added to specifications integrating Selectors and
    defining the set of selectors which is actually supported by each
    specification</div>

   <li>
    셀렉터는 이제 CSS3 모듈이며 독립적인 스펙문서입니다.
    다른 스펙문서가 CSS의 독립 문서인 이 문서를 참조할 수 있습니다.
    <div lang="en">Selectors are now a CSS3 Module and an independent specification;
    other specifications can now refer to this document independently of CSS</div>

   <li>
     이 스펙 문서는 독자 test suite를 가집니다.
     <div lang="en">the specification now has its own test suite</div>
  </ul>

  <h2 id=selectors><span class=secno>2. </span>셀렉터</h2>
  <p lang="ko"><em>이 섹션은 다음 섹션을 소개하는 성격의 섹션으로 표준에 준하는 내용이 아닙니다.</em></p>
  <p lang="en"><em>This section is non-normative, as it merely summarizes the following
   sections.</em>
  <p lang="ko">
   셀렉터는 구조를 나타냅니다.
   이 구조는 문서 트리 내 어떤 요소가 매치하는 지 결정하는 조건(CSS 룰에 의한 것)이나
   그 구조에 대응하는 HTML 혹은 XML fragment로 이용합니다.
  </p>
  <p lang="en">A Selector represents a structure. This structure can be used as a
   condition (e.g. in a CSS rule) that determines which elements a selector
   matches in the document tree, or as a flat description of the HTML or XML
   fragment corresponding to that structure.
  <p lang="ko">셀렉터의 범위는 간단히 요소의 이름부터 문맥을 표현하기까지 넓게 확장합니다.</p>
  <p lang="en">Selectors may range from simple element names to rich contextual
   representations.
  <p lang="ko">다음 표에서 셀렉터 문법을 정리하고 있습니다.</p>
  <p lang="en">The following table summarizes the Selector syntax:

  <table class=selectorsReview>
   <thead>
    <tr>
     <th class=pattern>패턴

     <th class=meaning>의미

     <th class=described>소개 섹션

     <th class=origin>CSS 레벨

   <tbody>
    <tr>
     <td class=pattern>*

     <td class=meaning>모든 요소

     <td class=described><a href="#universal-selector">전역 셀렉터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E

     <td class=meaning>E 타입 요소

     <td class=described><a href="#type-selectors">타입 셀렉터</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E[foo]

     <td class=meaning>"foo" 속성을 가진 E 요소

     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E[foo="bar"]

     <td class=meaning>"foo" 속성값이 문자열 "bar"인 요소

     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E[foo~="bar"]

     <td class=meaning>"foo" 속성값이 공백으로 구분된 값 목록에서, 하나 이상이 문자열 "bar"와 일치하는 요소 

     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E[foo^="bar"]

     <td class=meaning>"foo" 속성값이 문자열 "bar"로 시작하는 요소

     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E[foo$="bar"]

     <td class=meaning>"foo" 속성값이 문자열 "bar"로 끝나는 요소

     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E[foo*="bar"]

     <td class=meaning>"foo" 속성값에 문자열 "bar"를 포함하는 요소 

     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E[foo|="en"]

     <td class=meaning>
       "foo" 속성값이 하이픈으로 구분되는 리스트에서 (왼쪽을 기준으로) "en"으로 시작하는 요소
     
     <td class=described><a href="#attribute-selectors">속성 셀렉터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E:root

     <td class=meaning>문서의 루트인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:nth-child(n)

     <td class=meaning>부모에서 n번째 자식인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:nth-last-child(n)

     <td class=meaning>부모 내 마지막 요소부터 시작하여 n번째 자식인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:nth-of-type(n)

     <td class=meaning>해당 타입의 n번째 형제인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:nth-last-of-type(n)

     <td class=meaning>해당 타입의 마지막 요소부터 시작하여 n번째 형제인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:first-child

     <td class=meaning>부모의 첫번째 자식 요소인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E:last-child

     <td class=meaning>부모의 마지막 자식 요소인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:first-of-type

     <td class=meaning>해당 타입의 첫번째 형제요소인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:last-of-type

     <td class=meaning>해당 타입의 마지막 형제요소인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:only-child

     <td class=meaning>부모에서 유일한 자식인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:only-of-type

     <td class=meaning>해당 타입에서 유일한 형제인 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:empty

     <td class=meaning>(텍스트 노드를 포함한) 자식을 갖지 않는 E 요소

     <td class=described><a href="#structural-pseudos">구조 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:link<br>
      E:visited

     <td class=meaning>
      아직 방문하지 않은(:link), 이미 방문한(:visited) 타겟 하이퍼링크 소스인 E 요소

     <td class=described><a href="#link">링크 의사 클래스</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E:active<br>
      E:hover<br>
      E:focus

     <td class=meaning>유저가 액션을 취하는 동안 E 요소

     <td class=described><a href="#useraction-pseudos">유저 액션 의사 클래스</a>

     <td class=origin>1 2

    <tr>
     <td class=pattern>E:target

     <td class=meaning>URI 참조 타겟 E 요소

     <td class=described><a href="#target-pseudo">타겟 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:lang(fr)

     <td class=meaning>
       (문서 언어가 어떻게 언어를 지정하는지에 따라) 언어 "fr"인 E 타입 요소

     <td class=described><a href="#lang-pseudo">:lang() 의사 클래스</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E:enabled<br>
      E:disabled

     <td class=meaning>유저 인터페이스 요소인 E가 사용 가능 / 사용 불가능한 상태

     <td class=described><a href="#UIstates">UI 요소 상태 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E:checked<!--<br>E:indeterminate-->

     <td class=meaning>
      체크 되어있는 유저 인터페이스 요소 E
      (즉 라디오 버튼 혹은 체크박스)

     <td class=described><a href="#UIstates">UI 요소 상태 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E::first-line

     <td class=meaning>E 요소의 첫번째 줄

     <td class=described><a href="#first-line">::first-line 의사 요소</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E::first-letter

     <td class=meaning>E 요소의 첫번째 문자

     <td class=described><a href="#first-letter">::first-letter 의사 요소</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E::before

     <td class=meaning>E 요소 앞에 콘텐츠 생성

     <td class=described><a href="#gen-content">::before 의사 요소</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E::after

     <td class=meaning>E 요소 뒤에 콘텐츠 생성

     <td class=described><a href="#gen-content">::after 의사 요소</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E.warning

     <td class=meaning>
      "warning" 클래스를 가진 E 요소
      (문서 언어가 어떻게 class를 지정하느냐에 따라 다름)

     <td class=described><a href="#class-html">클래스 셀렉터</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E#myid

     <td class=meaning>"myid" ID를 가진 E 요소.

     <td class=described><a href="#id-selectors">ID 셀렉터</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E:not(s)

     <td class=meaning>심플 셀렉터 s에 매치하지 않는 E 요소

     <td class=described><a href="#negation">부정 의사 클래스</a>

     <td class=origin>3

    <tr>
     <td class=pattern>E F

     <td class=meaning>E 요소의 자손 F 요소

     <td class=described><a href="#descendant-combinators">자손 콤비네이터</a>

     <td class=origin>1

    <tr>
     <td class=pattern>E &gt; F

     <td class=meaning>E 요소의 자식 F 요소

     <td class=described><a href="#child-combinators">자식 콤비네이터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E + F

     <td class=meaning>E 요소 바로 다음에 이어지는 F 요소

     <td class=described><a href="#adjacent-sibling-combinators">인접 형제 콤비네이터</a>

     <td class=origin>2

    <tr>
     <td class=pattern>E ~ F

     <td class=meaning>E 요소 다음에 이어지는 F 요소

     <td class=described><a href="#general-sibling-combinators">일반 형제 콤비네이터</a>

     <td class=origin>3
  </table>
  <p lang="ko">
   각 셀렉터의 의미는 테이블의 "의미" 열 내 각 셀의 콘텐츠에 "~와 일치한다"라는 말을 붙여서 알 수 있습니다.
  <p lang="en">
   The meaning of each selector is derived from the table above by
   prepending "matches" to the contents of each cell in the "Meaning" column.

  <h2 id=casesens><span class=secno>3. </span>대소문자 구별</h2>

  <p lang="ko">
    모든 셀렉터 문법은 ASCII 범위(즉 [a-z][A-Z]와 동등) 내에서, 셀렉터의 제어 영역이 아닌 부분을 제외하면 대소문자를 구별하지 않습니다.
    문서 언어에 의존하는 셀렉터 내에서 문서 언어의 요소명, 속성명, 속성값은 대소문자를 구별합니다.
    HTML을 예로 들면 요소명이 대소문자를 구별하지 않습니다.
    하지만 XML에서는 대소문자를 구별합니다.
    네임스페이스 접두사의 대소문자 구별은 <a href="#CSS3NAMESPACE" rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>에서 정의합니다.
  </p>
  <p lang="en">All Selectors syntax is case-insensitive within the ASCII range (i.e.
   [a-z] and [A-Z] are equivalent), except for parts that are not under the
   control of Selectors. The case sensitivity of document language element
   names, attribute names, and attribute values in selectors depends on the
   document language. For example, in HTML, element names are
   case-insensitive, but in XML, they are case-sensitive. Case sensitivity of
   namespace prefixes is defined in <a href="#CSS3NAMESPACE"
   rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>.

  <h2 id=selector-syntax><span class=secno>4. </span>셀렉터 문법</h2>
  <p lang="ko">
    <dfn id=selector>셀렉터</dfn>는 <a href="#combinators">콤비네이터</a>로 구분된 한개 이상의 
    <a href="#sequence">심플 셀렉터 시퀀스</a> 체인입니다.
    셀렉터 중 심플 셀렉터의 마지막 시퀀스인 경우 하나의 
    <a href="#pseudo-elements">의사 요소</a>를 넣는 것도 가능합니다.
  </p>
  <p lang="en">A selector is a chain of one or more <a
   href="#sequence">sequences of simple selectors</a> separated by <a
   href="#combinators">combinators</a>. One <a
   href="#pseudo-elements">pseudo-element</a> may be appended to the last
   sequence of simple selectors in a selector.
  <p lang="ko">
    <dfn id=sequence-of-simple-selectors><a name=sequence>심플 셀렉터 시퀀스</a></dfn>는
    <a href="#combinators">콤비네이터</a>로 구분되지 않은 <a
   href="#simple-selectors-dfn">심플 셀렉터</a> 체인입니다.
    이는 항상 <a href="#type-selectors">타입 셀렉터</a>나
    <a href="#universal-selector">전역 셀렉터</a>로 시작합니다.
    다른 타입 셀렉터나 전역 셀렉터를 시퀀스에서 허용하지 않습니다.
  </p>
  <p lang="en">A <a name=sequence>sequence of
   simple selectors</a> is a chain of <a
   href="#simple-selectors-dfn">simple selectors</a> that are not separated
   by a <a href="#combinators">combinator</a>. It always begins with a <a
   href="#type-selectors">type selector</a> or a <a
   href="#universal-selector">universal selector</a>. No other type selector
   or universal selector is allowed in the sequence.
  
       
  <p lang="ko"><dfn id=simple-selector><a name=simple-selectors-dfn></a><a
   href="#simple-selectors">심플 셀렉터</a></dfn>는 <a
   href="#type-selectors">타입 셀렉터</a>, <a
   href="#universal-selector">전역 셀렉터</a>, <a
   href="#attribute-selectors">속성 셀렉터</a>, <a
   href="#class-html">클래스 셀렉터</a>, <a href="#id-selectors">ID
   셀렉터</a>, 혹은 <a href="#pseudo-classes">의사 클래스</a> 중 하나입니다.

  <p lang="en">A <dfn><a name=simple-selectors-dfn></a><a
   href="#simple-selectors">simple selector</a></dfn> is either a <a
   href="#type-selectors">type selector</a>, <a
   href="#universal-selector">universal selector</a>, <a
   href="#attribute-selectors">attribute selector</a>, <a
   href="#class-html">class selector</a>, <a href="#id-selectors">ID
   selector</a>, or <a href="#pseudo-classes">pseudo-class</a>.
  
  <p lang="ko"><dfn id=combinators0>콤비네이터</dfn>는: 공백 문자,
   &quot;~보다 큰 기호&quot; (U+003E, <code>&gt;</code>), &quot;덧셈 기호&quot; (U+002B, <code>+</code>) 및 &quot;물결표시&quot; (U+007E,
   <code>~</code>)입니다. 콤비네이터와 심플 셀렉터 사이에 공백 문자를 표시할 수 있습니다.
    <a name=whitespace></a>공백 문자에는
   "space" (U+0020), "tab" (U+0009), "line feed" (U+000A), "carriage return"
   (U+000D), "form feed" (U+000C) 문자만 사용할 수 있습니다.
    
   "em-space" (U+2003)나 "ideographic space"(U+3000) 같은
    다른 공백과 비슷한 문자는 공백 문자로 사용할 수 없습니다.

  <p lang="en"><dfn>Combinators</dfn> are: whitespace,
   &quot;greater-than sign&quot; (U+003E, <code>&gt;</code>), &quot;plus
   sign&quot; (U+002B, <code>+</code>) and &quot;tilde&quot; (U+007E,
   <code>~</code>). White space may appear between a combinator and the
   simple selectors around it. <a name=whitespace></a>Only the characters
   "space" (U+0020), "tab" (U+0009), "line feed" (U+000A), "carriage return"
   (U+000D), and "form feed" (U+000C) can occur in whitespace. Other
   space-like characters, such as "em-space" (U+2003) and "ideographic space"
   (U+3000), are never part of whitespace.
  <p lang="ko">셀렉터로 인해 나타나는 문서 내 요소는 
    <dfn id=subjects-of-the-selector><a name=subject></a>셀렉터 대상</dfn>이라 부릅니다.
    하나의 심플 셀렉터 시퀀스로 구성된 셀렉터는 요구사항을 만족하는 어떤 요소라도 나타냅니다.
    여기에 새로운 심플 셀렉터 시퀀스를 주어, 이를 콤비네이터로 엮은 케이스는, 매치하는 제한을 더합니다.
    이렇게하면 셀렉터 대상은 항상 마지막 심플 셀렉터 시퀀스로 표현된 요수의 일부가 됩니다.
  </p>
  <p lang="en">The elements of a document tree that are represented by a selector are
   the <dfn><a name=subject></a>subjects of the
   selector</dfn>. A selector consisting of a single sequence of simple
   selectors represents any element satisfying its requirements. 
    Prepending another sequence of simple selectors and a combinator to a sequence
   imposes additional matching constraints, so the subjects of a selector are
   always a subset of the elements represented by the last sequence of simple
   selectors.
  <p lang="ko">빈 셀렉터, 심플 셀렉터 시퀀스를 포함하지 않았거나 의사 요소가 없는 경우에
    <a href="#Conformance">유효하지 않은 셀렉터</a>가 됩니다.
  <p lang="en">An empty selector, containing no sequence of simple selectors and no
   pseudo-element, is an <a href="#Conformance">invalid selector</a>.
  <p lang="ko">셀렉터 내 문자는 CSS의 <a href="http://www.w3.org/TR/CSS21/syndata.html#characters">escaping rules</a>와
    동일하게 백슬래쉬와 함께 해석할 수 있습니다 <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>.
  <p lang="en">Characters in Selectors can be escaped with a backslash according to the
   same <a href="http://www.w3.org/TR/CSS21/syndata.html#characters">escaping
   rules</a> as CSS. <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>.
  <p lang="ko" id=nsdecl>
    몇가지 셀렉터는 네임스페이스 접두사를 지원합니다.
    어떤 네임스페이스 접두사가 <dfn id=declared>선언</dfn>되었는지 알기 위한 메커니즘은
    셀렉터를 이용하는 언어에 의해 정해져야만 합니다.
    만약 언어가 네임스페이스 접두사 메커니즘을 정의하지 않은 경우, 접두사는 선언되지 않습니다.
    CSS에서, 네임스페이스 접두사는 <a
   href="http://www.w3.org/TR/css3-namespace/#declaration"><code>@namespace</code></a> 룰에 따라
    선언합니다. <a href="#CSS3NAMESPACE"
   rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>
  </p>
  <p lang="en">Certain selectors support namespace prefixes. The mechanism by
   which namespace prefixes are <dfn> declared</dfn> should be
   specified by the language that uses Selectors. If the language does not
   specify a namespace prefix declaration mechanism, then no prefixes are
   declared. In CSS, namespace prefixes are declared with the <a
   href="http://www.w3.org/TR/css3-namespace/#declaration"><code>@namespace</code></a>
   rule. <a href="#CSS3NAMESPACE"
   rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>

  <h2 id=grouping><span class=secno>5. </span>셀렉터 그룹</h2>
  <p lang=ko>콤마로 구분한 셀렉터의 목록은 리스트 안의 각 셀렉터로 인해 가져온 모든 요소의 연합을 나타냅니다. (콤마는 U+002C)
  예를 들어, CSS에서 같은 선언을 공유하는 여러개의 셀렉터를 가질 때, 콤마로 구분된 목록으로 그룹핑 할 수 있습니다.
  공백 문자는 콤마의 앞 뒤에 존재할 수 있습니다.
  <p lang=en>A comma-separated list of selectors represents the union of all elements
   selected by each of the individual selectors in the list. (A comma is
   U+002C.) For example, in CSS when several selectors share the same
   declarations, they may be grouped into a comma-separated list. White space
   may appear before and/or after the comma.

  <div class=example>
   <p>CSS 예제:</p>

   <p>이 예제에서, 동일한 선언을 나타내는 세개의 규칙을 하나로 정리합니다.</p>

   <pre>h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

   <p>이는 아래와 같습니다.</p>

   <pre>h1, h2, h3 { font-family: sans-serif }</pre>
  </div>

  <p lang="ko"><strong>주의</strong>: 
    이 예제가 true인 이유는 예제의 셀렉터가 모두 유효한 셀렉터이기 때문입니다.
    만약 이 예제 중 하나라도 유효하지 않다면, 모든 셀렉터 그룹은 유효하지 않다고 간주어집니다.
    후자에서 그렇게 되면, 3개 헤딩 요소 모두 규칙이 유효하지 않다고 간주합니다.
    전자에서는 그렇게 되더라도, 유효하지 않은 셀렉터를 가진 규칙만 유효하지 않다고 간주어지니다.
  <p lang="en"><strong>Warning</strong>: the equivalence is true in this example
   because all the selectors are valid selectors. If just one of these
   selectors were invalid, the entire group of selectors would be invalid.
   This would invalidate the rule for all three heading elements, whereas in
   the former case only one of the three individual heading rules would be
   invalidated.

  <div class=example>
   <p>유효하지 않은 CSS 예제:</p>

   <pre>h1 { font-family: sans-serif }
h2..foo { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

   <p>이는 아래와 동일하지 않습니다:</p>

   <pre>h1, h2..foo, h3 { font-family: sans-serif }</pre>

   <p>왜냐하면 위 셀렉터(<code>h1, h2..foo, h3</code>)는 모든 규칙을 유효하지 않다고 간주하여 모든 스타일 규칙을 적용하지 않기 때문입니다.
     (셀렉터를 그룹화하지 않았을 때, <code>h2..foo</code> 룰만 적용하지 않습니다.)
   </p>
  </div>

  <h2 id=simple-selectors><span class=secno>6. </span>심플 셀렉터</h2>

  <h3 id=type-selectors><span class=secno>6.1. </span>타입 셀렉터</h3>
  <p lang=ko><dfn id=type-selector>타입 셀렉터</dfn>는 <a
   href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
    names</a> 문법을 이용해 작성한 문서 언어 요소 타입 이름입니다. <a href="#CSS3NAMESPACE"
   rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>
   타입 셀렉터는 문서 트리 안에 있는 요소 타입의 인스턴스를 나타냅니다.
  <p lang=en>A <dfn>type selector</dfn> is the name of a document
   language element type written using the syntax of <a
   href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
   names</a> <a href="#CSS3NAMESPACE"
   rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>. A type
   selector represents an instance of the element type in the document tree.

  <div class=example>
   <p>예제:</p>

   <p>아래 셀렉터는 문서 트리 안에 있는 <code>h1</code> 요소를 나타냅니다:</p>

   <pre>h1</pre>
  </div>

  <h4 id=typenmsp><span class=secno>6.1.1. </span>타입 셀렉터와 네임스페이스</h4>
  <p lang=ko>타입 셀렉터는 옵션으로 네임스페이스 컴포넌트 사용을 허용합니다:
    네임스페이스 컴포넌트는 사전에 <a href="#nsdecl">선언</a>된 네임스페이스 접두사와 요소명을
    네임스페이스 구분자 &quot;vertical bar&quot; (U+007C, <code>|</code>)로 구분한 것을 나타냅니다.
    (XML에서 사용하는 네임스페이스 이용 예시는 <a href="#XML-NAMES" rel=biblioentry>[XML-NAMES]<!--{{XML-NAMES}}--></a>를 참고하시길 바랍니다)
    
  <p lang=en>Type selectors allow an optional namespace component: a namespace prefix
   that has been previously <a href="#nsdecl">declared</a> may be prepended
   to the element name separated by the namespace separator &quot;vertical
   bar&quot; (U+007C, <code>|</code>). (See, e.g., <a href="#XML-NAMES"
   rel=biblioentry>[XML-NAMES]<!--{{XML-NAMES}}--></a> for the use of
   namespaces in XML.)

  <p lang=ko>셀렉터가 어떤 네임스페이스에도 속하지 않는 요소를 나타내기 위해,
    네임스페이스 컴포넌트는 빈 (접두사와 구분자를 가지지 않는) 상태로 있어도 좋습니다
  <p lang=en>The namespace component may be left empty (no prefix before the
   namespace separator) to indicate that the selector is only to represent
   elements with no namespace.
  <p lang=ko>셀렉터가 네임스페이스 접두사와 상관없이 (네임스페이스가 없는 요소도 포함하여) 요소를 선택 가능하도록 하기 위해,
    네임스페이스 접두사에 별표를 사용할 수 있습니다.
  <p lang=en>An asterisk may be used for the namespace prefix, indicating that the
   selector represents elements in any namespace (including elements with no
   namespace).
  <p lang="ko">네임스페이스 컴포넌트를 가지지 않는 (네임스페이스 구분자를 갖지 않는) 타입 셀렉터는
    네임스페이스에 속하지 않는 요소("<code>*|</code>"와 동등)를 나타냅니다.
    그러나, 네임스페이스 가지는 셀렉터 (CSS 스타일 시트 등) 기본 네임스페이스가 <a href="#nsdecl">선언</a>된 경우에는 이와 다릅니다.
    기본 네임스페이스가 선언된 경우, 네임스페이스를 가지지 않는 타입 셀렉터는 기본 네임스페이스 내 요소만을 나타냅니다.
  <p lang=en>Element type selectors that have no namespace component (no namespace
   separator) represent elements without regard to the element's namespace
   (equivalent to "<code>*|</code>") unless a default namespace has been <a
   href="#nsdecl">declared</a> for namespaced selectors (e.g. in CSS, in the
   style sheet). If a default namespace has been declared, such selectors
   will represent only elements in the default namespace.
  <p lang=ko>타입 셀렉터가 네임스페이스 접두사를 가지면서, 그 접두사에 대응하는 네임스페이스가 <a href="#nsdecl">정의</a>되어있지 안않다면
    그 셀렉터는 <a href="#Conformance">유효하지 않은</a> 셀렉터입니다.
  <p lang=en>A type selector containing a namespace prefix that has not been
   previously <a href="#nsdecl">declared</a> for namespaced selectors is an
   <a href="#Conformance">invalid</a> selector.
  <p lang=ko>네임스페이스를 이해하는 클라이언트에서, 타입 셀렉터의 요소명 부분 (네임스페이스 구분자 이후 부분)은 <a
   href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">수식명</a>의 <a
   href="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a>에만 대응해 매치합니다.
  <p lang=en>In a namespace-aware client, the name part of element type selectors
   (the part after the namespace separator, if it is present) will only match
   against the <a
   href="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a> of
   the element's <a
   href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">qualified
   name</a>.

  <p>이를 요약하면:

  <dl>
   <dt><code>ns|E</code>

  <dd>네임스페이스 ns 안에 E라는 이름을 가진 요소 <div lang=en>elements with name E in namespace ns</div>

   <dt><code>*|E</code>

   <dd>네임스페이스를 가지지 않는 것을 포함하여, 모든 네임스페이스 안의 E라는 이름을 가진 요소 <div lang=en>elements with name E in any namespace, including those without a namespace</div>

   <dt><code>|E</code>

   <dd>네임스페이스를 가지지 않는 E라는 이름을 가진 요소<div lang=en>elements with name E without a namespace</div>

   <dt><code>E</code>

   <dd>
    셀렉터에 대한 기본 네임스페이스가 <a href="#nsdecl">정의</a>되어있지 않은 경우를 나타내며 이는 *|E와 동등합니다.
    그 외의 경우에는 기본 네임스페이스를 ns로 하며 ns|E와 동일하게 취급합니다.
  </dl>

  <div class=example>
   <p>CSS 예제:</p>

   <pre>@namespace foo url(http://www.example.com);
 foo|h1 { color: blue }  /* first rule */
 foo|* { color: yellow } /* second rule */
 |h1 { color: red }      /* ...*/
 *|h1 { color: green }
 h1 { color: green }</pre>

   <p>
    (<code>@namespace</code> 규칙을 포함하지 않는) 첫번째 룰은 
    "http://www.example.com" 네임스페이스 내 <code>h1</code> 요소에만 매치할 것입니다.
    <span lang=en>The first rule (not counting the <code>@namespace</code> at-rule) will
    match only <code>h1</code> elements in the "http://www.example.com"
    namespace.</span>
  </p>

   <p>
     두번째 규칙은 "http://www.example.com" 네임스페이스 내 모든 요소에 매치할 것입니다.
    <span lang="en">The second rule will match all elements in the "http://www.example.com"
    namespace.</span></p>

   <p>
    세번째 규칙은 네임스페이스를 가지지 않는 <code>h1</code> 요소에만 매치할 것입니다.
    <span lang=en>The third rule will match only <code>h1</code> elements with no
      namespace.</span></p>

   <p>
    네번째 규칙은 (네임스페이스를 가지지 않는 것을 포함한) 어떤 네임스페이스 내의 <code>h1</code> 요소에도 매치할 것입니다.
    <span lang=en>The fourth rule will match <code>h1</code> elements in any namespace
    (including those without any namespace).</span></p>

   <p>
    마지막 규칙은 기본 네임스페이스를 정의하지 않았기 때문에 네번째 규칙과 동일합니다.
    <span lang=en>The last rule is equivalent to the fourth rule because no default
    namespace has been defined.</span></p>
  </div>

  <h3 id=universal-selector><span class=secno>6.2. </span>전역 셀렉터</h3>

  <p lang=ko>
   로컬명으로 별표(<code>*</code> U+002A)와 함께 <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
   name</a> <a href="#CSS3NAMESPACE" rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>으로써 작성된
   <dfn id=universal-selector0>전역셀렉터</dfn>는, 모든 요소 타입의 수식명을 나타냅니다.
    
   이는 기본 네임스페이스가 셀렉터에 대해 지정되어있는 경우를 제외하고, 
   (네임스페이스가 없는 것을 포함한) 모든 네임스페이스 내 문서 트리 안 모든 개별 요소를 나타냅니다.
    
   만약 기본 네임스페이스가 정의되어 있다면,
   <a href="#univnmsp">전역 셀렉터와 네임스페이스</a>를 참고하시길 바랍니다.
  
  <p lang=en>The <dfn>universal selector</dfn>, written as a
   <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
   name</a> <a href="#CSS3NAMESPACE"
   rel=biblioentry>[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a> with an
   asterisk (<code>*</code> U+002A) as the local name, represents the
   qualified name of any element type. It represents any single element in
   the document tree in any namespace (including those without a namespace)
   if no default namespace has been specified for selectors. If a default
   namespace has been specified, see <a href="#univnmsp">Universal selector
   and Namespaces</a> below.
  <p lang=ko>전역셀렉터 <code>*</code>이, (즉 네임스페이스 접두사를 갖지 않는)
    <a href="#sequence">심플 셀렉터 시퀀스</a> 내 컴포넌트 하나가 아니며,
    바로 뒤에 <a href="#pseudo-elements">의사 요소</a>가 존재하지 않는 경우,
    그 *을 생략하여 전역 셀렉터의 존재를 나타내도 무관합니다.
  <p lang=en>If a universal selector represented by <code>*</code> (i.e. without a
   namespace prefix) is not the only component of a <a
   href="#sequence">sequence of simple selectors</a> selectors or is
   immediately followed by a <a href="#pseudo-elements">pseudo-element</a>,
   then the <code>*</code> may be omitted and the universal selector's
   presence implied.

  <div class=example>
   <p>예제:</p>

   <ul>
    <li><code>*[hreflang|=en]</code>과 <code>[hreflang|=en]</code>는 동일하며,

    <li><code>*.warning</code>과 <code>.warning</code>은 동일하며,

    <li><code>*#myid</code>와 <code>#myid</code>은 동일합니다.
   </ul>
  </div>
  <p class=note lang=ko><strong>노트:</strong>혼란을 피하기 위해 <code>*</code>을 생략하지 않는걸 권장합니다.
   예를 들어 <code style="white-space: nowrap">div :first-child</code>과 <code style="white-space:nowrap">div:first-child</code>를
   생각해보면 이해가 빠릅니다. 여기서 <code style="white-space:nowrap">div *:first-child</code>가 더 가독성이 좋을 것입니다.
  <span lang=en><strong>Note:</strong> it is recommended that the
   <code>*</code> not be omitted, because it decreases the potential
   confusion between, for example, <code style="white-space: nowrap">div
   :first-child</code> and <code style="white-space:
   nowrap">div:first-child</code>. Here, <code style="white-space:
   nowrap">div *:first-child</code> is more readable.</span>

  <h4 id=univnmsp><span class=secno>6.2.1. </span>전역 셀렉터와 네임스페이스</h4>

  <p>전역 셀렉터는 옵션적으로 네임스페이스 컴포넌트 사용을 허용합니다.
    이는 다음과 같이 사용합니다.
    <span lang=en>The universal selector allows an optional namespace component. It is
      used as follows:</span>

  <dl>
   <dt><code>ns|*</code>

   <dd>네임스페이스 ns 내 모든 요소 <div lang=en>all elements in namespace ns</div>

   <dt><code>*|*</code>

   <dd>모든 요소 <div lang=en>all elements</div>

   <dt><code>|*</code>

   <dd>네임스페이스를 가지지 않는 모든 요소 <div lang=en>all elements without a namespace</div>

   <dt><code>*</code>

   <dd>
    기본 네임스페이스가 선언되어있지 않은 경우, 이는 *|*과 동일합니다.
    그 외의 경우, ns는 기본 네임스페이스로 간주하여 ns|*와 동일합니다.
    <div lang=en>if no default namespace has been specified, this is equivalent to *|*.
    Otherwise it is equivalent to ns|* where ns is the default namespace.</div>
  </dl>
  <p lang=ko><a href="#nsdecl">선언</a>되지 않은 네임 스페이스를 포함한 전역 셀렉터는 <a
   href="#Conformance">유효하지 않은</a> 셀렉터 입니다.
  <p lang=en>A universal selector containing a namespace prefix that has not been
   previously <a href="#nsdecl">declared</a> is an <a
   href="#Conformance">invalid</a> selector.

  <h3 id=attribute-selectors><span class=secno>6.3. </span>속성 셀렉터</h3>
  <p lang=ko>셀렉터는 요소 속성 표현도 가능합니다.
    셀렉터를 요소에 매치하는 표현식으로 사용할 떄,
    속성 셀렉터는 그 셀렉터에 의해 표현하는 속성에 매치하는 속성을 가진 요소에 매치합니다.
  <p lang=en>Selectors allow the representation of an element's attributes. When a
   selector is used as an expression to match against an element, attribute
   selectors must be considered to match an element if that element has an
   attribute that matches the attribute represented by the attribute
   selector.

  <h4 id=attribute-representation><span class=secno>6.3.1. </span>속성 의존 셀렉터와 속성값 셀렉터</h4>

  <p>CSS2는 네 속성 셀렉터를 소개합니다:

  <dl>
   <dt><code>[att]</code>

   <dd>Represents an element with the <code>att</code> 속성을 가진 요소를 나타내며, 속성값은 무관합니다.
    <div lang=en>Represents an element with the <code>att</code> attribute, whatever
    the value of the attribute.</div>

   <dt><code>[att=val]</code>

   <dd>
    <code>att</code> 속성을 가지며 속성의 값이 "val"와 일치하는 요소를 나타냅니다.
    <div lang=en>Represents an element with the <code>att</code> attribute whose value
    is exactly "val".</div>

   <dt><code>[att~=val]</code>
   <dd>
    <code>att</code> 속성을 가지며 속성의 값이 <a href="#whitespace">공백 문자</a>로 구분된 문자의 목록일 때,
    목록 중 하나가 "val"와 일치하는 요소를 나타냅니다.
    만약 "val"이 빈 문자열이라면, 그 무엇도 표현하지 않습니다.
    
    <div lang=en>Represents an element with the <code>att</code> attribute whose value
    is a <a href="#whitespace">whitespace</a>-separated list of words, one of
    which is exactly "val". If "val" contains whitespace, it will never
    represent anything (since the words are <em>separated</em> by spaces).
    Also if "val" is the empty string, it will never represent anything.</div>

   <dt><code>[att|=val]</code>
   
   <dd>
    <code>att</code> 속성을 가지며,
    그 값이 "val" 혹은, "val"에 이어 "-"(U+002D) 문자열로 이어지는 문자열로 시작하는 요소를 나타냅니다.
    이 셀렉터는 특히, BCP 47 (<a href="#BCP47"
    rel=biblioentry>[BCP47]<!--{{BCP47}}--></a>) 혹은 그 개정판에서 정의하는
     언어의 서브코드 매칭(HTML <code>a</code> 요소의 <code>hreflang</code> 속성 등)을 할 수 있게 이루어져 있습니다.
    <code>lang</code> (혹은 <code>xml:lang</code>)속성에 의한 언어 서브코드 매칭은
    <a href="#lang-pseudo">the <code>:lang</code> 의사 클래스</a>를 확인하시길 바랍니다.
     
    <div lang="en">Represents an element with the <code>att</code> attribute, its value
    either being exactly "val" or beginning with "val" immediately followed
    by "-" (U+002D). This is primarily intended to allow language subcode
    matches (e.g., the <code>hreflang</code> attribute on the <code>a</code>
    element in HTML) as described in BCP 47 (<a href="#BCP47"
    rel=biblioentry>[BCP47]<!--{{BCP47}}--></a>) or its successor. For
    <code>lang</code> (or <code>xml:lang</code>) language subcode matching,
    please see <a href="#lang-pseudo">the <code>:lang</code>
    pseudo-class</a>.</div>
  </dl>
  
  <p lang=ko>속성명은 반드시 CSS 
   <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">식별자</a>나
   <a href="http://www.w3.org/TR/CSS21/syndata.html#strings">문자열</a>이여야 합니다.
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a> 
   셀렉터 내의 속성명과 값의 대소문자 구별에 관해서는 문서 언어에 의존합니다.
    
  <p lang=en>Attribute values must be CSS <a
   href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>
   or <a href="http://www.w3.org/TR/CSS21/syndata.html#strings">strings</a>.
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a> The
   case-sensitivity of attribute names and values in selectors depends on the
   document language.

  <div class=example>
   <p>예제:</p>

   <p>
     아래 예제는 <code>title</code> 속성을 갖고 있는 <code>h1</code> 요소를 나타내며, 값은 상관 없습니다:
    <span lang=en>The following attribute selector represents an <code>h1</code> element
      that carries the <code>title</code> attribute, whatever its value:</span></p>

   <pre>h1[title]</pre>

   <p>
    아래 예제에서, 셀렉터는 <code>class</code> 속성을 가지고 그 값이 정확히 "example"과 일치하는
     <code>span</code> 요소를 나타냅니다.
    <span lang=en>In the following example, the selector represents a <code>span</code>
    element whose <code>class</code> attribute has exactly the value
    "example":</span></p>

   <pre>span[class="example"]</pre>

   <p>
    하나의 요소의 여러가지 속성을 나타내거나, 같은 속성에 다른 조건을 주기 위해 다중 속성 셀렉터를 사용할 수 있습니다.
    다음 예제에서 셀렉터는 <code>hello</code> 속성을 가지며 그 값이 "Cleveland"이고,
    <code>goodbye</code> 속성을 가지며 그 값이 "Columbus"인 <code>span</code> 요소를 나타냅니다.
    <span lang="en">
    Multiple attribute selectors can be used to represent several
    attributes of an element, or several conditions on the same attribute.
    Here, the selector represents a <code>span</code> element whose
    <code>hello</code> attribute has exactly the value "Cleveland" and whose
    <code>goodbye</code> attribute has exactly the value "Columbus":</span></p>

   <pre>span[hello="Cleveland"][goodbye="Columbus"]</pre>

   <p>
    다음 CSS 규칙은 "="과 "~=" 사이의 차이점에 대해 소개합니다.
     첫번째 셀렉터는 <code>a</code> 요소의 <code>rel</code> 속성 값이
     "copyright copyleft copyeditor"인 경우 매치할 것이며,
     두번째 셀렉터는 <code>a</code> 요소의 <code>href</code> 속성 값이 정확히
     "http://www.w3.org/"인 경우 매치할 것입니다.
    <span lang=en>The following CSS rules illustrate the differences between "=" and
    "~=". The first selector would match, for example, an <code>a</code>
    element with the value "copyright copyleft copyeditor" on a
    <code>rel</code> attribute. The second selector would only match an
    <code>a</code> element with an <code>href</code> attribute having the
    exact value "http://www.w3.org/".</span></p>

   <pre>a[rel~="copyright"] { ... }
a[href="http://www.w3.org/"] { ... }</pre>

   <p>
    다음 셀렉터는 <code>a</code> 요소의 <code>hreflang</code> 속성이 정확히 "fr"인 경우를 나타냅니다.
    <span lang=en>The following selector represents an <code>a</code> element whose
    <code>hreflang</code> attribute is exactly "fr".</span></p>

   <pre>a[hreflang=fr]</pre>

   <p>
    다음 셀렉터는 <code>a</code> 요소의 <code>hreflang</code> 속성이 "en"으로 시작하는 것을 나타내며,
    이는 "en", "en-US", "en-scouse"를 포함합니다.
    <span lang="en">The following selector represents an <code>a</code> element for which
    the value of the <code>hreflang</code> attribute begins with "en",
    including "en", "en-US", and "en-scouse":</span></p>

   <pre>a[hreflang|="en"]</pre>

   <p>
    다음 셀렉터는 <code>character</code> 속성에
    두개의 다른 값 중 하나를 가질 수 있는 <code>DIALOGUE</code> 요소를 나타냅니다.
    <span lang="en">The following selectors represent a <code>DIALOGUE</code> element
    whenever it has one of two different values for an attribute
    <code>character</code>:</span></p>

   <pre>DIALOGUE[character=romeo]
DIALOGUE[character=juliet]</pre>
  </div>

  <h4 id=attribute-substrings><span class=secno>6.3.2. </span>부분 매칭 속성 셀렉터</h4>

  <p lang=ko>
    속성 값에 부분 매칭하기 위한 세 추가 셀렉터를 제공합니다.
  <p lang=en>
   Three additional attribute selectors are provided for matching
   substrings in the value of an attribute:

  <dl>
   <dt><code>[att^=val]</code>

   <dd>
    <code>att</code> 속성을 가지며 해당 속성 값이 "val" 접두사로 시작하는 요소를 나타냅니다.
     만약 "val"이 빈 문자열이라면 셀렉터는 아무 것도 나타내지 않습니다.
    <div lang=en>
    Represents an element with the <code>att</code> attribute whose value
    begins with the prefix "val". If "val" is the empty string then the
    selector does not represent anything.</div>

   <dt><code>[att$=val]</code>

   <dd>
    <code>att</code> 속성을 가지며 해당 속성 값이 "val" 접미사로 끝나는 요소를 나타냅니다.
    만약 "val"이 빈 문자열이라면 셀렉터는 아무 것도 나타내지 않습니다.
    <div lang=en>
    Represents an element with the <code>att</code> attribute whose value
    ends with the suffix "val". If "val" is the empty string then the
    selector does not represent anything.</div>
     
   <dt><code>[att*=val]</code>
   
   <dd>
    <code>att</code> 속성을 가지며 해당 속성 값이 "val" 부분 문자열을 최소 1개 이상 포함하는 요소를 나타냅니다.
     만약 "val"이 빈 문자열이라면 셀렉터는 아무 것도 나타내지 않습니다.
    <div lang=en>
    Represents an element with the <code>att</code> attribute whose value
    contains at least one instance of the substring "val". If "val" is the
    empty string then the selector does not represent anything.</div>
  </dl>
  <p lang=ko>속성명은 반드시 CSS 
   <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">식별자</a>나
   <a href="http://www.w3.org/TR/CSS21/syndata.html#strings">문자열</a>이여야 합니다.
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a> 
   셀렉터 내의 속성명과 값의 대소문자 구별에 관해서는 문서 언어에 의존합니다.
    
  <p lang=en>
   Attribute values must be CSS <a
   href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>
   or <a href="http://www.w3.org/TR/CSS21/syndata.html#strings">strings</a>.
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a> The
   case-sensitivity of attribute names in selectors depends on the document
   language.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 image를 참조하는 HTML <code>object</code> 객체를 나타냅니다.
    <span lang=en>The following selector represents an HTML <code>object</code>,
    referencing an image:</span></p>

   <pre>object[type^="image/"]</pre>

   <p>
    아래 셀렉터는 <code>href</code> 속성 값이 ".html"로 끝나는 HTML 앵커 <code>a</code> 요소를 나타냅니다.
    <span lang=en>The following selector represents an HTML anchor <code>a</code> with an
    <code>href</code> attribute whose value ends with ".html".</span></p>

   <pre>a[href$=".html"]</pre>

   <p>
    아래 셀렉터는 <code>title</code> 속성의 값에 "hello" 부분 문자열을 포함하는 HTML 문장(p요소)을 나타냅니다.
    <span lang="en">The following selector represents an HTML paragraph with a
    <code>title</code> attribute whose value contains the substring "hello"</span></p>

   <pre>p[title*="hello"]</pre>
  </div>

  <h4 id=attrnmsp><span class=secno>6.3.3. </span>속성 셀렉터와 네임스페이스</h4>
  <p lang=ko>
    셀렉터 내의 속성명은 <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS 수식명</a>으로써 제공됩니다:
    네임스페이스가 사전에 <a href="#nsdecl">선언</a>된 경우,
    속성명 앞에 접두사를 네임스페이스 구분자&quot;vertical bar&quot; (<code>|</code>)로 구분해 표현하는 것이 가능합니다.
    XML 내 네임스페이스 권고안과 스펙을 맞추기 위해, 기본 네임스페이스는 속성에 사용하지 않습니다.
    즉, 네임스페이스 컴포넌트를 가지지 않는 속성 셀렉터는, 네임스페이스에 속하지 않는 속성만 사용합니다
    (이는 "<code>|attr</code>"과 동일합니다. 또 이 속성은 "per-element-type namespace partition"에 있다고 간주합니다).
    셀렉터가 네임스페이스에 상관없이 모든 속성에 매치한다는 걸 나타내고 싶을 때, 별표를 네임스페이스 접두사로 사용할 수 있습니다.
  <p lang=en>The attribute name in an attribute selector is given as a <a
   href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
   name</a>: a namespace prefix that has been previously <a
   href="#nsdecl">declared</a> may be prepended to the attribute name
   separated by the namespace separator &quot;vertical bar&quot;
   (<code>|</code>). In keeping with the Namespaces in the XML
   recommendation, default namespaces do not apply to attributes, therefore
   attribute selectors without a namespace component apply only to attributes
   that have no namespace (equivalent to "<code>|attr</code>"; these
   attributes are said to be in the "per-element-type namespace partition").
   An asterisk may be used for the namespace prefix indicating that the
   selector is to match all attribute names without regard to the attribute's
   namespace.
  <p lang=ko>속성 셀렉터 내의 속성명에 네임스페이스 접두사르 가지면서,
    그 접두사에 대한 <a href="#nsdecl">선언</a>을 하지 않은 경우, 
    이는 <a href="#Conformance">유효하지 않은</a> 셀렉터입니다.
  <p lang=en>An attribute selector with an attribute name containing a namespace
   prefix that has not been previously <a href="#nsdecl">declared</a> is an
   <a href="#Conformance">invalid</a> selector.

  <div class=example>
   <p>CSS 예제:</p>

   <pre>@namespace foo "http://www.example.com";
[foo|att=val] { color: blue }
[*|att] { color: yellow }
[|att] { color: green }
[att] { color: green }</pre>

   <p>
    첫번째 규칙은 "http://www.example.com" 네임스페이스 안에서 <code>att</code>  속성을 가지며, 
    값이 "val"인 요소를 나타냅니다.
    <span lang=en>The first rule will match only elements with the attribute
    <code>att</code> in the "http://www.example.com" namespace with the value
    "val".</span></p>

   <p>
    두번째 규칙은 (네임스페이스가 없는 걸 포함하여) 네임스페이스에 상관 없이 <code>att</code> 속성을 가지는
     요소를 나타냅니다.
    <span lang=en>The second rule will match only elements with the attribute
    <code>att</code> regardless of the namespace of the attribute (including
    no namespace).</span></p>

   <p>
    마지막 두 규칙은 동일하며, 네임스페이스에 속하지 않는 <code>att</code> 속성을 가진 요소를 나타냅니다.
    <span lang="en">The last two rules are equivalent and will match only elements with the
    attribute <code>att</code> where the attribute is not in a namespace.</span></p>
  </div>

  <h4 id=def-values><span class=secno>6.3.4. </span>DTD 내 기본 속성값</h4>
  <p lang=ko>
    속성 셀렉터는 문서 트리 내의 속성 값을 나타냅니다.
    문서 트리가 어떻게 구축되어 있는 지는 셀렉터 스펙의 범위 밖입니다.
    몇몇 문서 포맷은 DTD 혹은 그 외의 방법으로 속성의 기본값을 정의 가능하지만,
    속성 셀렉터를 이용해 선택 가능한 건 기본 값이 문서 트리에 나타날 때 뿐입니다.
    이를 위해, 문서 트리에 기본 값이 있던 없던 동작 가능하도록 셀렉터를 설계하고 있습니다.
  <p lang=en>Attribute selectors represent attribute values in the document tree. How
   that document tree is constructed is outside the scope of Selectors. In
   some document formats default attribute values can be defined in a DTD or
   elsewhere, but these can only be selected by attribute selectors if they
   appear in the document tree. Selectors should be designed so that they
   work whether or not the default values are included in the document tree.
  <p lang=ko>예를 들어, XML UA는 <em>필수는 아니지만</em> DTD의 "외부 서브셋"을 읽어올 수 있습니다.
    그러나 문서 "내부 서브셋" 안의 어떤 속성 기본 값을 찾는 데는 DTD가 필수입니다.
    (서브셋 정의에 관련된 내용은 <a href="#XML10" rel=biblioentry>[XML10]<!--{{XML10}}--></a> 참고)
    DTD의 외부 서브셋에 의해 정의된 속성의 기본 값은, UA에 따라 문서 트리에 나타나거나, 나타나지 않거나 할 것입니다.
  <p lang=en>For example, a XML UA may, but is <em>not</em> required to read an
   "external subset" of the DTD but <em>is</em> required to look for default
   attribute values in the document's "internal subset." (See, e.g., <a
   href="#XML10" rel=biblioentry>[XML10]<!--{{XML10}}--></a> for definitions
   of these subsets.) Depending on the UA, a default attribute value defined
   in the external subset of the DTD might or might not appear in the
   document tree.
  <p lang=ko>XML 네임스페이스를 이해하는 UA는 필수는 아니지만, 네임스페이스를 이용해서 속성의 기본값이
    문서 트리 안에 나타나고 있는 듯 표현하는 게 가능합니다.
    (예를 들어, XHTML UA는 XHTML DTD의 정의를 이용하지 않아도 됩니다.
    자세한 내용은 Namespaces in XML 1.0을 참조하시길 바랍니다. <a href="#XML-NAMES" rel=biblioentry>[XML-NAMES]<!--{{XML-NAMES}}--></a>
  <p lang=en>A UA that recognizes an XML namespace may, but is not required to use
   its knowledge of that namespace to treat default attribute values as if
   they were present in the document. (For example, an XHTML UA is not
   required to use its built-in knowledge of the XHTML DTD. See, e.g., <a
   href="#XML-NAMES" rel=biblioentry>[XML-NAMES]<!--{{XML-NAMES}}--></a> for
   details on namespaces in XML 1.0.)
  <p class=note lang=ko><strong>노트:</strong> 일반적으로, 구현체는 외부 서브셋을 무시합니다.
    이는 XML 스펙에 있어 유효성 검사를 진행하지 않은 서브셋의 동작과 일치합니다.
  <p class=note lang=en><strong>Note:</strong> Typically, implementations choose to
   ignore external subsets. This corresponds to the behaviour of
   non-validating processors as defined by the XML specification.
  <div class=example>
   <p>예제:</p>

   <p>
    <code>radix</code> 속성의 기본 값이 <code>"demical"</code>인 요소 <code>EXAMPLE</code>이 있다고 했을 때,
    DTD는 아래와 같이 구성합니다.
    <span lang=en> Consider an element <code>EXAMPLE</code> with an attribute <code>radix</code> that has a default value of <code>"decimal"</code>. The DTD fragment might be </span>
   </p>

   <pre
    class=dtd-example>&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"></pre>

   <p>
     여기서 스타일 시트가 아래와 같은 규칙을 가진다고 하였을 때
     <span lang=en>If the style sheet contains the rules</span>
   </p>

   <pre>EXAMPLE[radix=decimal] { /*... default property settings ...*/ }
EXAMPLE[radix=octal]   { /*... other settings...*/ }</pre>

   <p>
    첫번째 규칙은 <code>radix</code> 속성이 기본으로 설정되어있는 요소,
    즉 속성이 명시적으로 지정되어있지 않은 것에 매치하지 않을 가능성이 있습니다.
    모든 가능성에 대비하기 위해, 기본 값에 대한 속성 셀렉터는 제거하지 않으면 안됩니다.
    <span lang=en>
      the first rule might not match elements whose <code>radix</code> attribute is set by default, 
      i.e. not set explicitly. To catch all cases, the attribute selector for the default value must be dropped:</span>
   </p>

   <pre>EXAMPLE                { /*... default property settings ...*/ }
EXAMPLE[radix=octal]   { /*... other settings...*/ }</pre>

   <p>
    <code>EXAMPLE[radix=octal]</code>는 타입 셀렉터보다 상세하기 때문에,
     <code>radix</code> 속성값이 <code>"octal"</code>인 요소에서는
     2번째 규칙에 있는 스타일 선언이 1번째 스타일 선언을 덮어쓸 것입니다.
     디폴트 상태에서 적용하는 모든 속성 선언은,
     그 외의 상태에 대해 적용하는 스타일 룰에 덮어쓰여지는 점에 주의하시길 바랍니다.
     
    <span lang=en>Here, because the selector <code>EXAMPLE[radix=octal]</code> is more
    specific than the type selector alone, the style declarations in the
    second rule will override those in the first for elements that have a
    <code>radix</code> attribute value of <code>"octal"</code>. Care has to
    be taken that all property declarations that are to apply only to the
    default case are overridden in the non-default cases' style rules.</span></p>
  </div>

  <h3 id=class-html><span class=secno>6.4. </span>클래스 셀렉터</h3>

  <p lang=ko>
    HTML에서, 작성자는 <code>~=</code> 기호를 대신해서
    "페리오드" 표기법 (또한 "마침표"로 알려져있는, U+002E, <code>.</code>)을 사용할 수 있습니다.
    HTML을 가져올 때 <code>div.value</code>와 <code>div[class~=value)</code>는 같은 의미입니다.
    속성 값은 반드시 마침표 (<code>.</code>) 뒤에 표기해야 합니다.
 <p lang=en>Working with HTML, authors may use the "period" notation (also known as
   "full stop", U+002E, <code>.</code>) as an alternative to the
   <code>~=</code> notation when representing the <code>class</code>
   attribute. Thus, for HTML, <code>div.value</code> and
   <code>div[class~=value]</code> have the same meaning. The attribute value
   must immediately follow the full stop (<code>.</code>).
  <p lang=ko>네임스페이스에 있어서 속성이 "class" 속성을 결정하는, 네임스페이스 고유의 처리를 UA가 가지고 있는 경우,
    UA는 "마침표" 기호를 그 XML 문서에서도 사용할 수 있습니다.
    메임스페이스 고유의 처리를 예로 들자면 스펙 문장에서 정의되어 있습니다.
    (예: SVG 1.0 <a href="#SVG11" rel=biblioentry>[SVG11]<!--{{SVG11}}--></a>은
    <a href="http://www.w3.org/TR/2001/PR-SVG-20010719/styling.html#ClassAttribute">SVG
   <code>class</code> 속성</a>을 정의하며, UA가 어떻게 해석해야하는 지 설명하고 있습니다.
    MathML 1.01 <a href="#MATHML" rel=biblioentry>[MATHML]<!--{{MATHML}}--></a>도 마찬가지로 <a
   href="http://www.w3.org/1999/07/REC-MathML-19990707/chapter2.html#sec2.3.4">MathML
   <code>class</code> 속성</a>을 정의하고 있습니다)
    
  <p lang=en>UAs may apply selectors using the period (.) notation in XML documents
   if the UA has namespace-specific knowledge that allows it to determine
   which attribute is the "class" attribute for the respective namespace. One
   such example of namespace-specific knowledge is the prose in the
   specification for a particular namespace (e.g. SVG 1.0 <a href="#SVG11"
   rel=biblioentry>[SVG11]<!--{{SVG11}}--></a> describes the <a
   href="http://www.w3.org/TR/2001/PR-SVG-20010719/styling.html#ClassAttribute">SVG
   <code>class</code> attribute</a> and how a UA should interpret it, and
   similarly MathML 1.01 <a href="#MATHML"
   rel=biblioentry>[MATHML]<!--{{MATHML}}--></a> describes the <a
   href="http://www.w3.org/1999/07/REC-MathML-19990707/chapter2.html#sec2.3.4">MathML
   <code>class</code> attribute</a>.)

  <div class=example>
   <p>CSS 예제:</p>

   <p>
    <code>class~="pastoral"</code>인 모든 요소에 대해 스타일을 적용할 때 아래와 같이 작성합니다.
    <span lang=en>We can assign style information to all elements with
    <code>class~="pastoral"</code> as follows:</span></p>

   <pre>*.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

   <p>
     혹은 단순하게
     <span lang=en>or just</span> 
   </p>

   <pre>.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

   <p>
    <code>class~="pastoral"</code>인 H1 요소에 스타일을 적용할 때 아래와 같이 작성합니다.
    <span lang=en>The following assigns style only to H1 elements with
   <code>class~="pastoral"</code>:</span></p>

   <pre>H1.pastoral { color: green }  /* H1 elements with class~=pastoral */</pre>

   <p>
    이 규칙을 적용했을 때, 첫번째 <code>H1</code> 인스턴스는 녹색이 아니지만,
    두번째 <code>H1</code>은 녹색입니다.
    <span lang=en>Given these rules, the first <code>H1</code> instance below would not
    have green text, while the second would:</span></p>

   <pre>&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;</pre>

   <p>
    아래 규칙은 <code>P</code> 요소 중에서,
     <code>class</code> 속성값에 <code>pastoral</code>과 <code>maring</code>을 포함한 것을 매치합니다.
     이 때 <code>class</code> 속성값은 <a href="#whitespace">공백 문자</a>로 구분된 값의 리스트입니다.
    <span lang=en>The following rule matches any <code>P</code> element whose
    <code>class</code> attribute has been assigned a list of <a
    href="#whitespace">whitespace</a>-separated values that includes both
    <code>pastoral</code> and <code>marine</code>:</span></p>

   <pre>p.pastoral.marine { color: green }</pre>

   <p>
    위 규칙은  <code>class="pastoral blue aqua marine"</code>에 매치하지만,
    <code>class="pastoral blue"</code>에는 매치하지 않습니다.
    <span lang=en>This rule matches when <code>class="pastoral blue aqua marine"</code>
    but does not match for <code>class="pastoral blue"</code>.</span></p>
  </div>

  <p class=note lang=ko><strong>노트:</strong>
   CSS에 "class" 속성을 주는 게 큰 파워를 가지기 때문에,
   작성자는 (HTML의 <code>DIV</code>나 <code>SPAN</code>같은) 기본 표현을 거의 가지지 않은
   요소에 "class" 속성으로 스타일 정보를 주어 자신의 "문서 언어"를 설계할 수 있습니다.
   그러나 작성자는 문서 언어의 구조화 요소 의미와 의도를 이해하기 위해 이러한 사용을 피하길 바라며,
   문서 요소는 작성자가 정의한 클래스를 이해하지 못할 것입니다.
  <p class=note lang=en><strong>Note:</strong> Because CSS gives considerable power
   to the "class" attribute, authors could conceivably design their own
   "document language" based on elements with almost no associated
   presentation (such as <code>DIV</code> and <code>SPAN</code> in HTML) and
   assigning style information through the "class" attribute. Authors should
   avoid this practice since the structural elements of a document language
   often have recognized and accepted meanings and author-defined classes may
   not.
  <p class=note lang=ko><strong>노트:</strong> 요소가 복수의 class 속성을 가지고 있는 경우,
    각각의 값은 클래스를 검색하기 전에 공백 문자로 결합되어있어야 합니다.
    그러나 현 시점에서 CSS 워킹 그룹은 그런 사태를 상정한 상황을 인식하고 있지 않기 때문에,
    이 동작은 표준에 준하는 내용은 아닙니다.
  <p class=note lang=en><strong>Note:</strong> If an element has multiple class
   attributes, their values must be concatenated with spaces between the
   values before searching for the class. As of this time the working group
   is not aware of any manner in which this situation can be reached,
   however, so this behavior is explicitly non-normative in this
   specification.

  <h3 id=id-selectors><span class=secno>6.5. </span>ID 셀렉터</h3>
  <p lang=ko>문서 언어는 ID 타입으로 선언된 속성을 가질 수 있습니다.
    ID 타입 속성이 특별한 이유는 결합된 문서에서 속성이 주어지는 요소의 타입을 묻지 않고,
    같은 값을 가진 속성이 두개 존재할 수 없기 때문입니다.
    
    문서 언어가 무엇이던, ID 타입 속성은 요소를 유니크하게 만들 때 사용합니다.
    HTML 언어에 있어 ID 타입 속성은 모든 "id"라는 이름을 가집니다.
    XML 언어에서는 ID 타입 속성이 다른 이름을 가질 수 있지만, ID 타입 속성의 성질은 다르지 않습니다.
  <p lang=en>Document languages may contain attributes that are declared to be of
   type ID. What makes attributes of type ID special is that no two such
   attributes can have the same value in a conformant document, regardless of
   the type of the elements that carry them; whatever the document language,
   an ID typed attribute can be used to uniquely identify its element. In
   HTML all ID attributes are named "id"; XML applications may name ID
   attributes differently, but the same restriction applies.
  <p lang=ko>문서 언어의 ID 타입 속성은 문서 트리 내 하나의 요소 인스턴스 식별자로 주어집니다.
    ID 셀렉터는 "해쉬" (U+0023, <code>#</code>) 직후에 ID 타입 속성 값을 적어 표기합니다.
    값은 CSS<a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">식별자</a>여야 합니다. ID 셀렉터는 셀렉터 내 식별자에 매치하는 식별자를 가진 요소를 나타냅니다.
  <p lang=en>An ID-typed attribute of a document language allows authors to assign an
   identifier to one element instance in the document tree. An ID selector
   contains a &quot;number sign&quot; (U+0023, <code>#</code>) immediately
   followed by the ID value, which must be an CSS <a
   href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>.
   An ID selector represents an element instance that has an identifier that
   matches the identifier in the ID selector.
  <p lang=ko>
    셀렉터 스펙은 UA가 어떻게 요소 내의 ID 타입 속성을 아는지 정의하지 않습니다.
    UA가 문서의 DTD를 읽고, ID 타입 속성의 정보를 UA에 결합하여, 유저에게 물어보는 정도로 예상됩니다.
  <p lang=en>Selectors does not specify how a UA knows the ID-typed attribute of an
   element. The UA may, e.g., read a document's DTD, have the information
   hard-coded or ask the user.

  <div class=example>
   <p>예제:</p>

   <p>
    다음 ID 셀렉터는 ID 타입 속성 값으로 "chapter1"을 가지는 <code>h1</code> 요소를 나타냅니다.
    <span lang=en>The following ID selector represents an <code>h1</code> element whose
    ID-typed attribute has the value "chapter1":</span></p>

   <pre>h1#chapter1</pre>

   <p>
    다음 ID 셀렉터는 ID 타입 속성 값으로 "chapter1"을 가지는 모든 요소를 나타냅니다. 
    <span lang=en>The following ID selector represents any element whose ID-typed
    attribute has the value "chapter1":</span></p>

   <pre>#chapter1</pre>

   <p>
    다음 셀렉터는 ID 타입 속성 값으로 "z98y"를 가지는 모든 요소를 나타냅니다. 
    <span lang=en>The following selector represents any element whose ID-typed attribute
    has the value "z98y".</span></p>

   <pre>*#z98y</pre>
  </div>

  <p class=note lang=ko><strong>노트:</strong> XML 1.0 <a href="#XML10"
   rel=biblioentry>[XML10]<!--{{XML10}}--></a>에서, 어떤 속성이 요소의 ID인지
   나타내는 정보는 DTD 혹은 스키마 언어에 있다고 간주어집니다.
   UA는 XML을 해석할 때 항상 DTD를 읽어들이는 게 아니므로, 요소의 ID가 무엇인지 모를 가능성도 있습니다.
   (그러나 UA가 네임스페이스 고유 처리를 가지고, 그 네임스페이스에서 어떤 속성이 ID 속성인지 알릴 가능성도 있습니다)
   그 UA가 요소의 ID를 모른다면, 스타일시트의 작성자가 알고있는, 혹은 추측 가능한 경우,
   ID 셀렉터가 아닌 속성 셀렉터를 사용해야 합니다.
   즉 <code>#p371</code> 대신에 <code>[name=p371]</code>를 사용합니다.
    
  <p class=note lang=en><strong>Note:</strong> In XML 1.0 <a href="#XML10"
   rel=biblioentry>[XML10]<!--{{XML10}}--></a>, the information about which
   attribute contains an element's IDs is contained in a DTD or a schema.
   When parsing XML, UAs do not always read the DTD, and thus may not know
   what the ID of an element is (though a UA may have namespace-specific
   knowledge that allows it to determine which attribute is the ID attribute
   for that namespace). If a style sheet author knows or suspects that a UA
   may not know what the ID of an element is, he should use normal attribute
   selectors instead: <code>[name=p371]</code> instead of <code>#p371</code>.
  <p lang=ko>만약 요소가 여러개의 ID 속성을 가지고 있는 경우 모든 값을 그 요소의 ID로 취급하여, ID 셀렉터 처리대상으로 인식해야 합니다. 이는 xml:id, DOM3 Core, XML DTD, 네임스페이스 고유 처리가 엮일 때 발생할 가능성이 있습니다.
  <p lang=en>If an element has multiple ID attributes, all of them must be treated as
   IDs for that element for the purposes of the ID selector. Such a situation
   could be reached using mixtures of xml:id, DOM3 Core, XML DTDs, and
   namespace-specific knowledge.

  <h3 id=pseudo-classes><span class=secno>6.6. </span>의사 클래스</h3>
  
  <p lang=ko>
   의사 클래스는 문서 트리 범위에 포함하지 않는 정보나, 심플 셀렉터로는 표현 불가능한 것을
   선택 가능하도록 도입한 컨셉입니다.
  <p lang=en>The pseudo-class concept is introduced to permit selection based on
   information that lies outside of the document tree or that cannot be
   expressed using the other simple selectors.
  <p lang=ko>의사 클래스는 항상 &quot;콜론&quot; (<code>:</code>)으로 시작하며,
    그 이후에 의사 클래스 명을 입력해 표시하며, 선택적으로 괄호를 이용해 값을 가지는 것도 있습니다.
  <p lang=en>A pseudo-class always consists of a &quot;colon&quot; (<code>:</code>)
   followed by the name of the pseudo-class and optionally by a value between
   parentheses.
  <p lang=ko>
    의사 클래스는 셀렉터가 포함하는 모든 심플 셀렉터 시퀀스를 허용합니다. 의사 클래스는
    의사 클래스는 타입 셀렉터나 (생략 가능한)전역 셀렉터를 읽어들인 뒤 심플 셀렉터 시퀀스 내 모든 곳에 허용합니다.
    의사 클래스 이름은 대소문자를 구분하지 않습니다.
    몇몇 의사 클래스는 상호 배타적이며, 같은 요소에 동시에 사용하는 건 가능합니다.
    의사 클래스는 동적일 수 있으며, 유저와 문서간 인터렉션에 반응해서 의사 클래스가 잡히거나 사라질 수 있습니다.
  <p lang=en>Pseudo-classes are allowed in all sequences of simple selectors
   contained in a selector. Pseudo-classes are allowed anywhere in sequences
   of simple selectors, after the leading type selector or universal selector
   (possibly omitted). Pseudo-class names are case-insensitive. Some
   pseudo-classes are mutually exclusive, while others can be applied
   simultaneously to the same element. Pseudo-classes may be dynamic, in the
   sense that an element may acquire or lose a pseudo-class while a user
   interacts with the document.

  <h4 id=dynamic-pseudos><span class=secno>6.6.1. </span>동적 의사 클래스</h4>

  <p lang=ko>
    동적 의사 클래스는 요소명, 속성, 내용을 제외한 문서 트리에서 추론할 수 없는 성질에서
    요소를 분류하는 것입니다.
  <p lang=en>Dynamic pseudo-classes classify elements on characteristics other than
   their name, attributes, or content, in principle characteristics that
   cannot be deduced from the document tree.
  <p lang=ko>동적 의사 클래스는 문서 트리나 문서 소스에는 나타나지 않습니다.
  <p lang=en>Dynamic pseudo-classes do not appear in the document source or document
   tree.

  <h5 id=the-link-pseudo-classes-link-and-visited><span class=secno>6.6.1.1.
   </span><a name=link>링크 의사 클래스: :link와 :visited</a></h5>
  <p lang=ko>
    보통 유저 에이전트는 이미 방문한 링크와 그렇지 않은 링크를 구분해서 보여줍니다.
    셀렉터에서는 이 구분을 위한 <code>:link</code>와 <code>:visited</code> 의사 클래스를 제공합니다.
  <p lang=en>User agents commonly display unvisited links differently from previously
   visited ones. Selectors provides the pseudo-classes <code>:link</code> and
   <code>:visited</code> to distinguish them:

  <ul>
   <li>
     <code>:link</code> 의사 클래스는 아직 방문하지 않은 링크에 적용합니다.
     <div lang=en>The <code>:link</code> pseudo-class applies to links that have not yet
     been visited.</div>

   <li>
     <code>:visited</code> 의사 클래스는 유저가 이미 방문한 링크에 적용합니다.
     <div lang=en>The <code>:visited</code> pseudo-class applies once the link has been
     visited by the user.</div>
  </ul>
  <p lang=ko>일정 시간이 지나면, UA는 이미 방문한 링크를 
    (방문하지 않은 링크인) &lsquo;<code class=css>:link</code>&rsquo; 상태로 변환합니다.
  <p lang=en>After some amount of time, user agents may choose to return a visited
   link to the (unvisited) &lsquo;<code class=css>:link</code>&rsquo; state.

  <p lang=ko>이 두 상태는 상호 배타적입니다.
  <p lang=en>The two states are mutually exclusive.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 <code>external</code> 클래스를 가지며 이미 방문한 링크를 나타냅니다.
    <span lang=en>The following selector represents links carrying class
    <code>external</code> and already visited:</span></p>

   <pre>a.external:visited</pre>
  </div>
  <p class=note lang=ko><strong>노트:</strong> 
    스타일시트 작성자가 :link, :visited 의사 클래스를 악용하여,
    유저가 어떤 사이트에 접속했는지 유저의 허락 없이 확인할 수 있습니다.
  <p class=note lang=en><strong>Note:</strong> It is possible for style sheet authors
   to abuse the :link and :visited pseudo-classes to determine which sites a
   user has visited without the user's consent.
  <p lang=ko>따라서 UA는 모든 링크를 방문하지 않음으로 인식하거나,
    각각의 링크를 표시할 때 유저의 프라이버시를 배려한 방법을 구현하는 등의 조치를 취할 수 있습니다.
  <p lang=en>UAs may therefore treat all links as unvisited links, or implement other
   measures to preserve the user's privacy while rendering visited and
   unvisited links differently.

  <h5 id=the-user-action-pseudo-classes-hover-act><span class=secno>6.6.1.2.
   </span><a name=useraction-pseudos>유저 액션 의사 클래스 :hover, :active, :focus</a></h5>
  <p lang=ko>인터렉티브 유저 에이전트는 유저의 행동에 반응하여 렌더링을 변경합니다.
   셀렉터는 유저의 행동에 따라서 요소를 선택하는 3개의 의사 클래스를 제공합니다.
  <p lang=en>
    Interactive user agents sometimes change the rendering in response to
   user actions. Selectors provides three pseudo-classes for the selection of
   an element the user is acting on.

  <ul>
   <li>
    <code>:hover</code> 의사 클래스는 유저가 포인팅 디바이스에서 접속했을 때 보이는 요소에 적용합니다.
    요소가 보여질 때 적용하기 때문에, 요소가 보이지 않을 때는 적용하지 않습니다.
    예를 들어, 비주얼 유저 에이전트에서 이 의사 클래스는 커서 (마우스 포인터)가 요소에 의해 생성되는
    박스 위에 있을 때 적용할 수 있습니다.
    <a href="http://www.w3.org/TR/REC-CSS2/media.html#interactive-media-group">인터랙티브 미디어</a>를
    지원하지 않는 유저 에이전트가 이 의사 클래스를 반드시 지원할 필요는 없습니다.
    <a href="http://www.w3.org/TR/REC-CSS2/media.html#interactive-media-group">인터랙티브 미디어</a>를
    지원하는 유저 에이전트 중 일부가 이 의사 클래스를 지원하지 않을 가능성이 있습니다.
    (예를 들어 펜 디바이스는 호버 효과를 확인하지 못합니다)
    <div lang=en>The <code>:hover</code> pseudo-class applies while the user designates
    an element with a pointing device, but does not necessarily activate it.
    For example, a visual user agent could apply this pseudo-class when the
    cursor (mouse pointer) hovers over a box generated by the element. User
    agents not that do not support <a
    href="http://www.w3.org/TR/REC-CSS2/media.html#interactive-media-group">interactive
    media</a> do not have to support this pseudo-class. Some conforming user
    agents that support <a
    href="http://www.w3.org/TR/REC-CSS2/media.html#interactive-media-group">interactive
    media</a> may not be able to support this pseudo-class (e.g., a pen
    device that does not detect hovering).</div>
   
   <li>
    <code>:active</code> 의사 클래스는 유저가 활성화시킨 요소를 나타냅니다.
     예를 들어, 유저가 마우스 버튼을 누르고 뗄 때까지의 시간에 적용됩니다.
     마우스 버튼이 1개 이상 존재하는 시스템에서, <code>:active</code>는
     단일 버튼 혹은 주요 실행 버튼 (대부분의 경우 "왼쪽" 마우스 버튼), 혹은 aliases에만 적용합니다.
    <div lang=en>The <code>:active</code> pseudo-class applies while an element is
    being activated by the user. For example, between the times the user
    presses the mouse button and releases it. On systems with more than one
    mouse button, <code>:active</code> applies only to the primary or primary
    activation button (typically the "left" mouse button), and any aliases
    thereof.</div>

   <li>
    <code>:focus</code> 의사 클래스는 포커스가 활성화되어있는 요소를 나태닙니다.
    (키보드 및 마우스 이벤트, 혹은 다른 input form 등에 사용합니다)
    <div lang=en>The <code>:focus</code> pseudo-class applies while an element has the
    focus (accepts keyboard or mouse events, or other forms of input).</div>
  </ul>

  <p>
   문서 언어나 구현체의 한계에 따라,
   <code>:active</code>나 <code>:focus</code>가 주어졌으나,
   가져 올 수 있는 요소와 그렇지 않은 요소가 있을 수 있습니다.
  <div lang=en>There may be document language or implementation specific limits on
   which elements can become <code>:active</code> or acquire
    <code>:focus</code>.</div>
  <p lang=ko>
    이 의사 클래스는 상호 배타적이지 않습니다.
    요소는 동일한 시간에 여러개의 의사 클래스에 매치할 수 있습니다.
  <p lang=en>
   These pseudo-classes are not mutually exclusive. An element may match
   several pseudo-classes at the same time.
  <p lang=ko>셀렉터의 부모에 &lsquo;<code class=css>:active</code>&rsquo;나 &lsquo;<code
   class=css>:hover</code>&rsquo; 상태를 지원하는 지에 대해서 이 스펙에서는 정의하지 않습니다.
  <p lang=en>Selectors doesn't define if the parent of an element that is
   &lsquo;<code class=css>:active</code>&rsquo; or &lsquo;<code
   class=css>:hover</code>&rsquo; is also in that state.
  
  <p class=note lang=ko><strong>노트:</strong> 
    그 요소의 자식이 포인팅 디바이스에서 지정되었으며 요소 자신이 &lsquo;<code class=css>:hover</code>&rsquo; 상태가 되는 경우, 
    &lsquo;<code class=css>:hover</code>&rsquo;가 포인팅 디바이스 밑이 아닌 요소에 적용되는 것도 고려해야합니다.
    
  <p class=note lang=en><strong>Note:</strong> If the &lsquo;<code
   class=css>:hover</code>&rsquo; state applies to an element because its
   child is designated by a pointing device, then it's possible for
   &lsquo;<code class=css>:hover</code>&rsquo; to apply to an element that is
   not underneath the pointing device.

  <div class=example>
   <p>예제:</p>

   <pre>a:link    /* unvisited links */
a:visited /* visited links */
a:hover   /* user hovers */
a:active  /* active links */</pre>

   <p>동적 의사 클래스에 결합하는 예제입니다:
   <span lang=en>An example of combining dynamic pseudo-classes:</span></p>

   <pre>a:focus
a:focus:hover</pre>

   <p>
    마지막 셀렉터는 의사 클래스 :focus와 의사 클래스 :hover 상태인 <code>a</code> 요소와 매치합니다.
    <span lang=en>The last selector matches <code>a</code> elements that are in the
      pseudo-class :focus and in the pseudo-class :hover.</span></p>
  </div>
  <p class=note lang=ko><strong>노트:</strong> 요소는 &lsquo;<code
   class=css>:visited</code>&rsquo;와 &lsquo;<code
   class=css>:active</code>&rsquo; (혹은 &lsquo;<code
   class=css>:link</code>&rsquo; 와 &lsquo;<code
   class=css>:active</code>&rsquo;) 양쪽을 동시에 사용 가능합니다.
    
  <p class=note lang=en><strong>Note:</strong> An element can be both &lsquo;<code
   class=css>:visited</code>&rsquo; and &lsquo;<code
   class=css>:active</code>&rsquo; (or &lsquo;<code
   class=css>:link</code>&rsquo; and &lsquo;<code
   class=css>:active</code>&rsquo;).

  <h4 id=target-pseudo><span class=secno>6.6.2. </span>타겟 의사 클래스 :target</h4>
  <p lang=ko>
   &quot;해쉬&quot; (#) 기호와 뒤에 앵커 식별자를 가진 URI 같은 몇몇 URI는 리소스의 위치를 참조합니다.
   (부분 식별자라 부릅니다)
  <p lang=en>Some URIs refer to a location within a resource. This kind of URI ends
   with a &quot;number sign&quot; (#) followed by an anchor identifier
   (called the fragment identifier).
  <p lang=ko>부분 식별자가 붙은 URI는 문서 내 특정 요소에 링크하며, 이를 타겟 요소라고 부릅니다.
    아래는 HTML 문서 내에서 <code>section_2</code>라 이름붙여진 요소를 참조하는 URI입니다.
  <p lang=en>URIs with fragment identifiers link to a certain element within the
   document, known as the target element. For instance, here is a URI
   pointing to an anchor named <code>section_2</code> in an HTML document:

  <pre>http://example.com/html/top.html#section_2</pre>
  <p lang=ko>타겟 요소는 <code>:target</code> 의사 클래스를 이용해 나타낼 수 있습니다.
    만약 문서의 URI가 부분 식별자를 가지지 않는다면, 해당 문서에 타겟 요소는 존재하지 않습니다.
  <p lang=en>A target element can be represented by the <code>:target</code>
   pseudo-class. If the document's URI has no fragment identifier, then the
   document has no target element.

  <div class=example>
   <p>예제:</p>

   <pre>p.note:target</pre>

   <p>
    이 셀렉터는 참조 URI의 타겟 요소이며 <code>note</code>라는 클래스를 가진 <code>p</code>요소를 의미합니다.
    <span lang=en>This selector represents a <code>p</code> element of class
    <code>note</code> that is the target element of the referring URI.</span></p>
  </div>

  <div class=example>
   <p>CSS 예제:</p>

   <p>
    여기, <code>:target</code> 의사 클래스를 사용하여 타겟 요소의 색상을 붉게 하고 그 요소의 앞에 이미지를 둘 때 사용하는 예제입니다:
    <span lang=en>Here, the <code>:target</code> pseudo-class is used to make the target
    element red and place an image before it, if there is one:</span></p>

   <pre>*:target { color : red }
*:target::before { content : url(target.png) }</pre>
  </div>

  <h4 id=lang-pseudo><span class=secno>6.6.3. </span>언어 의사 클래스 :lang</h4>
  <p lang=ko>문서 언어가 요소가 어떤 인간 언어로 작성되어있는 지 결정하는 수단을 정의하는 경우,
    그 언어 정보로 요소를 선택하는 게 가능합니다.
    예를 들어 HTML에서 <a href="#HTML401" rel=biblioentry>[HTML401]<!--{{HTML401}}--></a>,
    <code>lang</code> 속성이나 <code>meta</code> 요소, 혹은 프로토콜 (HTTP 헤더 등) 등 몇가지 방법으로 문서의 언어정보를 취득할 수 있습니다.
    XML에서는 <code>xml:lang</code> 속성을 사용하며, 언어 정보를 판별하는 언어 고유의 구조가 있을 가능성이 있습니다.
    
  <p lang=en>If the document language specifies how the human language of an element
   is determined, it is possible to write selectors that represent an element
   based on its language. For example, in HTML <a href="#HTML401"
   rel=biblioentry>[HTML401]<!--{{HTML401}}--></a>, the language is
   determined by a combination of the <code>lang</code> attribute and
   possibly information from the <code>meta</code> elements or the protocol
   (such as HTTP headers). XML uses an attribute called
   <code>xml:lang</code>, and there may be other document language-specific
   methods for determining the language.
  <p lang=ko> 의사 클래스 <code>:lang(C)</code>은 C라는 언어를 가진 요소를 나타냅니다.
    요소가 셀렉터에 의해 표현되어지고 있는 지는,
    요소의 언어값(필요에 의해 BCP 47 문법을 통해 정규화 됨)이 식별자 C와 동일하거나
    식별자 C로 시작해서 바로 뒤에 "-"(U+002D)가 있는 지를 기본으로 합니다.
    요소의 언어값과 식별자 C간 매칭은 ASCII 범위 내에서 대소문자를 구분하지 않습니다.
    식별자 C는 유효한 언어 이름이여야 합니다.
  <p lang=en>The pseudo-class <code>:lang(C)</code> represents an element that is in
   language C. Whether an element is represented by a <code>:lang()</code>
   selector is based solely on the element's language value (normalized to
   BCP 47 syntax if necessary) being equal to the identifier C, or beginning
   with the identifier C immediately followed by "-" (U+002D). The matching
   of C against the element's language value is performed case-insensitively.
   The identifier C does not have to be a valid language name.
  <p lang=ko>C는 유효한 CSS <a
   href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">식별자</a>
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>여야 하며 공백이어선 안됩니다.
    (그 외의 경우 모두 유효하지 않습니다)
  <p>C must be a valid CSS <a
   href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifier</a>
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a> and must not
   be empty. (Otherwise, the selector is invalid.)
  <p class=note lang=ko><strong>노트:</strong> 
    문서나 프로토콜이 언어 정보를 나타낼 때,
    값은 BCP 47<a href="#BCP47" rel=biblioentry>[BCP47]<!--{{BCP47}}--></a>(혹은 개정판)의 언어 코드를 이용하는 걸 권장합니다.
    또, XML 기반 문서에서 "xml:lang" 속성을 사용할 경우, 그 값에 BCP 47 코드를 사용하게 됩니다. <a href="#XML10" rel=biblioentry>[XML10]<!--{{XML10}}--></a>
    <a href="http://www.w3.org/International/questions/qa-lang-2or3.html"> "FAQ: 두 글자 혹은 세 글자 언어 코드"</a>를 참고하시길 바랍니다.
  <p class=note lang=en><strong>Note:</strong> It is recommended that documents and
   protocols indicate language using codes from BCP 47 <a href="#BCP47"
   rel=biblioentry>[BCP47]<!--{{BCP47}}--></a> or its successor, and by means
   of "xml:lang" attributes in the case of XML-based documents <a
   href="#XML10" rel=biblioentry>[XML10]<!--{{XML10}}--></a>. See <a
   href="http://www.w3.org/International/questions/qa-lang-2or3.html"> "FAQ:
   Two-letter or three-letter language codes."</a>

  <div class=example>
   <p>예제:</p>

   <p>
    아래 두 셀렉터는 벨기에식 프랑스어나 독일어로 시작하는 HTML 문서를 나타냅니다. 
    그 다음 두 셀렉터는 벨기에식 프랑스어나 독일어라 명시된 임의의 요소의 자식 <code>q</code> 인용구를 나타냅니다.
    <span lang=en>The two following selectors represent an HTML document that is in
    Belgian French or German. The two next selectors represent <code>q</code>
    quotations in an arbitrary element in Belgian French or German.</span></p>

   <pre>html:lang(fr-be)
html:lang(de)
:lang(fr-be) &gt; q
:lang(de) &gt; q</pre>
  </div>

  <p>
    <code>:lang(C)</code>과 &lsquo;<code class=css>|=</code>&rsquo; 간 차이는,
    &lsquo;<code class=css>|=</code>&rsquo;가 요소에 주어진 속성만을 대상으로 하는데 반해,
    <code>:lang(C)</code>은 UA가 문서의 시맨틱을 위한 정보를 처리대상으로 하는 데 있습니다.
   <span lang=en>The difference between <code>:lang(C)</code> and the &lsquo;<code
   class=css>|=</code>&rsquo; operator is that the &lsquo;<code
   class=css>|=</code>&rsquo; operator only performs a comparison against a
   given attribute on the element, while the <code>:lang(C)</code>
   pseudo-class uses the UAs knowledge of the document's semantics to perform
   the comparison.</span>

  <div class=example>
   <p>
    아래 HTML 예제에서, BODY만 <code>[lang|=fr]</code>에 매치할 것입니다. (BODY가 lang 속성을 가지고 있기 때문에)
     그러나 BODY와 P는 둘 다 <code>:lang(fr)</code>에 매치할 것입니다. (왜냐하면 둘 다 프랑스어라서)
     P는 LANG 속성을 가지고 있지 않기 때문에 <code>[lang|=fr]</code>에 매치하지 않습니다.
    <span lang=en>In this HTML example, only the BODY matches <code>[lang|=fr]</code>
    (because it has a LANG attribute) but both the BODY and the P match
    <code>:lang(fr)</code> (because both are in French). The P does not match
    the <code>[lang|=fr]</code> because it does not have a LANG attribute.</span></p>

   <pre>&lt;body lang=fr>
  &lt;p>Je suis fran&ccedil;ais.&lt;/p>
&lt;/body></pre>
  </div>

  <h4 id=UIstates><span class=secno>6.6.4. </span>UI 요소 상태 의사 클래스</h4>

  <h5 id=enableddisabled><span class=secno>6.6.4.1. </span>:enabled 및 :disabled 의사 클래스</h5>
  <p lang=ko><code>:enabled</code> 의사 클래스는 사용 가능한 상태인 유저 인터페이스 요소를 나타냅니다.
    몇가지 요소는 사용 불가능 상태에 해당합니다.
  <p lang=en>The <code>:enabled</code> pseudo-class represents user interface
   elements that are in an enabled state; such elements have a corresponding
   disabled state.
  <p lang=ko>역으로 <code>:disabled</code> 의사 클래스는 사용 불가능한 상태인 유저 인터페이스 요소를 나타냅니다.
    몇가지 요소는 사용 가능 상태에 해당합니다.
  <p lang=en>Conversely, the <code>:disabled</code> pseudo-class represents user
   interface elements that are in a disabled state; such elements have a
   corresponding enabled state.
  <p lang=ko>어느게 사용 가능한 상태이며 어느게 사용 불가능한 상태인지 구성하는 건 언어에 의존합니다.
    일반적으로 문서에 있어서, 대부분의 요소는 <code>:enabled</code>도 <code>:disabled</code>도 아닌 상태입니다.
  <p lang=en>What constitutes an enabled state, a disabled state, and a user
   interface element is language-dependent. In a typical document most
   elements will be neither <code>:enabled</code> nor <code>:disabled</code>.
  <p class=note lang=ko><strong>노트:</strong> UI요소와 유저 인터렉션에 영향을 줄 수 있는 CSS 속성이,
    <code>:enabled</code>나 <code>:disabled</code> 매치에 영향을 주지 않습니다.
    예를 들어, <code>display</code>와 <code>visibility</code> 속성은 요소의 사용 가능/사용 불가능 상태에 어떤 영향도 주지 않습니다.
  <p class=note lang=en><strong>Note:</strong> CSS properties that might affect a
   user’s ability to interact with a given user interface element do not
   affect whether it matches <code>:enabled</code> or <code>:disabled</code>;
   e.g., the <code>display</code> and <code>visibility</code> properties have
   no effect on the enabled/disabled state of an element.

  <h5 id=checked><span class=secno>6.6.4.2. </span>:checked 의사 클래스</h5>
  <p lang="ko">
    라디오 버튼과 체크박스 요소는 유저가 토글하는 요소입니다.
    몇개의 메뉴 아이템은 유저가 선택할 때 "checked" 상태가 됩니다.
    이러한 "checked" 상태에 있는 요소에 <code>:checked</code> 의사 클래스를 적용합니다.
    <code>:checked</code> 의사 클래스는 동적인 성질을 가지며,
    문서의 의미적 속성의 존재에 따라 적용될 때도 있어 유저의 행동에 의해 변경되며, 모든 매체에 적용됩니다.
    예를 들어 <code>:checked</code> 의사 클래스는 <a
   href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.2.1">HTML4 17.2.1 섹션</a>의 내용대로 <code>selected</code>나
   <code>checked</code> 속성을 가진 요소에 먼저 적용되지만 이러한 것들은 당연히 "off"가 가능하며,
   그 결과가 적용된 <code>:checked</code> 의사 클래스는 적용되지 않습니다.
  </p>
  <p lang="en">Radio and checkbox elements can be toggled by the user. Some menu items
   are "checked" when the user selects them. When such elements are toggled
   "on" the <code>:checked</code> pseudo-class applies. While the
   <code>:checked</code> pseudo-class is dynamic in nature, and can altered
   by user action, since it can also be based on the presence of semantic
   attributes in the document, it applies to all media. For example, the
   <code>:checked</code> pseudo-class initially applies to such elements that
   have the HTML4 <code>selected</code> and <code>checked</code> attributes
   as described in <a
   href="http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.2.1">Section
   17.2.1 of HTML4</a>, but of course the user can toggle "off" such elements
   in which case the <code>:checked</code> pseudo-class would no longer
   apply.

  <h5 id=indeterminate><span class=secno>6.6.4.3. </span>:indeterminate 의사 클래스</h5>

  <div class=note>
   <p lang=ko><strong>노트:</strong> 유저에 의해 토글되는 라디오 버튼이나 체크박스는,
   때로 체크 되어있지도 체크되어있지도 않은 불확정 상태가 됩니다.
   이는 요소의 속성이나 DOM의 조작에 의해 발생합니다.
   <p lang=en><strong>Note:</strong> Radio and checkbox elements can be toggled by
    the user, but are sometimes in an indeterminate state, neither checked
    nor unchecked. This can be due to an element attribute, or DOM
    manipulation.</p>
   <p lang=ko>미래의 셀렉터 스펙이 그러한 요소에 적용할 <code>:indeterminate</code> 의사 클래스를 도입할 가능성이 있습니다.
   <p lang=en>A future version of this specification may introduce an
    <code>:indeterminate</code> pseudo-class that applies to such elements.
    <!--While the <code>:indeterminate</code> pseudo-class is dynamic in
nature, and is altered by user action, since it can also be based on
the presence of an element attribute, it applies to all media.</p>

<p>Components of a radio-group initialized with no pre-selected choice
are an example of :indeterminate state.--></p>
  </div>

  <h4 id=structural-pseudos><span class=secno>6.6.5. </span>구조 의사 클래스</h4>
  <p lang=ko>셀렉터 스펙은 문서 트리 안 정보 중 다른 심플 셀렉터나 콤비네이터로는 표현 불가능한
  셀렉트를 가능하도록 <dfn id=structural-pseudo-classes>구조 의사 클래스</dfn>를 정의합니다.
  <p lang=en>Selectors introduces the concept of <dfn>structural pseudo-classes</dfn> to permit
   selection based on extra information that lies in the document tree but
   cannot be represented by other simple selectors or combinators.
  <p lang=ko>단일 텍스트와 요소가 아닌 노드는, 트리 구조에서 요소의 위치를 계산할 때 계산되지 않습니다.
  요소의 위치를 계산 할 때, 인덱스는 1로 시작합니다.
  <p lang=en>Standalone text and other non-element nodes are not counted when
   calculating the position of an element in the list of children of its
   parent. When calculating the position of an element in the list of
   children of its parent, the index numbering starts at 1.

  <h5 id=root-pseudo><span class=secno>6.6.5.1. </span>:root 의사 클래스</h5>
  <p lang=ko><code>:root</code> 의사 클래스는 문서의 루트 요소를 나타냅니다.
  HTML 4에서는 항상 <code>HTML</code> 요소 입니다.
  <p lang=en>The <code>:root</code> pseudo-class represents an element that is the
   root of the document. In HTML 4, this is always the <code>HTML</code>
   element.
  <h5 id=nth-child-pseudo><span class=secno>6.6.5.2. </span>:nth-child() 의사 클래스</h5>
  <p lang=ko><code>:nth-child(<var>a</var><code>n</code>+<var>b</var>)</code> 의사 클래스는
  문서 트리에서 어떤 요소의 자식에서 그 <strong>앞에</strong> <var>a</var><code>n</code>+<var>b</var>-1개
  (<code>n</code>은 양의 정수 혹은 0)의 형제를 가지는 상태를 나타냅니다.
  의사 클래스는 요소의 자식을 <code>a</code>개씩 그룹으로 나누어 (마지막 그룹은 나머지를 모두 가집니다)
  각각의 그룹에서 <code>b</code>번째 요소를 선택합니다.
  예를 들어, 이 셀렉터는 table 내 행을 선택하는 일이나,
  4개의 문장을 하나의 그룹으로 하여, 그룹 내 문장에 각각 다른 색을 주는 것이 가능합니다.
  <code>a</code>와 <code>b</code>의 값은 정수(양수, 음수, 0)여야 합니다.
  요소의 첫번째 자식 인덱스는 1입니다.
  <p lang=en>The <code>:nth-child(<var>a</var><code>n</code>+<var>b</var>)</code>
   pseudo-class notation represents an element that has
   <var>a</var><code>n</code>+<var>b</var>-1 siblings <strong>before</strong>
   it in the document tree, for any positive integer or zero value of
   <code>n</code>, and has a parent element. For values of <var>a</var> and
   <var>b</var> greater than zero, this effectively divides the element's
   children into groups of <var>a</var> elements (the last group taking the
   remainder), and selecting the <var>b</var>th element of each group. For
   example, this allows the selectors to address every other row in a table,
   and could be used to alternate the color of paragraph text in a cycle of
   four. The <var>a</var> and <var>b</var> values must be integers (positive,
   negative, or zero). The index of the first child of an element is 1.
  <p lang=ko>여기에 더해 <code>:nth-child()</code>는 &lsquo;<code class=css><code>odd</code></code>&rsquo; 및
  &lsquo;<code class=css><code>even</code></code>&rsquo;를 인수로 사용할 수 있습니다.
	&lsquo;<code class=css><code>odd</code></code>&rsquo;는 <code>2n+1</code>과 동일하며,
  &lsquo;<code class=css><code>even</code></code>&rsquo;은 <code>2n</code>과 동일합니다.
  <p lang=en>In addition to this, <code>:nth-child()</code> can take &lsquo;<code
   class=css><code>odd</code></code>&rsquo; and &lsquo;<code
   class=css><code>even</code></code>&rsquo; as arguments instead.
   &lsquo;<code class=css><code>odd</code></code>&rsquo; has the same
   signification as <code>2n+1</code>, and &lsquo;<code
   class=css><code>even</code></code>&rsquo; has the same signification as
   <code>2n</code>.
  <p lang=ko><code>:nth-child()</code> 인수는 아래 문법을 준수해야 합니다.
   <code>INTEGER</code>는 토큰 <code>[0-9]+</code>에 매치하며, 그 외의 토큰은 섹션 10.2 <a href="#lex">Lexical scanner</a>에서 정의합니다.
  <p lang=en>The argument to <code>:nth-child()</code> must match the grammar below,
   where <code>INTEGER</code> matches the token <code>[0-9]+</code> and the
   rest of the tokenization is given by the <a href="#lex">Lexical
   scanner</a> in section 10.2:

  <pre>nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;</pre>

  <div class=example>
   <p>예제:</p>

   <pre>tr:nth-child(2n+1) /* represents every odd row of an HTML table */
tr:nth-child(odd)  /* same */
tr:nth-child(2n+0) /* represents every even row of an HTML table */
tr:nth-child(even) /* same */

/* Alternate paragraph colours in CSS */
p:nth-child(4n+1) { color: navy; }
p:nth-child(4n+2) { color: green; }
p:nth-child(4n+3) { color: maroon; }
p:nth-child(4n+4) { color: purple; }</pre>
  </div>
  <p lang=ko><var>b</var> 값 앞에 음수기호가 있는 경우, 식 안의 "+"는 제거해야만 합니다.
  (<var>b</var> 음수 값을 표현할 "-"로 인해 결과적으로 바뀌기 때문입니다)
  <p lang=en>When the value <var>b</var> is preceded by a negative sign, the "+"
   character in the expression must be removed (it is effectively replaced by
   the "-" character indicating the negative value of <var>b</var>).

  <div class=example>
   <p>예제:</p>

   <pre>:nth-child(10n-1)  /* represents the 9th, 19th, 29th, etc, element */
:nth-child(10n+9)  /* Same */
:nth-child(10n+-1) /* Syntactically invalid, and would be ignored */</pre>
  </div>
  <p lang=ko><var>a</var>=0일 때, <var>a</var><code>n</code>를 포함할 필요는 없습니다. (다만, <var>b</var>가 이미 생략되어 있는 경우는 제외합니다)
  <var>a</var><code>n</code>가 인수에 포함되어있지 않고, <var>b</var>가 음수가 아닌 경우, <var>b</var> 앞에 있는 "+" 기호는 생략 가능합니다.
  이 경우 문법을 <code>:nth-child(<var>b</var>)</code>같이 간단하게 작성할 수 있습니다.
  <p lang=en>When <var>a</var>=0, the <var>a</var><code>n</code> part need not be
   included (unless the <var>b</var> part is already omitted). When
   <var>a</var><code>n</code> is not included and <var>b</var> is
   non-negative, the <code>+</code> sign before <var>b</var> (when allowed)
   may also be omitted. In this case the syntax simplifies to
   <code>:nth-child(<var>b</var>)</code>.

  <div class=example>
   <p>예제:</p>

   <pre>foo:nth-child(0n+5)   /* represents an element foo that is the 5th child
                         of its parent element */
foo:nth-child(5)      /* same */</pre>
  </div>

  <p lang=ko><var>a</var>=1이거나 <var>a</var>=-1일 때, 숫자는 선언에서 생략 가능합니다.
  <p lang=en>When <var>a</var>=1, or <var>a</var>=-1, the number may be omitted from
   the rule.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 위 규칙에 따라 동일합니다.
    <span lang=en>The following selectors are therefore equivalent:</span></p>

   <pre>bar:nth-child(1n+0)   /* represents all bar elements, specificity (0,1,1) */
bar:nth-child(n+0)    /* same */
bar:nth-child(n)      /* same */
bar                   /* same but lower specificity (0,0,1) */</pre>
  </div>
  <p lang=ko><var>b</var>=0일 때, <var>a</var>번째 요소 모두가 선택됩니다.
    이 경우 <var>a</var>가 이미 생략되어 있는 경우는 제외하여 +<var>b</var> (혹은 -<var>b</var>)을 생략하는 게 가능합니다.
  <p lang=en>If <var>b</var>=0, then every <var>a</var>th element is picked. In such
   a case, the +<var>b</var> (or -<var>b</var>) part may be omitted unless
   the <var>a</var> part is already omitted.

  <div class=example>
   <p>예제:</p>

   <pre>tr:nth-child(2n+0) /* represents every even row of an HTML table */
tr:nth-child(2n) /* same */</pre>
  </div>
  <p lang=ko>공백 문자는 "(" 뒤, ")" 앞, <var>a</var><code>n</code>와 <var>b</var> 부분을 나누는 "+" 혹은 "-" 전후에 입력할 수 있습니다.
  <p lang=en>Whitespace is permitted after the "(", before the ")", and on either
   side of the "+" or "-" that separates the <var>a</var><code>n</code> and
   <var>b</var> parts when both are present.

  <div class=example>
   <p>공백 문자를 사용한 유효한 예제입니다.</p>

   <pre>
:nth-child( 3n + 1 )
:nth-child( +3n - 2 )
:nth-child( -n+ 6)
:nth-child( +6 )
</pre>

   <p>공백 문자를 사용한 유효하지 않은 예제입니다.</p>

   <pre>
:nth-child(3 n)
:nth-child(+ 2n)
:nth-child(+ 2)
</pre>
  </div>
  <p lang=ko>
    만약 <var>a</var>와 <var>b</var>모두 0과 동일하다면,
    의사 클래스는 문서 트리 내 요소를 표현하지 않습니다.
  <p lang=en>
   If both <var>a</var> and <var>b</var> are equal to zero, the
   pseudo-class represents no element in the document tree.
  <p lang=ko><var>a</var> 값은 음수는 가능하나, 
  <var>a</var><code>n</code>+<var>b</var>가 양수 값을 가지는 경우에만 문서 트리의 요소를 나타내는 게 가능합니다.
  <p lang=en>The value <var>a</var> can be negative, but only the positive values of
   <var>a</var><code>n</code>+<var>b</var>, for <code>n</code>&ge;0, may
   represent an element in the document tree.

  <div class=example>
   <p>예제:</p>

   <pre>html|tr:nth-child(-n+6)  /* represents the 6 first rows of XHTML tables */</pre>
  </div>

  <h5 id=nth-last-child-pseudo><span class=secno>6.6.5.3.</span>:nth-last-child() 의사 클래스</h5>
  <p lang=ko><code>:nth-last-child(<var>a</var>n+<var>b</var>)</code> 의사 클래스는 문서 트리 내 어떤 요소의 자식에서,
  그 <strong>마지막에서</strong> <var>a</var><code>n</code>+<var>b</var>-1 개(<code>n</code>은 양의 정수 혹은 0) 형제를 가진 상태를 나타냅니다.
  인수에 대해서는 <a href="#nth-child-pseudo"><code>:nth-child</code></a>를 참조하시길 바랍니다.
  <code>:nth-child</code>와 동일하게 &lsquo;<code class=css><code>even</code></code>&rsquo;과 &lsquo;<code class=css><code>odd</code></code>&rsquo;을 가질 수 있습니다.
  <p lang=en>The <code>:nth-last-child(<var>a</var>n+<var>b</var>)</code>
   pseudo-class notation represents an element that has
   <var>a</var><code>n</code>+<var>b</var>-1 siblings <strong>after</strong>
   it in the document tree, for any positive integer or zero value of
   <code>n</code>, and has a parent element. See <a
   href="#nth-child-pseudo"><code>:nth-child()</code></a> pseudo-class for
   the syntax of its argument. It also accepts the &lsquo;<code
   class=css><code>even</code></code>&rsquo; and &lsquo;<code
   class=css><code>odd</code></code>&rsquo; values as arguments.

  <div class=example>
   <p>예제:</p>

   <pre>tr:nth-last-child(-n+2)    /* represents the two last rows of an HTML table */

foo:nth-last-child(odd)    /* represents all odd foo elements in their parent element,
                              counting from the last one */</pre>
  </div>

  <h5 id=nth-of-type-pseudo><span class=secno>6.6.5.4. </span>:nth-of-type() 의사 클래스</h5>
  <p lang=ko><code>:nth-of-type(<var>a</var>n+<var>b</var>)</code> 의사 클래스는 문서 트리 내 어떤 요소의 자식에서,
  그 요소와 같은 요소명을 가진 요소가 그 <strong>전에</strong> <var>a</var><code>n</code>+<var>b</var>-1 개(<code>n</code>은 양의 정수 혹은 0) 있는 상태를 나타냅니다.
  인수에 대해서는 <a href="#nth-child-pseudo"><code>:nth-child</code></a>를 참조하시길 바랍니다.
  <code>:nth-child</code>와 동일하게 &lsquo;<code class=css><code>even</code></code>&rsquo;과 &lsquo;<code class=css><code>odd</code></code>&rsquo;을 가질 수 있습니다.
  <p lang=en>The <code>:nth-of-type(<var>a</var>n+<var>b</var>)</code> pseudo-class
   notation represents an element that has
   <var>a</var><code>n</code>+<var>b</var>-1 siblings with the same expanded
   element name <strong>before</strong> it in the document tree, for any zero
   or positive integer value of <code>n</code>, and has a parent element. See
   <a href="#nth-child-pseudo"><code>:nth-child()</code></a> pseudo-class for
   the syntax of its argument. It also accepts the &lsquo;<code
   class=css><code>even</code></code>&rsquo; and &lsquo;<code
   class=css><code>odd</code></code>&rsquo; values.

  <div class=example>
   <p>CSS 예제:</p>

   <p>
     아래 규칙으로 작성자가 이미지를 교차로 float 시킬 수 있습니다.
     <span lang=en>This allows an author to alternate the position of floated images:</span></p>

   <pre>img:nth-of-type(2n+1) { float: right; }
img:nth-of-type(2n) { float: left; }</pre>
  </div>

  <h5 id=nth-last-of-type-pseudo><span class=secno>6.6.5.5.</span>:nth-last-of-type() 의사 클래스</h5>
  <p lang=ko><code>:nth-last-of-type(<var>a</var>n+<var>b</var>)</code> 의사 클래스는 문서 트리 내 어떤 요소의 자식에서
  그 요소와 같은 요소명을 가진 요소가 그 <strong>후에</strong> <var>a</var><code>n</code>+<var>b</var>-1개 (<code>n</code>은 양의 정수 혹은 0) 있는 상태를 나타냅니다.
  인수에 대해서는 <a href="#nth-child-pseudo"><code>:nth-child</code></a>를 참조하시길 바랍니다.
  <code>:nth-child</code>와 동일하게 &lsquo;<code class=css><code>even</code></code>&rsquo;과 &lsquo;<code class=css><code>odd</code></code>&rsquo;을 가질 수 있습니다.
  <p lang=en>The <code>:nth-last-of-type(<var>a</var>n+<var>b</var>)</code>
   pseudo-class notation represents an element that has
   <var>a</var><code>n</code>+<var>b</var>-1 siblings with the same expanded
   element name <strong>after</strong> it in the document tree, for any zero
   or positive integer value of <code>n</code>, and has a parent element. See
   <a href="#nth-child-pseudo"><code>:nth-child()</code></a> pseudo-class for
   the syntax of its argument. It also accepts the &lsquo;<code
   class=css><code>even</code></code>&rsquo; and &lsquo;<code
   class=css><code>odd</code></code>&rsquo; values.

  <div class=example>
   <p>예제:</p>

   <p>
    XHTML <code>body</code> 요소의 자식인 모든 <code>h2</code>요소 중,
    첫번째와 마지막을 제외한 모든 요소를 나타내고 싶을 때 아래와 같은 셀렉터를 사용합니다.
    <span lang=en>To represent all <code>h2</code> children of an XHTML <code>body</code>
    except the first and last, one could use the following selector:</span></p>

   <pre>body &gt; h2:nth-of-type(n+2):nth-last-of-type(n+2)</pre>

   <p>
    이 경우, 작성자는 <code>:not()</code>을 사용할 수 있지만, 길이는 크게 다르지 않습니다.
    <span lang=en>In this case, one could also use <code>:not()</code>, although the
    selector ends up being just as long:</span></p>

   <pre>body &gt; h2:not(:first-of-type):not(:last-of-type)</pre>
  </div>

  <h5 id=first-child-pseudo><span class=secno>6.6.5.6. </span>:first-child 의사 클래스</h5>
  <p lang=ko><code>:nth-child(1)</code>과 동일합니다. <code>:first-child</code> 의사 클래스는
    특정 요소의 첫번째 자식 요소를 나타냅니다.
  <p lang=en>Same as <code>:nth-child(1)</code>. The <code>:first-child</code>
   pseudo-class represents an element that is the first child of some other
   element.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 <code>div</code> 요소의 첫번째 자식인 <code>p</code>요소를 나타냅니다.
    <span lang=en>The following selector represents a <code>p</code> element that is the
    first child of a <code>div</code> element:</span></p>

   <pre>div &gt; p:first-child</pre>

   <p>
    이 셀렉터는 아래 코드에서 <code>div</code> 안의 <code>p</code>만 나타낼 수 있습니다.
    <span lang=en>This selector can represent the <code>p</code> inside the
    <code>div</code> of the following fragment:</span></p>

   <pre>&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
   &lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>
   <p>
     하지만 아래 코드에서 두번째 <code>p</code>요소는 나타내지 않습니다.
     <span lang=en>but cannot represent the second <code>p</code> in the following fragment:</span>
   <pre>&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
   &lt;h2&gt; Note &lt;/h2&gt;
   &lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>

   <p>아래 두 예제는 보통 동등합니다.
      <span lang=en>The following two selectors are usually equivalent:</span></p>

   <pre>* &gt; a:first-child /* a is first child of any element */
a:first-child /* Same (assuming a is not the root element) */</pre>
  </div>

  <h5 id=last-child-pseudo><span class=secno>6.6.5.7. </span>:last-child 의사 클래스</h5>

  <p lang=ko><code>:nth-last-child(1)</code>과 동일합니다. <code>:last-child</code> 의사 클래스는
    특정 요소의 마지막 자식 요소를 나타냅니다.
  <p lang=en>Same as <code>:nth-last-child(1)</code>. The <code>:last-child</code>
   pseudo-class represents an element that is the last child of some other
   element.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 순서 있는 목록 <code>ol</code> 내 마지막 자식 요소인 리스트 아이템 <code>li</code>를 나타냅니다.
    <span lang=en>The following selector represents a list item <code>li</code> that is
    the last child of an ordered list <code>ol</code>.</span>

   <pre>ol &gt; li:last-child</pre>
  </div>

  <h5 id=first-of-type-pseudo><span class=secno>6.6.5.8.
   </span>:first-of-type 의사 클래스</h5>

  <p lang=ko>
   <code>:nth-of-type(1)</code>과 동일합니다. <code>:first-of-type</code> 의사 클래스는
   부모 요소의 자식 목록에서 해당 타입을 갖는 첫번째 형제 요소입니다.
  <p lang=en>Same as <code>:nth-of-type(1)</code>. The <code>:first-of-type</code>
   pseudo-class represents an element that is the first sibling of its type
   in the list of children of its parent element.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 정의 목록 <code>dl</code>내 정의 제목 <code>dt</code>를 나타내며,
    이 <code>dt</code>는 그 부모 요소의 자식 목록의 타입 중 첫번째 요소여야 합니다.
    <span lang=en>The following selector represents a definition title <code>dt</code>
    inside a definition list <code>dl</code>, this <code>dt</code> being the
    first of its type in the list of children of its parent element.</span></p>

   <pre>dl dt:first-of-type</pre>

   <p>
    아래 예제에서 첫번째와 두번째 <code>dt</code> 요소는 유효하지만,
    세번째 <code>dt</code>요소는 그렇지 않습니다.
    <span lang=en>It is a valid description for the first two <code>dt</code> elements in
    the following example but not for the third one:</span></p>

   <pre>&lt;dl&gt;
 &lt;dt&gt;gigogne&lt;/dt&gt;
 &lt;dd&gt;
  &lt;dl&gt;
   &lt;dt&gt;fus&eacute;e&lt;/dt&gt;
   &lt;dd&gt;multistage rocket&lt;/dd&gt;
   &lt;dt&gt;table&lt;/dt&gt;
   &lt;dd&gt;nest of tables&lt;/dd&gt;
  &lt;/dl&gt;
 &lt;/dd&gt;
&lt;/dl&gt;</pre>
  </div>

  <h5 id=last-of-type-pseudo><span class=secno>6.6.5.9. </span>:last-of-type 의사 클래스</h5>
  <p lang=ko>
   <code>:nth-last-of-type(1)</code>과 동일합니다. <code>:last-of-type</code> 의사 클래스는
   부모 요소의 자식 목록에서 해당 타입을 갖는 마지막 형제 요소입니다.
  <p lang=en>Same as <code>:nth-last-of-type(1)</code>. The
   <code>:last-of-type</code> pseudo-class represents an element that is the
   last sibling of its type in the list of children of its parent element.

  <div class=example>
   <p>예제:</p>

   <p>
    다음 셀렉터는 테이블 행 <code>tr</code>의 마지막 데이터 셀 <code>td</code>를 나타냅니다.
    <span lang=en>The following selector represents the last data cell <code>td</code> of
    a table row <code>tr</code>.</span></p>

   <pre>tr &gt; td:last-of-type</pre>
  </div>

  <h5 id=only-child-pseudo><span class=secno>6.6.5.10. </span>:only-child 의사 클래스</h5>
  <p lang=ko>
    부모 요소를 가지며, 그 부모 요소에서 다른 자식 요소가 없는 요소를 나타냅니다.
    <code>:first-child:last-child</code>와 동일하며 <code>:nth-child(1):nth-last-child(1)</code>과도 동일하지만,
    이에 비교하면 덜 특별합니다.
  <p lang=en>Represents an element that has a parent element and whose parent element
   has no other element children. Same as
   <code>:first-child:last-child</code> or
   <code>:nth-child(1):nth-last-child(1)</code>, but with a lower
   specificity.

  <h5 id=only-of-type-pseudo><span class=secno>6.6.5.11. </span>:only-of-type 의사</h5>
  <p lang=en>
    부모 요소를 가지며, 그 부모 요소에서 같은 요소명을 가진 다른 자식 요소가 없는 요소를 나타냅니다.
    <code>:first-of-type:last-of-type</code>과 동일하며 <code>:nth-of-type(1):nth-last-of-type(1)</code>과도 동일하지만,
    이에 비교하면 덜 특별합니다.

  <p lang=en>Represents an element that has a parent element and whose parent element
   has no other element children with the same expanded element name. Same as
   <code>:first-of-type:last-of-type</code> or
   <code>:nth-of-type(1):nth-last-of-type(1)</code>, but with a lower
   specificity.

  <h5 id=empty-pseudo><span class=secno>6.6.5.12. </span>:empty 의사 클래스</h5>
  <p lang=ko><code>:empty</code> 의사 클래스는 자식을 가지지 않은 요소를 나타냅니다.
    문서 트리 관점에서 생각하면, 요소 노드와 콘텐츠 노드 (DOM <a href="#DOM-LEVEL-3-CORE"
   rel=biblioentry>[DOM-LEVEL-3-CORE]<!--{{DOM-LEVEL-3-CORE}}--></a> 텍스트 노트,
   CDATA 노드, 엔티티 참조 같은)가 0이 아닌 길이의 정보를 가진 경우,
   이는 요소가 비어있는 지 확인하는데 영향을 주는 것으로써 처리해야만 합니다.
   주석, 처리 명령, 그 외 노드는 요소가 공백인지 확인하는데 영향을 주지 않습니다.
  <p lang=en>The <code>:empty</code> pseudo-class represents an element that has no
   children at all. In terms of the document tree, only element nodes and
   content nodes (such as DOM <a href="#DOM-LEVEL-3-CORE"
   rel=biblioentry>[DOM-LEVEL-3-CORE]<!--{{DOM-LEVEL-3-CORE}}--></a> text
   nodes, CDATA nodes, and entity references) whose data has a non-zero
   length must be considered as affecting emptiness; comments, processing
   instructions, and other nodes must not affect whether an element is
   considered empty or not.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 코드에서 <code>p:empty</code>는 유효합니다.
    <span lang=en><code>p:empty</code> is a valid representation of the following
    fragment:</span></p>

   <pre>&lt;p&gt;&lt;/p&gt;</pre>

   <p>
    아래 코드에서 <code>foo:empry</code>는 유효하지 않습니다.
    <span lang=en><code>foo:empty</code> is not a valid representation for the following
    fragments:</span></p>

   <pre>&lt;foo&gt;bar&lt;/foo&gt;</pre>

   <pre>&lt;foo&gt;&lt;bar&gt;bla&lt;/bar&gt;&lt;/foo&gt;</pre>

   <pre>&lt;foo&gt;this is not &lt;bar&gt;:empty&lt;/bar&gt;&lt;/foo&gt;</pre>
  </div>

  <h4 id=content-selectors><span class=secno>6.6.6. </span>공백</h4>
  <!-- It's the Return of Appendix H!!! Run away! -->
  <p lang=ko>이 섹션은 의도적으로 비어있습니다. 
    (이 섹션에는 원래 <code>:contains()</code> 의사 클래스가 정의되어 있었습니다)
  <p lang=en>This section intentionally left blank. (This section previously defined
   a <code>:contains()</code> pseudo-class.)</p>
  <!-- (used to be :contains()) -->

  <h4 id=negation><span class=secno>6.6.7. </span>부정 의사 클래스</h4>

  <p lang=ko>부정 의사 클래스, <code>:not(<var>X</var>)</code>은 함수 표기식이며,
  (부정 의사 클래스 본인을 제외한) <a href="#simple-selectors-dfn">심플 셀렉터</a>를 인수로 가집니다.
  부정 의사 클래스는 인수 내 요소에서 표현하지 않는 요소를 나타냅니다.
  
  <p lang=en>The negation pseudo-class, <code>:not(<var>X</var>)</code>, is a
   functional notation taking a <a href="#simple-selectors-dfn">simple
   selector</a> (excluding the negation pseudo-class itself) as an argument.
   It represents an element that is not represented by its argument.

  <p lang=ko>부정 의사 클래스는 포함할 수 없습니다. <code>:not(:not(...))</code>은 유효하지 않습니다.
    또 의사 요소는 심플 셀렉터가 아니기 때문에, <code>:not()</code>에 넣을 수 있는 유효한 인수가 아닙니다.
  <p lang=en>Negations may not be nested; <code>:not(:not(...))</code> is invalid.
   Note also that since pseudo-elements are not simple selectors, they are
   not a valid argument to <code>:not()</code>.

  <div class=example>
   <p>예제:</p>

   <p>
    아래 셀렉터는 HTML 문서 내 <code>button</code> 중, 사용 불가능하지 않은(즉 사용 가능한) 것 모두에 매치합니다.
    <span lang=en>The following selector matches all <code>button</code> elements in an
    HTML document that are not disabled.</span></p>

   <pre>button:not([DISABLED])</pre>

   <p>
     아래 셀렉터는 <code>FOO</code> 요소를 제외한 모든 요소를 나타냅니다.
     <span lang=en>The following selector represents all but <code>FOO</code> elements.</span></p>

   <pre>*:not(FOO)</pre>

   <p>
    아래 셀렉터는, 링크가 아닌 모든 HTML 요소를 나타냅니다.
    <span lang=en>The following group of selectors represents all HTML elements except links.</span></p>

   <pre>html|*:not(:link):not(:visited)</pre>
  </div>
  <p lang=ko>기본 네임스페이스 선언은, 부정 의사 클래스의 인수에 영향을 주지 않습니다.
    그러나, 인수가 전역 셀렉터 혹은 타입 셀렉터인 경우를 제외합니다.
  <p lang=en>Default namespace declarations do not affect the argument of the
   negation pseudo-class unless the argument is a universal selector or a
   type selector.

  <div class=example>
   <p>예제:</p>

   <p>
    기본 네임스페이스가 "http://example.com"이라고 했을 때,
    아래 셀렉터는 그 네임스페이스에 속하지 않은 모든 요소를 나타냅니다. 
    <span lang=en>Assuming that the default namespace is bound to "http://example.com/",
    the following selector represents all elements that are not in that
    namespace:</span></p>

   <pre>*|*:not(*)</pre>

   <p>
    아래 셀렉터는 네임스페이스를 묻지 않고, 호버 상태가 아닌 요소 모두에 매치합니다.
    이는 기본 네임스페이스에 속하며,  호버 상태가 아닌 요소에 한정하지 않습니다.
    여기에 더해, 기본 네임스페이스에 속하지 않는 요소가 호버 상태인 경우, 그 요소는 매치하지 않습니다.
    <span lang=en>The following selector matches any element that is not being hovered,
    regardless of its namespace. In particular, it is not limited to only
    matching elements in the default namespace that are not being hovered,
    and elements not in the default namespace don't match the rule when they
    <em>are</em> being hovered.</span></p>

   <pre>*|*:not(:hover)</pre>
  </div>
  
  <p class=note><strong>노트</strong>: not() 의사 클래스를 사용해서 의미 없는 셀렉터를 작성할 수 있습니다.
  예를 들어, <code>:not(*|*)</code> 등의 요소도 나타내지 않습니다.
  그 외에도, <code>foo:not(bar)</code>같은 셀렉터도 작성할 수 있습니다.
  이는  <code>foo</code>와 동일하지만, <code>foo</code>보다 더 높은 상세도를 가집니다.
  <p class=note lang=en><strong>Note</strong>: the :not() pseudo allows useless
   selectors to be written. For instance <code>:not(*|*)</code>, which
   represents no element at all, or <code>foo:not(bar)</code>, which is
   equivalent to <code>foo</code> but with a higher specificity.

  <h2 id=pseudo-elements><span class=secno>7. </span>의사 요소</h2>
  <p lang=ko>의사 요소는 문서 언어에 의해 정의된 문서 트리에 추상적인 요소를 생성합니다.
    예를 들어, 문서 언어는 요소 내용의 첫번째 문자나 첫번째 행에 접근하는 수단을 제공하지 않습니다.
    의사 요소에 의해 본래 접근 불가능한 정보를 다루는 게 가능합니다.
    의사 요소는 원래 문서에 존재하지 않는 내용을 참조하는 방법도 제공합니다.
    (예: <code>::before</code>, <code>::after</code> 의사 요소는 생성된 콘텐츠에 접근할 수 있게 합니다)
  <p lang=en>Pseudo-elements create abstractions about the document tree beyond those
   specified by the document language. For instance, document languages do
   not offer mechanisms to access the first letter or first line of an
   element's content. Pseudo-elements allow authors to refer to this
   otherwise inaccessible information. Pseudo-elements may also provide
   authors a way to refer to content that does not exist in the source
   document (e.g., the <code>::before</code> and <code>::after</code>
   pseudo-elements give access to generated content).
  <p lang=ko>의사 요소는 의사 요소명 앞에 두개의 콜론 (<code>::</code>)을 작성해 생성합니다.
  <p lang=en>A pseudo-element is made of two colons (<code>::</code>) followed by the
   name of the pseudo-element.
  <p lang=ko><code>::</code> 표기법은 의사 클래스와 의사 요소를 구별하기 위해, 셀렉터 레벨 3에서 도입했습니다.
  현재 스타일시트와 호환하기 위해, UA는 CSS1, CSS2에서 도입된 콜론 1개 표기법으로 표현하는 의사 요소(<code>:first-line</code>,
  <code>:first-letter</code>, <code>:before</code>, <code>:after</code>)도 지원해야만 합니다.
   이 호환방안은 레벨 3에서 도입된 새로운 클래스에는 적용되지 않습니다.
  <p lang=en>This <code>::</code> notation is introduced by the current document in
   order to establish a discrimination between pseudo-classes and
   pseudo-elements. For compatibility with existing style sheets, user agents
   must also accept the previous one-colon notation for pseudo-elements
   introduced in CSS levels 1 and 2 (namely, <code>:first-line</code>,
   <code>:first-letter</code>, <code>:before</code> and <code>:after</code>).
   This compatibility is not allowed for the new pseudo-elements introduced
   in this specification.
  <p lang=ko>의사 요소는 셀렉터당 1개만 사용 가능합니다.
  셀렉터에 의사 요소가 있는 경우, 셀렉터의 <a href="#subject">대상</a>을 나타내는 심플 셀렉터 시퀀스 뒤에 나타나야만 합니다.
  <span class=note><strong>노트:</strong> 미래 버전의 셀렉터 스펙에서 셀렉터당 의사 요소를 여러개 허용할 가능성이 있습니다</span>
  <p lang=en>Only one pseudo-element may appear per selector, and if present it must
   appear after the sequence of simple selectors that represents the <a
   href="#subject">subjects</a> of the selector. <span
   class=note><strong>Note:</strong> A future version of this specification
   may allow multiple pseudo-elements per selector.</span>

  <h3 id=first-line><span class=secno>7.1. </span>::first-line 의사 요소</h3>
  <p lang=ko><code>::first-list</code> 의사 요소는 요소의 첫번째 줄 콘텐츠를 나타냅니다.
  <p lang=en>The <code>::first-line</code> pseudo-element describes the contents of
   the first formatted line of an element.

  <div class=example>
   <p>CSS 예제:</p>

   <pre>p::first-line { text-transform: uppercase }</pre>
   <p lang=ko>위 규칙은 "모든 <code>p</code> 요소에서, 첫번째 줄을 대문자로 표기하라"는 의미를 가집니다.
   <p lang=en>The above rule means "change the letters of the first line of every <code>p</code> element to uppercase".</p>
   <p lang=ko><code>p::first-line</code> 셀렉터는 실존하는 문서 요소에 매치하지 않습니다.
   이 셀렉터는, 적합 UA가 모든 <code>p</code> 요소의 시작 부분에 넣는 의사 요소에 매치합니다.
   <p lang=en>The selector <code>p::first-line</code> does not match any real
    document element. It does match a pseudo-element that conforming user
    agents will insert at the beginning of every <code>p</code> element.</p>
  </div>
  <p lang=ko>첫번째 줄의 길이는, 페이지 폭, 폰트 사이즈 등 여러 조건에 의존합니다.
    아래와 같은 HTML 문장을 생각해봅시다:
  <p lang=en>Note that the length of the first line depends on a number of factors,
   including the width of the page, the font size, etc. Thus, an ordinary
   HTML paragraph such as:

  <pre>
&lt;P&gt;This is a somewhat long HTML 
paragraph that will be broken into several 
lines. The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>
  <p lang=ko>이 문장이 아래와 같이 행이 나뉘어 표시되었다고 생각합시다:
  <p lang=en>the lines of which happen to be broken as follows:

  <pre>
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag 
sequence. The other lines will be treated as 
ordinary lines in the paragraph.
</pre>
  <p lang=ko>이 문장은 UA에 의해, <code>::first-line</code>의 <em>가상 태그 시퀀스</em>를 포함하도록 "재작성" 될 수 있습니다.
    이 가상 태그 시퀀스는 어떻게 속성이 상속되어야 하는지 알기 쉽게 합니다.
  <p lang=en>This paragraph might be "rewritten" by user agents to include the
   <em>fictional tag sequence</em> for <code>::first-line</code>. This
   fictional tag sequence helps to show how properties are inherited.

  <pre>
&lt;P&gt;<b>&lt;P::first-line&gt;</b> This is a somewhat long HTML 
paragraph that <b>&lt;/P::first-line&gt;</b> will be broken into several
lines. The first line will be identified 
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>
  <p lang=ko>
    가상 요소가 실제로 존재하는 요소에 의해 분해되는 경우 상정 가능한 결과는,
    가상 태그 시퀀스로 인해 그 요소가 다히며, 직후에 다시 여는 형태를 생각할 수 있습니다.
    첫번째 문장이 <code>span</code> 요소로 마크업 된 상황을 생각해봅시다:
  <p lang=en>If a pseudo-element breaks up a real element, the desired effect can
   often be described by a fictional tag sequence that closes and then
   re-opens the element. Thus, if we mark up the previous paragraph with a
   <code>span</code> element:

  <pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

  <p lang=ko>유저 에이전트는 <code>::first-line</code>으로 인한 가상 태그 시퀀스를 넣을 때,
  <code>span</code>의 시작 태그와 종료 태그를 아래와 같이 넣을 거라 생각할 수 있습니다.
  <p>
   the user agent could simulate start and end tags for <code>span</code>
   when inserting the fictional tag sequence for <code>::first-line</code>.

  <pre>
&lt;P&gt;&lt;P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

  <h4 id=first-formatted-line><span class=secno>7.1.1. </span>CSS에서 정의된 <dfn id=first-formatted-line0>첫번째 형태를 가진 행</dfn></h4>
  <p lang=ko>CSS에서, <code>::first-line</code> 의사 요소는 block box, inline-block, table-caption, table-cell 같은 블럭류 컨테이너에서만 기능합니다.
  <p lang=en>In CSS, the <code>::first-line</code> pseudo-element can only have an
   effect when attached to a block-like container such as a block box,
   inline-block, table-caption, or table-cell.
  <p lang=ko>요소의 첫번째 형태를 가진 행은, 같은 플로우 안의 자손 블 (position이나 float에 의해 통상 flow에서 벗어난 블록이 아닌 것)에 의존할 수도 있습니다.
    예를 들어, <code>&lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt;</code>라는 마크업에서 <code>DIV</code>의 첫번째 행은,
    <code>p</code>의 첫번째 행이 됩니다. (<code>P</code>와 <code>DIV</code> 양쪽 다 블록이라고 했을 때)
  <p lang=en>The first formatted line of an element may occur inside a block-level
   descendant in the same flow (i.e., a block-level descendant that is not
   out-of-flow due to floating or positioning). For example, the first line
   of the <code>DIV</code> in <code>&lt;DIV>&lt;P>This
   line...&lt;/P>&lt/DIV></code> is the first line of the <code>P</code>
   (assuming that both <code>P</code> and <code>DIV</code> are block-level).
  <p lang=ko>table-cell이나 inline-block의 첫번째 행은,
    선조 요소의 첫번째 형태를 가진 행이 되지 않습니다.
    즉, <code>&lt;DIV&gt;&lt;P
   STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
   etcetera&lt;/DIV&gt;</code> 마크업의 <code>DIV</code>의 형태를 가진 행은 "Hello"가 아닙니다.
  <p lang=en>The first line of a table-cell or inline-block cannot be the first
   formatted line of an ancestor element. Thus, in <code>&lt;DIV&gt;&lt;P
   STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
   etcetera&lt;/DIV&gt;</code> the first formatted line of the <code>DIV
   </code> is not the line "Hello".
  <p class=note lang=ko><strong>노트:</strong> <code>&lt;p&gt&lt;br&gt;First...</code> 마크업에서
    <code>p</code>의 첫번째 행에는 문자를 포함하지 않습니다(<code>br</code>은 HTML4 기본 스타일이 적용되어있는 것으로 간주어집니다).
    따라서, "First"라는 단어는 첫번째 형태를 가진 행에 포함하지 않습니다.
  <p class=note lang=en><strong>Note:</strong> Note that the first line of the
   <code>p</code> in this fragment: <code>&lt;p&gt&lt;br&gt;First...</code>
   doesn't contain any letters (assuming the default style for
   <code>br</code> in HTML 4). The word "First" is not on the first formatted
   line.
  <p lang=ko>UA는 <code>::first-line</code> 의사 요소에 대해, 가상의 여는 태그가
  그걸 둘러싼 요소 중 가장 안쪽에 있는 블록 요소 중 중첩되는 것으로 행동해야 합니다.
  (단 CSS1과 CSS2는 이 상태에 대해 어떤 설명도 하지 않기 때문에,
   제작자는 이 행동에 의존하지 않아도 됩니다) 예를 들어,
   아래와 같은 가상 태그 시퀀스가 있습니다.
  <p lang=en>A UA should act as if the fictional start tags of the
   <code>::first-line</code> pseudo-elements were nested just inside the
   innermost enclosing block-level element. (Since CSS1 and CSS2 were silent
   on this case, authors should not rely on this behavior.) For example, the
   fictional tag sequence for

  <pre>
&lt;DIV>
  &lt;P>First paragraph&lt;/P>
  &lt;P>Second paragraph&lt;/P>
&lt;/DIV>
</pre>

  <p>는

  <pre>
&lt;DIV>
  &lt;P>&lt;DIV::first-line>&lt;P::first-line>First paragraph&lt;/P::first-line>&lt;/DIV::first-line>&lt;/P>
  &lt;P>&lt;P::first-line>Second paragraph&lt;/P::first-line>&lt;/P>
&lt;/DIV>
</pre>

  <p lang=ko><code>::first-line</code> 의사 요소는 인라인 요소와 비슷하지만, 몇가지 제약이 있습니다.
   <code>::first-line</code> 가상 요소에는 아래 CSS 속성만 허용합니다:
   font 속성, color 속성, background 속성, &lsquo;<code
   class=property>word-spacing</code>&rsquo;, &lsquo;<code
   class=property>letter-spacing</code>&rsquo;, &lsquo;<code
   class=property>text-decoration</code>&rsquo;, &lsquo;<code
   class=property>vertical-align</code>&rsquo;, &lsquo;<code
   class=property>text-transform</code>&rsquo;, &lsquo;<code
   class=property>line-height</code>&rsquo;.
   UA에서 다른 속성을 허용할 수도 있습니다.
  <p lang=en>The <code>::first-line</code> pseudo-element is similar to an
   inline-level element, but with certain restrictions. The following CSS
   properties apply to a <code>::first-line</code> pseudo-element: font
   properties, color property, background properties, &lsquo;<code
   class=property>word-spacing</code>&rsquo;, &lsquo;<code
   class=property>letter-spacing</code>&rsquo;, &lsquo;<code
   class=property>text-decoration</code>&rsquo;, &lsquo;<code
   class=property>vertical-align</code>&rsquo;, &lsquo;<code
   class=property>text-transform</code>&rsquo;, &lsquo;<code
   class=property>line-height</code>&rsquo;. UAs may apply other properties
   as well.

  <p lang=ko>CSS 상속에 있어, 자식 요소의 일부가 첫번째 행인 경우 <code>::first-line</code> 의사 요소에 적용 가능한 속성만을 <code>::first-line</code> 의사 요소에서 상속받습니다.
    그 외의 속성에 대해서는, <code>::first-line</code>의 부모 중 의사 요소가 아닌 것에서 상속합니다.
    첫번째 행이 아닌 자식 요소의 일부는 그 부모에서 상속합니다.
  <p lang=en>During CSS inheritance, the portion of a child element that occurs on
   the first line only inherits properties applicable to the
   <code>::first-line</code> pseudo-element from the
   <code>::first-line</code> pseudo-element. For all other properties
   inheritence is from the non-pseudo-element parent of the first line pseudo
   element. (The portion of a child element that does not occur on the first
   line always inherits from the parent of that child.)

  <h3 id=first-letter><span class=secno>7.2. </span>::first-letter 의사 요소</h3>

  <p lang=ko><code>::first-letter</code> 의사 요소는 요소의 첫번째 문자를 나타냅니다.
    해당 줄에서 요소의 앞에 이미지나 인라인 테이블 등 다른 내용이 있는 경우 매치하지 않습니다.
    <code>::first-letter</code> 의사 요소는 "initial caps"와 "drop caps" 같이
    ㅌ자주 사용하는 타이포 그래피 효과를 얻기 위해 사용합니다.
  <p lang=en>The <code>::first-letter</code> pseudo-element represents the first
   letter of an element, if it is not preceded by any other content (such as
   images or inline tables) on its line. The ::first-letter pseudo-element
   may be used for "initial caps" and "drop caps", which are common
   typographical effects.

  <p lang=ko>Unicode에서 "open" (Ps), "close" (Pe), "initial" (Pi), "final" (Pf) and "other" (Po) 클래스에 분류되는 기호가
    행의 첫번째 문자거나 행의 첫번째 문자 직후에 나오는 경우, 그 또한 <code>::first-letter</code>에 포함하여야 합니다. <a
   href="#UNICODE" rel=biblioentry>[UNICODE]<!--{{!UNICODE}}--></a>
  <p lang=en>Punctuation (i.e, characters defined in Unicode in the "open" (Ps),
   "close" (Pe), "initial" (Pi). "final" (Pf) and "other" (Po) punctuation
   classes), that precedes or follows the first letter should be included. <a
   href="#UNICODE" rel=biblioentry>[UNICODE]<!--{{!UNICODE}}--></a>

  <div class=figure>
   <p><img alt="Quotes that precede the first letter should be included."
    src=first-letter2.png></p>
  </div>

  <p lang=ko><code>::first-letter</code>는 첫번쨰 글자가 숫자인 경우,
    예를 들어 "67 million dollares is a lot of money"라는 문장에서 "6"에도 적용됩니다.
  <p lang=en>The <code>::first-letter</code> also applies if the first letter is in
   fact a digit, e.g., the "6" in "67 million dollars is a lot of money."

  <p class=note><strong>Note:</strong> In some cases the
   <code>::first-letter</code> pseudo-element should include more than just
   the first non-punctuation character on a line. For example, combining
   characters must be kept with their base character. Additionally, some
   languages may have specific rules about how to treat certain letter
   combinations. The UA definition of <code>::first-letter</code> should
   include at least the default grapheme cluster as defined by UAX29 and may
   include more than that as appropriate. In Dutch, for example, if the
   letter combination "ij" appears at the beginning of an element, both
   letters should be considered within the <code>::first-letter</code>
   pseudo-element. <a href="#UAX29"
   rel=biblioentry>[UAX29]<!--{{UAX29}}--></a>

  <p>If the letters that would form the <code>::first-letter</code> are not
   in the same element, such as "&lsquo;<code class=css>T" in
   <code>&lt;p>'&lt;em>T...</code>, the UA may create a
   <code>::first-letter</code> pseudo-element from one of the elements, both
   elements, or simply not create a pseudo-element.</code>

  <p>Similarly, if the first letter(s) of the block are not at the start of
   the line (for example due to bidirectional reordering), then the UA need
   not create the pseudo-element(s).

  <div class=example>
   <p>Example:</p>

   <p><a name=overlapping-example>The following CSS and HTML example</a>
    illustrates how overlapping pseudo-elements may interact. The first
    letter of each P element will be green with a font size of &rsquo;24pt'.
    The rest of the first formatted line will be &lsquo;<code
    class=property>blue</code>&rsquo; while the rest of the paragraph will be
    &lsquo;<code class=property>red</code>&rsquo;.</p>

   <pre>p { color: red; font-size: 12pt }
p::first-letter { color: green; font-size: 200% }
p::first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;</pre>

   <p>Assuming that a line break will occur before the word "ends", the <span
    class=index-inst id=fictional-tag-sequence title="fictional tag
    sequence">fictional tag sequence</span> for this fragment might be:</p>

   <pre>&lt;P&gt;
&lt;P::first-line&gt;
&lt;P::first-letter&gt; 
S 
&lt;/P::first-letter&gt;ome text that 
&lt;/P::first-line&gt; 
ends up on two lines 
&lt;/P&gt;</pre>

   <p>Note that the <code>::first-letter</code> element is inside the
    <code>::first-line</code> element. Properties set on
    <code>::first-line</code> are inherited by <code>::first-letter</code>,
    but are overridden if the same property is set on
    <code>::first-letter</code>.</p>
  </div>

  <p>The first letter must occur on the <a href="#first-formatted-line">first
   formatted line.</a> For example, in this HTML fragment:
   <code>&lt;p&gt&lt;br&gt;First...</code> the first line doesn't contain any
   letters and <code>::first-letter</code> doesn't match anything (assuming
   the default style for <code>br</code> in HTML 4). In particular, it does
   not match the "F" of "First."

  <h4 id=application-in-css><span class=secno>7.2.1. </span>Application in
   CSS</h4>

  <p>In CSS, the <code>::first-letter</code> pseudo-element applies to
   block-like containers such as block, list-item, table-cell, table-caption,
   and inline-block elements. <span class=note><strong>Note:</strong> A
   future version of this specification may allow this pseudo-element to
   apply to more display types.</span>

  <p>The <code>::first-letter</code> pseudo-element can be used with all such
   elements that contain text, or that have a descendant in the same flow
   that contains text. A UA should act as if the fictional start tag of the
   ::first-letter pseudo-element is just before the first text of the
   element, even if that first text is in a descendant.

  <div class=example>
   <p>Example:</p>

   <p>The fictional tag sequence for this HTML fragment:

   <pre>&lt;div>
&lt;p>The first text.</pre>

   <p>is:

   <pre>&lt;div>
&lt;p>&lt;div::first-letter>&lt;p::first-letter>T&lt;/...>&lt;/...>he first text.</pre>
  </div>

  <p>In CSS the first letter of a table-cell or inline-block cannot be the
   first letter of an ancestor element. Thus, in <code>&lt;DIV&gt;&lt;P
   STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
   etcetera&lt;/DIV&gt;</code> the first letter of the <code>DIV</code> is
   not the letter "H". In fact, the <code>DIV</code> doesn't have a first
   letter.

  <p>If an element is a list item (&lsquo;<code class=css>display:
   list-item</code>&rsquo;), the <code>::first-letter</code> applies to the
   first letter in the principal box after the marker. UAs may ignore
   <code>::first-letter</code> on list items with &lsquo;<code
   class=css>list-style-position: inside</code>&rsquo;. If an element has
   <code>::before</code> or <code>::after</code> content, the
   <code>::first-letter</code> applies to the first letter of the element
   <em>including</em> that content.

  <div class=example>
   <p>Example:</p>

   <p>After the rule <code>p::before {content: "Note: "}</code>, the selector
    <code>p::first-letter</code> matches the "N" of "Note".</p>
  </div>

  <p>In CSS a ::first-line pseudo-element is similar to an inline-level
   element if its &lsquo;<code class=property>float</code>&rsquo; property is
   &lsquo;<code class=property>none</code>&rsquo;; otherwise, it is similar
   to a floated element. The following properties that apply to
   <code>::first-letter</code> pseudo-elements: font properties, &lsquo;<code
   class=property>text-decoration</code>&rsquo;, &lsquo;<code
   class=property>text-transform</code>&rsquo;, &lsquo;<code
   class=property>letter-spacing</code>&rsquo;, &lsquo;<code
   class=property>word-spacing</code>&rsquo; (when appropriate), &lsquo;<code
   class=property>line-height</code>&rsquo;, &lsquo;<code
   class=property>float</code>&rsquo;, &lsquo;<code
   class=property>vertical-align</code>&rsquo; (only if &lsquo;<code
   class=property>float</code>&rsquo; is &lsquo;<code
   class=property>none</code>&rsquo;), margin properties, padding properties,
   border properties, color property, background properties. UAs may apply
   other properties as well. To allow UAs to render a typographically correct
   drop cap or initial cap, the UA may choose a line-height, width and height
   based on the shape of the letter, unlike for normal elements.

  <div class=example>
   <p>Example:</p>

   <p>This CSS and HTML example shows a possible rendering of an initial cap.
    Note that the &lsquo;<code class=property>line-height</code>&rsquo; that
    is inherited by the <code>::first-letter</code> pseudo-element is 1.1,
    but the UA in this example has computed the height of the first letter
    differently, so that it doesn't cause any unnecessary space between the
    first two lines. Also note that the fictional start tag of the first
    letter is inside the <span>span</span>, and thus the font weight of the
    first letter is normal, not bold as the <span>span</span>:

   <pre>
p { line-height: 1.1 }
p::first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p>&lt;span>Het hemelsche&lt;/span> gerecht heeft zich ten lange lesten&lt;br>
Erbarremt over my en mijn benaeuwde vesten&lt;br>
En arme burgery, en op mijn volcx gebed&lt;br>
En dagelix geschrey de bange stad ontzet.
</pre>

   <div class=figure>
    <p><img alt="Image illustrating the ::first-letter pseudo-element"
     src=initial-cap.png>
   </div>
  </div>

  <div class=example>
   <p>The following CSS will make a drop cap initial letter span about two
    lines:</p>

   <pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P               { font-size: 12pt; line-height: 1.2 }
   P::first-letter { font-size: 200%; font-weight: bold; float: left }
   SPAN            { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

   <p>This example might be formatted as follows:</p>

   <div class=figure>
    <p><img alt="Image illustrating the combined effect of the ::first-letter
     and ::first-line pseudo-elements" src=first-letter.png></p>
   </div>

   <p>The <span class=index-inst id=fictional-tag-sequence0 title="fictional
    tag sequence">fictional tag sequence</span> is:</p>

   <pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P::first-letter&gt;
T
&lt;/P::first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

   <p>Note that the <code>::first-letter</code> pseudo-element tags abut the
    content (i.e., the initial character), while the ::first-line
    pseudo-element start tag is inserted right after the start tag of the
    block element.</p>
  </div>

  <p>In order to achieve traditional drop caps formatting, user agents may
   approximate font sizes, for example to align baselines. Also, the glyph
   outline may be taken into account when formatting.

  <h3 id=selection><span class=secno>7.3. </span>Blank</h3>

  <p>This section intentionally left blank. (This section previously defined
   a <code>::selection</code> pseudo-element.)

  <h3 id=gen-content><span class=secno>7.4. </span>The ::before and ::after
   pseudo-elements</h3>

  <p>The <code>::before</code> and <code>::after</code> pseudo-elements can
   be used to describe generated content before or after an element's
   content. They are explained in CSS 2.1 <a href="#CSS21"
   rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>.

  <p>When the <code>::first-letter</code> and <code>::first-line</code>
   pseudo-elements are applied to an element having content generated using
   <code>::before</code> or <code>::after</code>, they apply to the first
   letter or line of the element including the generated content.

  <h2 id=combinators><span class=secno>8. </span>Combinators</h2>

  <h3 id=descendant-combinators><span class=secno>8.1. </span>Descendant
   combinator</h3>

  <p>At times, authors may want selectors to describe an element that is the
   descendant of another element in the document tree (e.g., "an
   <code>EM</code> element that is contained within an <code>H1</code>
   element"). Descendant combinators express such a relationship. A
   descendant combinator is <a href="#whitespace">whitespace</a> that
   separates two sequences of simple selectors. A selector of the form
   "<code>A B</code>" represents an element <code>B</code> that is an
   arbitrary descendant of some ancestor element <code>A</code>.

  <div class=example>
   <p>Examples:</p>

   <p>For example, consider the following selector:</p>

   <pre>h1 em</pre>

   <p>It represents an <code>em</code> element being the descendant of an
    <code>h1</code> element. It is a correct and valid, but partial,
    description of the following fragment:</p>

   <pre>&lt;h1&gt;This &lt;span class="myclass"&gt;headline
is &lt;em&gt;very&lt;/em&gt; important&lt;/span&gt;&lt;/h1&gt;</pre>

   <p>The following selector:</p>

   <pre>div * p</pre>

   <p>represents a <code>p</code> element that is a grandchild or later
    descendant of a <code>div</code> element. Note the whitespace on either
    side of the "*" is not part of the universal selector; the whitespace is
    a combinator indicating that the <code>div</code> must be the ancestor of
    some element, and that that element must be an ancestor of the
    <code>p</code>.</p>

   <p>The following selector, which combines descendant combinators and <a
    href="#attribute-selectors">attribute selectors</a>, represents an
    element that (1) has the <code>href</code> attribute set and (2) is
    inside a <code>p</code> that is itself inside a <code>div</code>:</p>

   <pre>div p *[href]</pre>
  </div>

  <h3 id=child-combinators><span class=secno>8.2. </span>Child combinators</h3>

  <p>A <dfn id=child-combinator>child combinator</dfn> describes a childhood
   relationship between two elements. A child combinator is made of the
   &quot;greater-than sign&quot; (U+003E, <code>&gt;</code>) character and
   separates two sequences of simple selectors.

  <div class=example>
   <p>Examples:</p>

   <p>The following selector represents a <code>p</code> element that is
    child of <code>body</code>:</p>

   <pre>body &gt; p</pre>

   <p>The following example combines descendant combinators and child
    combinators.</p>

   <pre>div ol&gt;li p</pre>
   <!-- LEAVE THOSE SPACES OUT! see below -->
   <p>It represents a <code>p</code> element that is a descendant of an
    <code>li</code> element; the <code>li</code> element must be the child of
    an <code>ol</code> element; the <code>ol</code> element must be a
    descendant of a <code>div</code>. Notice that the optional white space
    around the "&gt;" combinator has been left out.</p>
  </div>

  <p>For information on selecting the first child of an element, please see
   the section on the <code><a
   href="#structural-pseudos">:first-child</a></code> pseudo-class above.

  <h3 id=sibling-combinators><span class=secno>8.3. </span>Sibling
   combinators</h3>

  <p>There are two different sibling combinators: the adjacent sibling
   combinator and the general sibling combinator. In both cases, non-element
   nodes (e.g. text between elements) are ignored when considering adjacency
   of elements.

  <h4 id=adjacent-sibling-combinators><span class=secno>8.3.1.
   </span>Adjacent sibling combinator</h4>

  <p>The adjacent sibling combinator is made of the &quot;plus sign&quot;
   (U+002B, <code>+</code>) character that separates two sequences of simple
   selectors. The elements represented by the two sequences share the same
   parent in the document tree and the element represented by the first
   sequence immediately precedes the element represented by the second one.

  <div class=example>
   <p>Examples:</p>

   <p>The following selector represents a <code>p</code> element immediately
    following a <code>math</code> element:</p>

   <pre>math + p</pre>

   <p>The following selector is conceptually similar to the one in the
    previous example, except that it adds an attribute selector &mdash; it
    adds a constraint to the <code>h1</code> element, that it must have
    <code>class="opener"</code>:</p>

   <pre>h1.opener + h2</pre>
  </div>

  <h4 id=general-sibling-combinators><span class=secno>8.3.2. </span>General
   sibling combinator</h4>

  <p>The general sibling combinator is made of the &quot;tilde&quot; (U+007E,
   <code>~</code>) character that separates two sequences of simple
   selectors. The elements represented by the two sequences share the same
   parent in the document tree and the element represented by the first
   sequence precedes (not necessarily immediately) the element represented by
   the second one.

  <div class=example>
   <p>Example:</p>

   <pre>h1 ~ pre</pre>

   <p>represents a <code>pre</code> element following an <code>h1</code>. It
    is a correct and valid, but partial, description of:</p>

   <pre>&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;</pre>
  </div>

  <h2 id=specificity><span class=secno>9. </span>Calculating a selector's
   specificity</h2>

  <p>A selector's specificity is calculated as follows:

  <ul>
   <li>count the number of ID selectors in the selector (= a)

   <li>count the number of class selectors, attributes selectors, and
    pseudo-classes in the selector (= b)

   <li>count the number of type selectors and pseudo-elements in the selector
    (= c)

   <li>ignore the universal selector
  </ul>

  <p>Selectors inside <a href="#negation">the negation pseudo-class</a> are
   counted like any other, but the negation itself does not count as a
   pseudo-class.

  <p>Concatenating the three numbers a-b-c (in a number system with a large
   base) gives the specificity.

  <div class=example>
   <p>Examples:</p>

   <pre>*               /* a=0 b=0 c=0 -&gt; specificity =   0 */
LI              /* a=0 b=0 c=1 -&gt; specificity =   1 */
UL LI           /* a=0 b=0 c=2 -&gt; specificity =   2 */
UL OL+LI        /* a=0 b=0 c=3 -&gt; specificity =   3 */
H1 + *[REL=up]  /* a=0 b=1 c=1 -&gt; specificity =  11 */
UL OL LI.red    /* a=0 b=1 c=3 -&gt; specificity =  13 */
LI.red.level    /* a=0 b=2 c=1 -&gt; specificity =  21 */
#x34y           /* a=1 b=0 c=0 -&gt; specificity = 100 */
#s12:not(FOO)   /* a=1 b=0 c=1 -&gt; specificity = 101 */
</pre>
  </div>

  <p class=note><strong>Note:</strong> Repeated occurrances of the same
   simple selector are allowed and do increase specificity.

  <p class=note><strong>Note:</strong> the specificity of the styles
   specified in an HTML <code>style</code> attribute is described in CSS 2.1.
   <a href="#CSS21" rel=biblioentry>[CSS21]<!--{{!CSS21}}--></a>.

  <h2 id=w3cselgrammar><span class=secno>10. </span>The grammar of Selectors</h2>

  <h3 id=grammar><span class=secno>10.1. </span>Grammar</h3>

  <p>The grammar below defines the syntax of Selectors. It is globally LL(1)
   and can be locally LL(2) (but note that most UAs should not use it
   directly, since it doesn't express the parsing conventions). The format of
   the productions is optimized for human consumption and some shorthand
   notations beyond Yacc (see <a href="#YACC"
   rel=biblioentry>[YACC]<!--{{!YACC}}--></a>) are used:

  <ul>
   <li><b>*</b>: 0 or more

   <li><b>+</b>: 1 or more

   <li><b>?</b>: 0 or 1

   <li><b>|</b>: separates alternatives

   <li><b>[ ]</b>: grouping
  </ul>

  <p>The productions are:

  <pre>selectors_group
  : selector [ COMMA S* selector ]*
  ;

selector
  : simple_selector_sequence [ combinator simple_selector_sequence ]*
  ;

combinator
  /* combinators can be surrounded by whitespace */
  : PLUS S* | GREATER S* | TILDE S* | S+
  ;

simple_selector_sequence
  : [ type_selector | universal ]
    [ HASH | class | attrib | pseudo | negation ]*
  | [ HASH | class | attrib | pseudo | negation ]+
  ;

type_selector
  : [ namespace_prefix ]? element_name
  ;

namespace_prefix
  : [ IDENT | '*' ]? '|'
  ;

element_name
  : IDENT
  ;

universal
  : [ namespace_prefix ]? '*'
  ;

class
  : '.' IDENT
  ;

attrib
  : '[' S* [ namespace_prefix ]? IDENT S*
        [ [ PREFIXMATCH |
            SUFFIXMATCH |
            SUBSTRINGMATCH |
            '=' |
            INCLUDES |
            DASHMATCH ] S* [ IDENT | STRING ] S*
        ]? ']'
  ;

pseudo
  /* '::' starts a pseudo-element, ':' a pseudo-class */
  /* Exceptions: :first-line, :first-letter, :before and :after. */
  /* Note that pseudo-elements are restricted to one per selector and */
  /* occur only in the last simple_selector_sequence. */
  : ':' ':'? [ IDENT | functional_pseudo ]
  ;

functional_pseudo
  : FUNCTION S* expression ')'
  ;

expression
  /* In CSS3, the expressions are identifiers, strings, */
  /* or of the form "an+b" */
  : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
  ;

negation
  : NOT S* negation_arg S* ')'
  ;

negation_arg
  : type_selector | universal | HASH | class | attrib | pseudo
  ;</pre>

  <h3 id=lex><span class=secno>10.2. </span>Lexical scanner</h3>

  <p>The following is the <a name=x3>tokenizer</a>, written in Flex (see <a
   href="#FLEX" rel=biblioentry>[FLEX]<!--{{!FLEX}}--></a>) notation. The
   tokenizer is case-insensitive.

  <p>The two occurrences of "\377" represent the highest character number
   that current versions of Flex can deal with (decimal 255). They should be
   read as "\4177777" (decimal 1114111), which is the highest possible code
   point in Unicode/ISO-10646. <a href="#UNICODE"
   rel=biblioentry>[UNICODE]<!--{{!UNICODE}}--></a>

  <pre>%option case-insensitive

ident     [-]?{nmstart}{nmchar}*
name      {nmchar}+
nmstart   [_a-z]|{nonascii}|{escape}
nonascii  [^\0-\177]
unicode   \\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
escape    {unicode}|\\[^\n\r\f0-9a-f]
nmchar    [_a-z0-9-]|{nonascii}|{escape}
num       [0-9]+|[0-9]*\.[0-9]+
string    {string1}|{string2}
string1   \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*\"
string2   \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*\'
invalid   {invalid1}|{invalid2}
invalid1  \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*
invalid2  \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*
nl        \n|\r\n|\r|\f
w         [ \t\r\n\f]*

D         d|\\0{0,4}(44|64)(\r\n|[ \t\r\n\f])?
E         e|\\0{0,4}(45|65)(\r\n|[ \t\r\n\f])?
N         n|\\0{0,4}(4e|6e)(\r\n|[ \t\r\n\f])?|\\n
O         o|\\0{0,4}(4f|6f)(\r\n|[ \t\r\n\f])?|\\o
T         t|\\0{0,4}(54|74)(\r\n|[ \t\r\n\f])?|\\t
V         v|\\0{0,4}(58|78)(\r\n|[ \t\r\n\f])?|\\v

%%

[ \t\r\n\f]+     return S;

"~="             return INCLUDES;
"|="             return DASHMATCH;
"^="             return PREFIXMATCH;
"$="             return SUFFIXMATCH;
"*="             return SUBSTRINGMATCH;
{ident}          return IDENT;
{string}         return STRING;
{ident}"("       return FUNCTION;
{num}            return NUMBER;
"#"{name}        return HASH;
{w}"+"           return PLUS;
{w}"&gt;"           return GREATER;
{w}","           return COMMA;
{w}"~"           return TILDE;
":"{N}{O}{T}"("  return NOT;
@{ident}         return ATKEYWORD;
{invalid}        return INVALID;
{num}%           return PERCENTAGE;
{num}{ident}     return DIMENSION;
"&lt;!--"           return CDO;
"--&gt;"            return CDC;

\/\*[^*]*\*+([^/*][^*]*\*+)*\/                    /* ignore comments */

.                return *yytext;</pre>

  <h2 id=profiling><span class=secno>11. </span>Profiles</h2>

  <p>Each specification using Selectors must define the subset of Selectors
   it allows and excludes, and describe the local meaning of all the
   components of that subset.

  <p>Non normative examples:

  <div class=profile>
   <table class=tprofile>
    <tbody>
     <tr>
      <th class=title colspan=2>Selectors profile

     <tr>
      <th>Specification

      <td>CSS level 1

     <tr>
      <th>Accepts

      <td>type selectors<br>
       class selectors<br>
       ID selectors<br>
       :link, :visited and :active pseudo-classes<br>
       descendant combinator <br>
       ::first-line and ::first-letter pseudo-elements

     <tr>
      <th>Excludes

      <td>
       <p>universal selector<br>
        attribute selectors<br>
        :hover and :focus pseudo-classes<br>
        :target pseudo-class<br>
        :lang() pseudo-class<br>
        all UI element states pseudo-classes<br>
        all structural pseudo-classes<br>
        negation pseudo-class<br>
        ::before and ::after pseudo-elements<br>
        child combinators<br>
        sibling combinators

       <p>namespaces

     <tr>
      <th>Extra constraints

      <td>only one class selector allowed per sequence of simple selectors
   </table>
   <br>
   <br>

   <table class=tprofile>
    <tbody>
     <tr>
      <th class=title colspan=2>Selectors profile

     <tr>
      <th>Specification

      <td>CSS level 2

     <tr>
      <th>Accepts

      <td>type selectors<br>
       universal selector<br>
       attribute presence and values selectors<br>
       class selectors<br>
       ID selectors<br>
       :link, :visited, :active, :hover, :focus, :lang() and :first-child
       pseudo-classes <br>
       descendant combinator<br>
       child combinator<br>
       adjacent sibling combinator<br>
       ::first-line and ::first-letter pseudo-elements<br>
       ::before and ::after pseudo-elements

     <tr>
      <th>Excludes

      <td>
       <p>substring matching attribute selectors<br>
        :target pseudo-classes<br>
        all UI element states pseudo-classes<br>
        all structural pseudo-classes other than :first-child<br>
        negation pseudo-class <br>
        general sibling combinators

       <p>namespaces

     <tr>
      <th>Extra constraints

      <td>more than one class selector per sequence of simple selectors (CSS1
       constraint) allowed
   </table>

   <p>In CSS, selectors express pattern matching rules that determine which
    style rules apply to elements in the document tree.

   <p>The following selector (CSS level 2) will <b>match</b> all anchors
    <code>a</code> with attribute <code>name</code> set inside a section 1
    header <code>h1</code>:

   <pre>h1 a[name]</pre>

   <p>All CSS declarations attached to such a selector are applied to
    elements matching it.
  </div>

  <div class=profile>
   <table class=tprofile>
    <tbody>
     <tr>
      <th class=title colspan=2>Selectors profile

     <tr>
      <th>Specification

      <td>STTS 3

     <tr>
      <th>Accepts

      <td>
       <p>type selectors<br>
        universal selectors<br>
        attribute selectors<br>
        class selectors<br>
        ID selectors<br>
        all structural pseudo-classes<br>
        all combinators

       <p>namespaces

     <tr>
      <th>Excludes

      <td>non-accepted pseudo-classes<br>
       pseudo-elements<br>

     <tr>
      <th>Extra constraints

      <td>some selectors and combinators are not allowed in fragment
       descriptions on the right side of STTS declarations.
   </table>

   <p>Selectors can be used in STTS 3 in two different manners:

   <ol>
    <li>a selection mechanism equivalent to CSS selection mechanism:
     declarations attached to a given selector are applied to elements
     matching that selector,

    <li>fragment descriptions that appear on the right side of declarations.
   </ol>
  </div>

  <h2 id=Conformance><span class=secno>12. </span>Conformance and
   requirements</h2>

  <p>This section defines conformance with the present specification only.

  <p>The inability of a user agent to implement part of this specification
   due to the limitations of a particular device (e.g., non interactive user
   agents will probably not implement dynamic pseudo-classes because they
   make no sense without interactivity) does not imply non-conformance.

  <p>All specifications reusing Selectors must contain a <a
   href="#profiling">Profile</a> listing the subset of Selectors it accepts
   or excludes, and describing the constraints it adds to the current
   specification.

  <p>Invalidity is caused by a parsing error, e.g. an unrecognized token or a
   token which is not allowed at the current parsing point.

  <p>User agents must observe the rules for handling parsing errors:

  <ul>
   <li>a simple selector containing an <a href="#nsdecl">undeclared namespace
    prefix</a> is invalid

   <li>a selector containing an invalid simple selector, an invalid
    combinator or an invalid token is invalid.

   <li>a group of selectors containing an invalid selector is invalid.
  </ul>

  <p>Specifications reusing Selectors must define how to handle parsing
   errors. (In the case of CSS, the entire rule in which the selector is used
   is dropped.)

  <h2 id=Tests><span class=secno>13. </span>Tests</h2>

  <p>This specification has <a
   href="http://www.w3.org/Style/CSS/Test/CSS3/Selectors/current/">a test
   suite</a> allowing user agents to verify their basic conformance to the
   specification. This test suite does not pretend to be exhaustive and does
   not cover all possible combined cases of Selectors.

  <h2 id=ACKS><span class=secno>14. </span>Acknowledgements</h2>

  <p>The CSS working group would like to thank everyone who has sent comments
   on this specification over the years.

  <p>In particular, the working group would like to extend special thanks to
   Donna McManus, Justin Baker, Joel Sklar, and Molly Ives Brower who
   performed the final editorial review of the last call draft. The working
   group would also like to thank Adam Kuehn, Boris Zbarsky, David Perrell,
   Elliotte Harold, Matthew Raymond, Ruud Steltenpool, Patrick Garies, Anton
   Prowse, and the W3C Internationalization Working Group for their last call
   comments and kind words.

  <h2 id=references><span class=secno>15. </span>References</h2>

  <h3 id=normative-references><span class=secno>15.1. </span>Normative
   References</h3>
  <!--begin-normative-->
  <!-- Sorted by label -->

  <dl class=bibliography>
   <dt style="display: none"><!-- keeps the doc valid if the DL is empty -->
    <!---->

   <dt id=CSS21>[CSS21]

   <dd>Bert Bos; et al. <a
    href="http://www.w3.org/TR/2009/CR-CSS2-20090908"><cite>Cascading Style
    Sheets Level 2 Revision 1 (CSS 2.1) Specification.</cite></a> 07 June 2011. W3C Recommendation.  URL: <a
    href="http://www.w3.org/TR/2011/REC-CSS2-20110607/">http://www.w3.org/TR/2011/REC-CSS2-20110607/</a>
    </dd>
   <!---->

   <dt id=CSS3NAMESPACE>[CSS3NAMESPACE]

   <dd>Elika J. Etemad; Anne van Kesteren. <a
    href="http://www.w3.org/TR/2011/REC-css3-namespace-20110929/"><cite>CSS
    Namespaces Module.</cite></a> 29 September 2011. W3C Recommendation.
    URL: <a
    href="http://www.w3.org/TR/2011/REC-css3-namespace-20110929/">http://www.w3.org/TR/2011/REC-css3-namespace-20110929/</a>
    </dd>
   <!---->

   <dt id=FLEX>[FLEX]

   <dd><cite>Flex: The Lexical Scanner Generator.</cite> Version 2.3.7, ISBN
    1882114213</dd>
   <!---->

   <dt id=UNICODE>[UNICODE]

<dd>The Unicode Consortium. The
Unicode Standard, Version 6.0.0, (Mountain View, CA: The Unicode
Consortium, 2011. ISBN 978-1-936213-01-6)
and as updated from time to time by the publication
of new versions. (See <a href="http://www.unicode.org/unicode/standard/versions/">
http://www.unicode.org/unicode/standard/versions/</a> for the latest
version and additional information on versions of the standard and of
the Unicode Character Database).<br> Available at <a href="http://www.unicode.org/versions/Unicode6.0.0/">
http://www.unicode.org/versions/Unicode6.0.0/</a>
    </dd>
   <!---->

   <dt id=YACC>[YACC]

   <dd>S. C. Johnson. <cite>YACC - Yet another compiler compiler.</cite>
    Murray Hill. 1975. Technical Report.</dd>
   <!---->
  </dl>
  <!--end-normative-->

  <h3 id=informative-references><span class=secno>15.2. </span>Informative
   References</h3>
  <!--begin-informative-->
  <!-- Sorted by label -->

  <dl class=bibliography>
   <dt style="display: none"><!-- keeps the doc valid if the DL is empty -->
    <!---->

   <dt id=BCP47>[BCP47]

   <dd>A. Phillips;  M. Davis<a
    href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt"><cite>Tags for Identifying Languages</cite> and <cite>Matching of Language Tags</cite>.</a> September 2009. Internet Best
    Current Practice 47. URL: <a
    href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">http://www.rfc-editor.org/rfc/bcp/bcp47.txt</a>
    </dd>
   <!---->

   <dt id=CSS1>[CSS1]

   <dd>H&#229;kon Wium Lie; Bert Bos. <a
    href="http://www.w3.org/TR/2008/REC-CSS1-20080411"><cite>Cascading Style
    Sheets (CSS1) Level 1 Specification.</cite></a> 11 April 2008. W3C
    Recommendation. URL: <a
    href="http://www.w3.org/TR/2008/REC-CSS1-20080411">http://www.w3.org/TR/2008/REC-CSS1-20080411</a>
    </dd>
   <!---->

   <dt id=DOM-LEVEL-3-CORE>[DOM-LEVEL-3-CORE]

   <dd>Gavin Nicol; et al. <a
    href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407"><cite>Document
    Object Model (DOM) Level 3 Core Specification.</cite></a> 7 April 2004.
    W3C Recommendation. URL: <a
    href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407</a>
    </dd>
   <!---->

   <dt id=HTML401>[HTML401]

   <dd>David Raggett; Ian Jacobs; Arnaud Le Hors. <a
    href="http://www.w3.org/TR/1999/REC-html401-19991224"><cite>HTML 4.01
    Specification.</cite></a> 24 December 1999. W3C Recommendation. URL: <a
    href="http://www.w3.org/TR/1999/REC-html401-19991224">http://www.w3.org/TR/1999/REC-html401-19991224</a>
    </dd>
   <!---->

   <dt id=MATHML>[MATHML]

   <dd>Patrick Ion; Robert Miner. <a
    href="http://www.w3.org/1999/07/REC-MathML-19990707"><cite>Mathematical
    Markup Language (MathML) 1.01 Specification.</cite></a> 7 July 1999. W3C
    Recommendation. URL: <a
    href="http://www.w3.org/1999/07/REC-MathML-19990707">http://www.w3.org/1999/07/REC-MathML-19990707</a>
    </dd>
   <!---->

   <dt id=STTS3>[STTS3]

   <dd>Daniel Glazman. <a href="http://www.w3.org/TR/NOTE-STTS3"><cite>Simple
    Tree Transformation Sheets 3.</cite></a> Electricit&#233; de France. 11
    November 1998. Submission to the W3C. URL: <a
    href="http://www.w3.org/TR/NOTE-STTS3">http://www.w3.org/TR/NOTE-STTS3</a>
    </dd>
   <!---->

   <dt id=SVG11>[SVG11]

   <dd>Erik Dahlström et. al. <a
    href="http://www.w3.org/TR/2011/REC-SVG11-20110816/"><cite>Scalable Vector
    Graphics (SVG) 1.1 Specification.</cite></a> 16 August 2011. W3C
    Recommendation. URL: <a
    href="http://www.w3.org/TR/2011/REC-SVG11-20110816/">http://www.w3.org/TR/2011/REC-SVG11-20110816/</a>
    </dd>
   <!---->

   <dt id=UAX29>[UAX29]

   <dd>Mark Davis. <a
    href="http://www.unicode.org/unicode/reports/tr29/tr29-9.html"><cite>Text
    Boundaries.</cite></a> 25 March 2005. Unicode Standard Annex #29. URL: <a
    href="http://www.unicode.org/unicode/reports/tr29/tr29-9.html">http://www.unicode.org/unicode/reports/tr29/tr29-9.html</a>
    </dd>
   <!---->

   <dt id=XML-NAMES>[XML-NAMES]

   <dd>Tim Bray; et al. <a
    href="http://www.w3.org/TR/2009/PER-xml-names-20090806"><cite>Namespaces
    in XML 1.0 (Third Edition).</cite></a> 6 August 2009. W3C Proposed Edited
    Recommendation. URL: <a
    href="http://www.w3.org/TR/2009/PER-xml-names-20090806">http://www.w3.org/TR/2009/PER-xml-names-20090806</a>
    </dd>
   <!---->

   <dt id=XML10>[XML10]

   <dd>C. M. Sperberg-McQueen; et al. <a
    href="http://www.w3.org/TR/2008/PER-xml-20080205"><cite>Extensible Markup
    Language (XML) 1.0 (Fifth Edition).</cite></a> 10 February 1998. W3C
    Proposed Edited Recommendation. Revised 5 February 2008 URL: <a
    href="http://www.w3.org/TR/2008/PER-xml-20080205">http://www.w3.org/TR/2008/PER-xml-20080205</a>
    </dd>
   <!---->
  </dl>
  <!--end-informative-->
